--- a/libavcodec/mlp.h	2013-03-20 17:36:45.000000000 -0700
+++ b/libavcodec/mlp.h.new	2015-05-04 06:53:48.644996105 -0700
@@ -45,7 +45,7 @@
 /** Maximum number of substreams that can be decoded.
  *  MLP's limit is 2. TrueHD supports at least up to 3.
  */
-#define MAX_SUBSTREAMS      3
+#define MAX_SUBSTREAMS      4
 
 /** which multiple of 48000 the maximum sample rate is */
 #define MAX_RATEFACTOR      4
--- a/libavcodec/mlp_parser.c	2013-04-09 18:52:16.000000000 -0700
+++ b/libavcodec/mlp_parser.c.new	2015-05-04 06:57:30.611666232 -0700
@@ -117,6 +117,24 @@
     return layout;
 }
 
+static int ff_mlp_get_major_sync_size(const uint8_t * buf, int bufsize)
+{
+    int has_extension, extensions = 0;
+    int size = 28;
+    if (bufsize < 28)
+        return -1;
+
+    if (AV_RB32(buf) == 0xf8726fba) {
+        has_extension = buf[25] & 1;
+        if (has_extension) {
+            extensions = buf[26] >> 4;
+            size += 2 + extensions * 2;
+        }
+    }
+    return size;
+}
+
+
 /** Read a major sync info header - contains high level information about
  *  the stream - sample rate, channel arrangement etc. Most of this
  *  information is not actually necessary for decoding, only for playback.
@@ -125,18 +143,19 @@
 
 int ff_mlp_read_major_sync(void *log, MLPHeaderInfo *mh, GetBitContext *gb)
 {
-    int ratebits;
+    int ratebits, header_size;
     uint16_t checksum;
 
     assert(get_bits_count(gb) == 0);
 
-    if (gb->size_in_bits < 28 << 3) {
+    header_size = ff_mlp_get_major_sync_size(gb->buffer, gb->size_in_bits >> 3);
+    if (header_size < 0 || gb->size_in_bits < header_size << 3) {
         av_log(log, AV_LOG_ERROR, "packet too short, unable to read major sync\n");
         return -1;
     }
 
-    checksum = ff_mlp_checksum16(gb->buffer, 26);
-    if (checksum != AV_RL16(gb->buffer+26)) {
+    checksum = ff_mlp_checksum16(gb->buffer, header_size - 2);
+    if (checksum != AV_RL16(gb->buffer+header_size-2)) {
         av_log(log, AV_LOG_ERROR, "major sync info header checksum error\n");
         return AVERROR_INVALIDDATA;
     }
@@ -145,6 +164,7 @@
         return AVERROR_INVALIDDATA;
 
     mh->stream_type = get_bits(gb, 8);
+    mh->header_size = header_size;
 
     if (mh->stream_type == 0xbb) {
         mh->group1_bits = mlp_quants[get_bits(gb, 4)];
@@ -186,7 +206,7 @@
 
     mh->num_substreams = get_bits(gb, 4);
 
-    skip_bits_long(gb, 4 + 11 * 8);
+    skip_bits_long(gb, 4 + (header_size - 17) * 8);
 
     return 0;
 }
--- a/libavcodec/mlp_parser.h	2013-04-09 18:52:16.000000000 -0700
+++ b/libavcodec/mlp_parser.h.new	2015-05-04 06:58:23.631348774 -0700
@@ -32,6 +32,7 @@
 typedef struct MLPHeaderInfo
 {
     int stream_type;            ///< 0xBB for MLP, 0xBA for TrueHD
+    int header_size;            ///< Size of the major sync header, in bytes
 
     int group1_bits;            ///< The bit depth of the first substream
     int group2_bits;            ///< Bit depth of the second substream (MLP only)
--- a/libavcodec/mlpdec.c	2013-04-09 18:52:16.000000000 -0700
+++ b/libavcodec/mlpdec.c.new	2015-05-04 07:01:05.750378537 -0700
@@ -125,6 +125,10 @@
     /// Current access unit being read has a major sync.
     int         is_major_sync_unit;
 
+    /// Size of the major sync unit, in bytes
+    int         major_sync_header_size;
+
+
     /// Set if a valid major sync block has been read. Otherwise no decoding is possible.
     uint8_t     params_valid;
 
@@ -314,11 +318,15 @@
         return AVERROR_INVALIDDATA;
     }
 
+    m->major_sync_header_size = mh.header_size;
+
     m->access_unit_size      = mh.access_unit_size;
     m->access_unit_size_pow2 = mh.access_unit_size_pow2;
 
     m->num_substreams        = mh.num_substreams;
-    m->max_decoded_substream = m->num_substreams - 1;
+
+    /* limit to decoding 3 substreams, as the 4th is used by Dolby Atmos for non-audio data */
+    m->max_decoded_substream = FFMIN(m->num_substreams - 1, 2);
 
     m->avctx->sample_rate    = mh.group1_samplerate;
     m->avctx->frame_size     = mh.access_unit_size;
@@ -1035,7 +1043,7 @@
         if (read_major_sync(m, &gb) < 0)
             goto error;
         m->is_major_sync_unit = 1;
-        header_size += 28;
+        header_size += m->major_sync_header_size;
     }
 
     if (!m->params_valid) {
