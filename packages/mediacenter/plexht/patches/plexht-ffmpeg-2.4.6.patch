diff -ur a/xbmc/cores/amlplayer/AMLPlayer.cpp b/xbmc/cores/amlplayer/AMLPlayer.cpp
--- a/xbmc/cores/amlplayer/AMLPlayer.cpp	2015-03-12 20:52:41.074096999 +0100
+++ b/xbmc/cores/amlplayer/AMLPlayer.cpp	2015-03-12 20:48:25.150096999 +0100
@@ -387,16 +387,16 @@
 
             /* TODO: handle other subtitle codec types
             // subtitle codecs
-            CODEC_ID_DVD_SUBTITLE= 0x17000,
-            CODEC_ID_DVB_SUBTITLE,
-            CODEC_ID_TEXT,  ///< raw UTF-8 text
-            CODEC_ID_XSUB,
-            CODEC_ID_SSA,
-            CODEC_ID_MOV_TEXT,
-            CODEC_ID_HDMV_PGS_SUBTITLE,
-            CODEC_ID_DVB_TELETEXT,
-            CODEC_ID_SRT,
-            CODEC_ID_MICRODVD,
+            AV_CODEC_ID_DVD_SUBTITLE= 0x17000,
+            AV_CODEC_ID_DVB_SUBTITLE,
+            AV_CODEC_ID_TEXT,  ///< raw UTF-8 text
+            AV_CODEC_ID_XSUB,
+            AV_CODEC_ID_SSA,
+            AV_CODEC_ID_MOV_TEXT,
+            AV_CODEC_ID_HDMV_PGS_SUBTITLE,
+            AV_CODEC_ID_DVB_TELETEXT,
+            AV_CODEC_ID_SRT,
+            AV_CODEC_ID_MICRODVD,
             */
             switch(sub_type)
             {
@@ -405,12 +405,12 @@
                   "sub_type(0x%x), size(%d), bgntime(%lld), endtime(%lld), string(%s)",
                   sub_type, sub_size-20, subtitle->bgntime, subtitle->endtime, &sub_buffer[20]);
                 break;
-              case CODEC_ID_TEXT:
+              case AV_CODEC_ID_TEXT:
                 subtitle->bgntime = sub_pts/ 90;
                 subtitle->endtime = subtitle->bgntime + 4000;
                 subtitle->string  = &sub_buffer[20];
                 break;
-              case CODEC_ID_SSA:
+              case AV_CODEC_ID_SSA:
                 if (strncmp((const char*)&sub_buffer[20], "Dialogue:", 9) == 0)
                 {
                   int  vars_found, hour1, min1, sec1, hunsec1, hour2, min2, sec2, hunsec2, nothing;
@@ -584,7 +584,7 @@
     {
       CGUIDialogBusy *dialog = (CGUIDialogBusy*)g_windowManager.GetWindow(WINDOW_DIALOG_BUSY);
       dialog->Show();
-      while (!m_ready.WaitMSec(1))
+      while (!m_ready.WaitMSec(100))
         g_windowManager.ProcessRenderLoop(false);
       dialog->Close();
     }
diff -ur a/xbmc/cores/AudioEngine/AEFactory.cpp b/xbmc/cores/AudioEngine/AEFactory.cpp
--- a/xbmc/cores/AudioEngine/AEFactory.cpp	2015-03-12 20:52:41.058096999 +0100
+++ b/xbmc/cores/AudioEngine/AEFactory.cpp	2015-03-12 20:48:25.150096999 +0100
@@ -42,10 +42,6 @@
 
 bool CAEFactory::LoadEngine()
 {
-#if defined(TARGET_RASPBERRY_PI)
-  return true;
-#endif
-
   bool loaded = false;
 
   std::string engine;
@@ -124,10 +120,6 @@
 
 bool CAEFactory::StartEngine()
 {
-#if defined(TARGET_RASPBERRY_PI)
-  return true;
-#endif
-
   if (!AE)
     return false;
 
diff -ur a/xbmc/cores/AudioEngine/AESinkFactory.cpp b/xbmc/cores/AudioEngine/AESinkFactory.cpp
--- a/xbmc/cores/AudioEngine/AESinkFactory.cpp	2015-03-12 20:52:41.058096999 +0100
+++ b/xbmc/cores/AudioEngine/AESinkFactory.cpp	2015-03-12 20:48:25.150096999 +0100
@@ -25,6 +25,8 @@
   #include "Sinks/AESinkDirectSound.h"
 #elif defined(TARGET_ANDROID)
   #include "Sinks/AESinkAUDIOTRACK.h"
+#elif defined(TARGET_RASPBERRY_PI)
+  #include "Sinks/AESinkPi.h"
 #elif defined(TARGET_LINUX) || defined(TARGET_FREEBSD)
   #if defined(HAS_ALSA)
     #include "Sinks/AESinkALSA.h"
@@ -55,6 +57,8 @@
         driver == "DIRECTSOUND" ||
 #elif defined(TARGET_ANDROID)
         driver == "AUDIOTRACK"  ||
+#elif defined(TARGET_RASPBERRY_PI)
+        driver == "PI"          ||
 #elif defined(TARGET_LINUX) || defined(TARGET_FREEBSD)
   #if defined(HAS_ALSA)
         driver == "ALSA"        ||
@@ -110,6 +114,9 @@
 #elif defined(TARGET_ANDROID)
   if (driver.empty() || driver == "AUDIOTRACK")
     TRY_SINK(AUDIOTRACK)
+#elif defined(TARGET_RASPBERRY_PI)
+  if (driver.empty() || driver == "PI")
+    TRY_SINK(Pi)
 
 #elif defined(TARGET_LINUX) || defined(TARGET_FREEBSD)
   #if defined(HAS_ALSA)
@@ -145,6 +152,8 @@
     ENUMERATE_SINK(WASAPI, force);
 #elif defined(TARGET_ANDROID)
     ENUMERATE_SINK(AUDIOTRACK, force);
+#elif defined(TARGET_RASPBERRY_PI)
+    ENUMERATE_SINK(Pi, force);
 #elif defined(TARGET_LINUX) || defined(TARGET_FREEBSD)
   #if defined(HAS_ALSA)
     ENUMERATE_SINK(ALSA, force);
diff -ur a/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.cpp b/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.cpp
--- a/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.cpp	2015-03-12 20:52:41.058096999 +0100
+++ b/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.cpp	2015-03-12 20:48:25.150096999 +0100
@@ -109,7 +109,7 @@
   if (dts && (!ac3 || g_advancedSettings.m_audioTranscodeTo.Equals("dts")))
   {
     m_CodecName = "DTS";
-    m_CodecID   = CODEC_ID_DTS;
+    m_CodecID   = AV_CODEC_ID_DTS;
     m_PackFunc  = &CAEPackIEC61937::PackDTS_1024;
     m_BitRate   = DTS_ENCODE_BITRATE;
     codec = m_dllAvCodec.avcodec_find_encoder(m_CodecID);
@@ -120,7 +120,7 @@
   if (!codec && ac3)
   {
     m_CodecName = "AC3";
-    m_CodecID   = CODEC_ID_AC3;
+    m_CodecID   = AV_CODEC_ID_AC3;
     m_PackFunc  = &CAEPackIEC61937::PackAC3;
     m_BitRate   = AC3_ENCODE_BITRATE;
     codec = m_dllAvCodec.avcodec_find_encoder(m_CodecID);
@@ -226,7 +226,7 @@
   return m_BitRate;
 }
 
-CodecID CAEEncoderFFmpeg::GetCodecID()
+AVCodecID CAEEncoderFFmpeg::GetCodecID()
 {
   return m_CodecID;
 }
diff -ur a/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.h b/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.h
--- a/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.h	2015-03-12 20:52:41.058096999 +0100
+++ b/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.h	2015-03-12 20:48:25.150096999 +0100
@@ -39,7 +39,7 @@
   virtual void Reset();
 
   virtual unsigned int GetBitRate    ();
-  virtual CodecID      GetCodecID    ();
+  virtual AVCodecID    GetCodecID    ();
   virtual unsigned int GetFrames     ();
 
   virtual int Encode (float *data, unsigned int frames);
@@ -51,7 +51,7 @@
   DllAvUtil   m_dllAvUtil;
 
   std::string                m_CodecName;
-  CodecID                   m_CodecID;
+  AVCodecID                  m_CodecID;
   unsigned int              m_BitRate;
   CAEPackIEC61937::PackFunc m_PackFunc;
 
diff -ur a/xbmc/cores/AudioEngine/Interfaces/AEEncoder.h b/xbmc/cores/AudioEngine/Interfaces/AEEncoder.h
--- a/xbmc/cores/AudioEngine/Interfaces/AEEncoder.h	2015-03-12 20:52:41.062096999 +0100
+++ b/xbmc/cores/AudioEngine/Interfaces/AEEncoder.h	2015-03-12 20:48:25.150096999 +0100
@@ -64,10 +64,10 @@
   virtual unsigned int GetBitRate() = 0;
 
   /**
-   * Returns the CodecID of the encoder
+   * Returns the AVCodecID of the encoder
    * @return the ffmpeg codec id
    */
-  virtual CodecID GetCodecID() = 0;
+  virtual AVCodecID GetCodecID() = 0;
 
   /**
    * Return the number of frames needed to encode
diff -ur a/xbmc/cores/AudioEngine/Makefile.in b/xbmc/cores/AudioEngine/Makefile.in
--- a/xbmc/cores/AudioEngine/Makefile.in	2015-03-12 20:52:41.062096999 +0100
+++ b/xbmc/cores/AudioEngine/Makefile.in	2015-03-12 20:48:25.150096999 +0100
@@ -39,6 +39,8 @@
 SRCS += Sinks/AESinkNULL.cpp
 SRCS += Sinks/AESinkProfiler.cpp
 
+SRCS += Sinks/AESinkPi.cpp
+
 SRCS += Engines/SoftAE/SoftAE.cpp
 SRCS += Engines/SoftAE/SoftAEStream.cpp
 SRCS += Engines/SoftAE/SoftAESound.cpp
diff -ur a/xbmc/cores/AudioEngine/Sinks/CMakeLists.txt b/xbmc/cores/AudioEngine/Sinks/CMakeLists.txt
--- a/xbmc/cores/AudioEngine/Sinks/CMakeLists.txt	2015-03-12 20:52:41.062096999 +0100
+++ b/xbmc/cores/AudioEngine/Sinks/CMakeLists.txt	2015-03-12 20:48:25.150096999 +0100
@@ -4,12 +4,16 @@
   set(ae_SRCS ${ae_SRCS} AESinkALSA.cpp AESinkALSA.h)
 endif()
 
+if(TARGET_RPI)
+  set(ae_SRCS ${ae_SRCS} AESinkPi.cpp AESinkPi.h)
+endif(TARGET_RPI)
+
 if(TARGET_WIN32)
   set(ae_SRCS ${ae_SRCS} AESinkWASAPI.cpp AESinkWASAPI.h AESinkDirectSound.cpp AESinkDirectSound.h)
 endif(TARGET_WIN32)
 
-if(TARGET_COMMON_LINUX OR TARGET_FREEBSD)
+if(TARGET_COMMON_LINUX)
   set(ae_SRCS ${ae_SRCS} AESinkOSS.cpp AESinkOSS.h)
-endif(TARGET_COMMON_LINUX OR TARGET_FREEBSD)
+endif(TARGET_COMMON_LINUX)
 
 add_sources(${ae_SRCS})
diff -ur a/xbmc/cores/DllLoader/CMakeLists.txt b/xbmc/cores/DllLoader/CMakeLists.txt
--- a/xbmc/cores/DllLoader/CMakeLists.txt	2015-03-12 20:52:41.066096999 +0100
+++ b/xbmc/cores/DllLoader/CMakeLists.txt	2015-03-12 20:48:09.942096999 +0100
@@ -4,15 +4,10 @@
 list(REMOVE_ITEM dllloader_SRCS ./DllLoader-linux.cpp)
 if(UNIX)
   list(REMOVE_ITEM dllloader_SRCS ./Win32DllLoader.cpp)
-  list(REMOVE_ITEM dllloader_SRCS ./Win32DllLoader.h)
 else()
   list(REMOVE_ITEM dllloader_SRCS ./DllLoader-linux.cpp)
   list(REMOVE_ITEM dllloader_SRCS ./ldt_keeper.c)
   list(REMOVE_ITEM dllloader_SRCS ./mmap_anon.c)
   list(REMOVE_ITEM dllloader_SRCS ./SoLoader.cpp)
 endif()
-if(TARGET_FREEBSD)
-  list(REMOVE_ITEM dllloader_SRCS ./ldt_keeper.c)
-  list(REMOVE_ITEM dllloader_SRCS ./ldt_keeper.h)
-endif()
 add_sources(${dllloader_SRCS})
diff -ur a/xbmc/cores/dvdplayer/DVDAudio.cpp b/xbmc/cores/dvdplayer/DVDAudio.cpp
--- a/xbmc/cores/dvdplayer/DVDAudio.cpp	2015-03-12 20:52:41.074096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDAudio.cpp	2015-03-12 20:48:25.150096999 +0100
@@ -120,7 +120,7 @@
   free(m_pBuffer);
 }
 
-bool CDVDAudio::Create(const DVDAudioFrame &audioframe, CodecID codec, bool needresampler)
+bool CDVDAudio::Create(const DVDAudioFrame &audioframe, AVCodecID codec, bool needresampler)
 {
   CLog::Log(LOGNOTICE,
     "Creating audio stream (codec id: %i, channels: %i, sample rate: %i, %s)",
@@ -183,7 +183,7 @@
   m_time.Flush();
 }
 
-DWORD CDVDAudio::AddPacketsRenderer(unsigned char* data, DWORD len, CSingleLock &lock)
+unsigned int CDVDAudio::AddPacketsRenderer(unsigned char* data, unsigned int len, CSingleLock &lock)
 {
   if(!m_pAudioStream)
     return 0;
@@ -198,8 +198,8 @@
   timeout += DVD_SEC_TO_TIME(1.0);
   timeout += CDVDClock::GetAbsoluteClock();
 
-  DWORD  total = len;
-  DWORD  copied;
+  unsigned int  total = len;
+  unsigned int  copied;
   do
   {
     copied = m_pAudioStream->AddData(data, len);
@@ -226,22 +226,22 @@
   return total - len;
 }
 
-DWORD CDVDAudio::AddPackets(const DVDAudioFrame &audioframe)
+unsigned int CDVDAudio::AddPackets(const DVDAudioFrame &audioframe)
 {
   CSingleLock lock (m_critSection);
 
   unsigned char* data = audioframe.data;
-  DWORD len = audioframe.size;
+  unsigned int len = audioframe.size;
 
-  DWORD total = len;
-  DWORD copied;
+  unsigned int total = len;
+  unsigned int copied;
 
   if (m_iBufferSize > 0) // See if there are carryover bytes from the last call. need to add them 1st.
   {
     copied = std::min(m_dwPacketSize - m_iBufferSize % m_dwPacketSize, len); // Smaller of either the data provided or the leftover data
     if(copied)
     {
-      m_pBuffer = (BYTE*)realloc(m_pBuffer, m_iBufferSize + copied);
+      m_pBuffer = (uint8_t*)realloc(m_pBuffer, m_iBufferSize + copied);
       memcpy(m_pBuffer + m_iBufferSize, data, copied); // Tack the caller's data onto the end of the buffer
       data += copied; // Move forward in caller's data
       len -= copied; // Decrease amount of data available from caller
@@ -270,7 +270,7 @@
   // if we have more data left, save it for the next call to this funtion
   if (len > 0 && !m_bStop)
   {
-    m_pBuffer     = (BYTE*)realloc(m_pBuffer, len);
+    m_pBuffer     = (uint8_t*)realloc(m_pBuffer, len);
     m_iBufferSize = len;
     memcpy(m_pBuffer, data, len);
   }
@@ -287,12 +287,12 @@
   if (!m_pAudioStream)
     return;
 
-  DWORD silence = m_dwPacketSize - m_iBufferSize % m_dwPacketSize;
+  unsigned int silence = m_dwPacketSize - m_iBufferSize % m_dwPacketSize;
 
   if(silence > 0 && m_iBufferSize > 0)
   {
     CLog::Log(LOGDEBUG, "CDVDAudio::Drain - adding %d bytes of silence, buffer size: %d, chunk size: %d", silence, m_iBufferSize, m_dwPacketSize);
-    m_pBuffer = (BYTE*)realloc(m_pBuffer, m_iBufferSize + silence);
+    m_pBuffer = (uint8_t*)realloc(m_pBuffer, m_iBufferSize + silence);
     memset(m_pBuffer+m_iBufferSize, 0, silence);
     m_iBufferSize += silence;
   }
diff -ur a/xbmc/cores/dvdplayer/DVDAudio.h b/xbmc/cores/dvdplayer/DVDAudio.h
--- a/xbmc/cores/dvdplayer/DVDAudio.h	2015-03-12 20:52:41.074096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDAudio.h	2015-03-12 20:48:25.154096999 +0100
@@ -30,9 +30,6 @@
 #include "cores/AudioEngine/Utils/AEChannelInfo.h"
 class IAEStream;
 
-#ifndef _LINUX
-enum CodecID;
-#else
 extern "C" {
 #if (defined USE_EXTERNAL_FFMPEG)
   #if (defined HAVE_LIBAVCODEC_AVCODEC_H)
@@ -44,9 +41,8 @@
   #include "libavcodec/avcodec.h"
 #endif
 }
-#endif
-typedef struct stDVDAudioFrame DVDAudioFrame;
 
+typedef struct stDVDAudioFrame DVDAudioFrame;
 
 class CPTSOutputQueue
 {
@@ -80,10 +76,10 @@
   float GetCurrentAttenuation();
   void Pause();
   void Resume();
-  bool Create(const DVDAudioFrame &audioframe, CodecID codec, bool needresampler);
+  bool Create(const DVDAudioFrame &audioframe, AVCodecID codec, bool needresampler);
   bool IsValidFormat(const DVDAudioFrame &audioframe);
   void Destroy();
-  DWORD AddPackets(const DVDAudioFrame &audioframe);
+  unsigned int AddPackets(const DVDAudioFrame &audioframe);
   double GetDelay(); // returns the time it takes to play a packet if we add one at this time
   double GetPlayingPts() { return m_time.Current(); }
   void   SetPlayingPts(double pts);
@@ -99,10 +95,10 @@
   IAEStream *m_pAudioStream;
 protected:
   CPTSOutputQueue m_time;
-  DWORD AddPacketsRenderer(unsigned char* data, DWORD len, CSingleLock &lock);
-  BYTE* m_pBuffer; // should be [m_dwPacketSize]
-  DWORD m_iBufferSize;
-  DWORD m_dwPacketSize;
+  unsigned int AddPacketsRenderer(unsigned char* data, unsigned int len, CSingleLock &lock);
+  uint8_t*     m_pBuffer; // should be [m_dwPacketSize]
+  unsigned int m_iBufferSize;
+  unsigned int m_dwPacketSize;
   CCriticalSection m_critSection;
 
   int m_iBitrate;
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp
--- a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp	2015-03-12 20:52:41.074096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp	2015-03-12 20:48:25.154096999 +0100
@@ -30,8 +30,8 @@
 {
   m_iBufferSize1 = 0;
   m_iBufferSize2 = 0;
-  m_pBuffer2     = (BYTE*)_aligned_malloc(AVCODEC_MAX_AUDIO_FRAME_SIZE + FF_INPUT_BUFFER_PADDING_SIZE, 16);
-  memset(m_pBuffer2, 0, AVCODEC_MAX_AUDIO_FRAME_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);
+  m_iBufferTotalSize2 = 0;
+  m_pBuffer2     = NULL;
 
   m_iBuffered = 0;
   m_pCodecContext = NULL;
@@ -50,7 +50,6 @@
 
 CDVDAudioCodecFFmpeg::~CDVDAudioCodecFFmpeg()
 {
-  _aligned_free(m_pBuffer2);
   Dispose();
 }
 
@@ -123,6 +122,9 @@
   if (m_pConvert)
     m_dllSwResample.swr_free(&m_pConvert);
 
+  if (m_pBuffer2)
+    m_dllAvUtil.av_freep(&m_pBuffer2);
+
   if (m_pCodecContext)
   {
     if (m_bOpenedCodec) m_dllAvCodec.avcodec_close(m_pCodecContext);
@@ -137,15 +139,15 @@
 
   m_iBufferSize1 = 0;
   m_iBufferSize2 = 0;
+  m_iBufferTotalSize2 = 0;
   m_iBuffered = 0;
 }
 
-int CDVDAudioCodecFFmpeg::Decode(BYTE* pData, int iSize)
+int CDVDAudioCodecFFmpeg::Decode(uint8_t* pData, int iSize)
 {
   int iBytesUsed, got_frame;
   if (!m_pCodecContext) return -1;
 
-  m_iBufferSize1 = AVCODEC_MAX_AUDIO_FRAME_SIZE ;
   m_iBufferSize2 = 0;
 
   AVPacket avpkt;
@@ -195,18 +197,35 @@
                       m_dllAvUtil.av_get_default_channel_layout(m_pCodecContext->channels), AV_SAMPLE_FMT_FLT, m_pCodecContext->sample_rate,
                       m_dllAvUtil.av_get_default_channel_layout(m_pCodecContext->channels), m_pCodecContext->sample_fmt, m_pCodecContext->sample_rate,
                       0, NULL);
+
+      if(!m_pConvert || m_dllSwResample.swr_init(m_pConvert) < 0)
+      {
+          CLog::Log(LOGERROR, "CDVDAudioCodecFFmpeg::Decode - Unable to convert %d to AV_SAMPLE_FMT_FLT", m_pCodecContext->sample_fmt);
+          m_iBufferSize1 = 0;
+          m_iBufferSize2 = 0;
+          return;
+      }
     }
 
-    if(!m_pConvert || m_dllSwResample.swr_init(m_pConvert) < 0)
+    int needed_buf_size = m_dllAvUtil.av_samples_get_buffer_size(NULL, m_pCodecContext->channels, m_pFrame1->nb_samples, AV_SAMPLE_FMT_FLT, 0);
+    if(m_iBufferTotalSize2 < needed_buf_size)
     {
-      CLog::Log(LOGERROR, "CDVDAudioCodecFFmpeg::Decode - Unable to convert %d to AV_SAMPLE_FMT_FLT", m_pCodecContext->sample_fmt);
-      m_iBufferSize1 = 0;
-      m_iBufferSize2 = 0;
-      return;
+        m_pBuffer2 = (uint8_t*)m_dllAvUtil.av_realloc(m_pBuffer2, needed_buf_size);
+        if(!m_pBuffer2)
+        {
+            CLog::Log(LOGERROR, "CDVDAudioCodecFFmpeg::Decode - Unable to allocate a %i bytes buffer for resampling", needed_buf_size);
+            m_iBufferSize1 = 0;
+            m_iBufferSize2 = 0;
+            m_iBufferTotalSize2 = 0;
+            return;
+        }
+        m_iBufferTotalSize2 = needed_buf_size;
     }
 
-    int len = m_iBufferSize1 / m_dllAvUtil.av_get_bytes_per_sample(m_pCodecContext->sample_fmt);
-    if(m_dllSwResample.swr_convert(m_pConvert, &m_pBuffer2, len, (const uint8_t**)m_pFrame1->data, m_pFrame1->nb_samples) < 0)
+    int outsamples;
+    outsamples = m_dllSwResample.swr_convert(m_pConvert, &m_pBuffer2, m_iBufferTotalSize2, (const uint8_t**)m_pFrame1->extended_data, m_pFrame1->nb_samples);
+
+    if(outsamples < 0)
     {
       CLog::Log(LOGERROR, "CDVDAudioCodecFFmpeg::Decode - Unable to convert %d to AV_SAMPLE_FMT_FLT", (int)m_pCodecContext->sample_fmt);
       m_iBufferSize1 = 0;
@@ -214,12 +233,17 @@
       return;
     }
 
+    if(outsamples < m_pFrame1->nb_samples)
+    {
+      CLog::Log(LOGWARNING, "CDVDAudioCodecFFmpeg::Decode - Resampler produced less samples than what it was given");
+    }
+
     m_iBufferSize1 = 0;
-    m_iBufferSize2 = len * m_dllAvUtil.av_get_bytes_per_sample(AV_SAMPLE_FMT_FLT);
+    m_iBufferSize2 = m_dllAvUtil.av_samples_get_buffer_size(NULL, m_pCodecContext->channels, m_pFrame1->nb_samples, AV_SAMPLE_FMT_FLT, 0);
   }
 }
 
-int CDVDAudioCodecFFmpeg::GetData(BYTE** dst)
+int CDVDAudioCodecFFmpeg::GetData(uint8_t** dst)
 {
   if(m_iBufferSize1)
   {
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.h b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.h
--- a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.h	2015-03-12 20:52:41.074096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.h	2015-03-12 20:48:25.154096999 +0100
@@ -33,8 +33,8 @@
   virtual ~CDVDAudioCodecFFmpeg();
   virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
   virtual void Dispose();
-  virtual int Decode(BYTE* pData, int iSize);
-  virtual int GetData(BYTE** dst);
+  virtual int Decode(uint8_t* pData, int iSize);
+  virtual int GetData(uint8_t** dst);
   virtual void Reset();
   virtual int GetChannels();
   virtual CAEChannelInfo GetChannelMap();
@@ -55,8 +55,9 @@
 
   AVFrame* m_pFrame1;
   int      m_iBufferSize1;
-  BYTE*    m_pBuffer2;
+  uint8_t*    m_pBuffer2;
   int      m_iBufferSize2;
+  int      m_iBufferTotalSize2;
 
   bool m_bOpenedCodec;
   int m_iBuffered;
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodec.h b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodec.h
--- a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodec.h	2015-03-12 20:52:41.074096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodec.h	2015-03-12 20:48:25.154096999 +0100
@@ -56,13 +56,13 @@
    * returns bytes used or -1 on error
    *
    */
-  virtual int Decode(BYTE* pData, int iSize) = 0;
+  virtual int Decode(uint8_t* pData, int iSize) = 0;
 
   /*
    * returns nr of bytes used or -1 on error
    * the data is valid until the next Decode call
    */
-  virtual int GetData(BYTE** dst) = 0;
+  virtual int GetData(uint8_t** dst) = 0;
 
   /*
    * resets the decoder
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLibMad.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLibMad.cpp
--- a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLibMad.cpp	2015-03-12 20:52:41.074096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLibMad.cpp	2015-03-12 20:48:25.154096999 +0100
@@ -82,9 +82,9 @@
   }
 }
 
-int CDVDAudioCodecLibMad::Decode(BYTE* pData, int iSize)
+int CDVDAudioCodecLibMad::Decode(uint8_t* pData, int iSize)
 {
-  BYTE* pBuffer = m_inputBuffer;
+  uint8_t* pBuffer = m_inputBuffer;
   //int iBufferSize = iSize;
   bool bFullOutputBuffer = false;
 
@@ -127,7 +127,7 @@
         if (m_stream.next_frame)
         {
           m_iInputBufferSize = m_stream.bufend - m_stream.next_frame;
-          pBuffer = (BYTE*)m_stream.next_frame;
+          pBuffer = (uint8_t*)m_stream.next_frame;
         }
 
         if (m_iInputBufferSize <= 0)
@@ -185,7 +185,7 @@
   return 0;
 }
 
-int CDVDAudioCodecLibMad::GetData(BYTE** dst)
+int CDVDAudioCodecLibMad::GetData(uint8_t** dst)
 {
   *dst = m_decodedData;
   return m_iDecodedDataSize;
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLibMad.h b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLibMad.h
--- a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLibMad.h	2015-03-12 20:52:41.074096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLibMad.h	2015-03-12 20:48:25.154096999 +0100
@@ -33,8 +33,8 @@
   virtual ~CDVDAudioCodecLibMad();
   virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
   virtual void Dispose();
-  virtual int Decode(BYTE* pData, int iSize);
-  virtual int GetData(BYTE** dst);
+  virtual int Decode(uint8_t* pData, int iSize);
+  virtual int GetData(uint8_t** dst);
   virtual void Reset();
   virtual CAEChannelInfo GetChannelMap();
   virtual int GetChannels()                 { return m_iSourceChannels;   }
@@ -55,11 +55,11 @@
   struct mad_stream m_stream;
   struct mad_frame m_frame;
 
-  BYTE m_decodedData[MAD_DECODED_SIZE];
-  int  m_iDecodedDataSize;
+  uint8_t m_decodedData[MAD_DECODED_SIZE];
+  int     m_iDecodedDataSize;
 
-  BYTE m_inputBuffer[MAD_INPUT_SIZE];
-  int m_iInputBufferSize;
+  uint8_t m_inputBuffer[MAD_INPUT_SIZE];
+  int     m_iInputBufferSize;
 
   DllLibMad m_dll;
 };
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLPcm.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLPcm.cpp
--- a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLPcm.cpp	2015-03-12 20:52:41.074096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLPcm.cpp	2015-03-12 20:48:25.154096999 +0100
@@ -23,9 +23,14 @@
 
 CDVDAudioCodecLPcm::CDVDAudioCodecLPcm() : CDVDAudioCodecPcm()
 {
-  m_codecID = CODEC_ID_NONE;
-  m_bufferSize = LPCM_BUFFER_SIZE;
-  memset(m_buffer, 0, sizeof(m_buffer));
+  m_codecID = AV_CODEC_ID_NONE;
+  m_bufferSize = 0;
+  m_buffer = NULL;
+}
+
+CDVDAudioCodecLPcm::~CDVDAudioCodecLPcm()
+{
+  delete m_buffer;
 }
 
 bool CDVDAudioCodecLPcm::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
@@ -33,28 +38,35 @@
   m_codecID = hints.codec;
 
   CDVDStreamInfo hints2(hints, true);
-  hints2.codec = CODEC_ID_NONE;
+  hints2.codec = AV_CODEC_ID_NONE;
 #if 0
-  if (hints.codecID = CODEC_ID_LPCM_S24BE) hints2.codec = CODEC_ID_PCM_S24BE;
+  if (hints.codecID = AV_CODEC_ID_LPCM_S24BE) hints2.codec = AV_CODEC_ID_PCM_S24BE;
 #endif
-  if (hints2.codec != CODEC_ID_NONE)
+  if (hints2.codec != AV_CODEC_ID_NONE)
     return CDVDAudioCodecPcm::Open(hints2, options);
 
   return false;
 }
 
-int CDVDAudioCodecLPcm::Decode(BYTE* pData, int iSize)
+int CDVDAudioCodecLPcm::Decode(uint8_t* pData, int iSize)
 {
-  BYTE* d = m_buffer;
-  BYTE* s = pData;
+  uint8_t* d = m_buffer;
+  uint8_t* s = pData;
   int iDecoded = 0;
 
-  if (iSize > m_bufferSize) iSize = m_bufferSize;
+  if (iSize > m_bufferSize)
+  {
+    delete m_buffer;
+    d = m_buffer = new uint8_t[iSize];
+    if(!m_buffer)
+      return -1;
+    m_bufferSize = iSize;
+  }
 
   if (iSize >= 12)
   {
 #if 0
-    if (m_codecID == CODEC_ID_LPCM_S24BE)
+    if (m_codecID == AV_CODEC_ID_LPCM_S24BE)
 #endif
     {
       for (iDecoded = 0; iDecoded <= (iSize - 12); iDecoded += 12)
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLPcm.h b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLPcm.h
--- a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLPcm.h	2015-03-12 20:52:41.074096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLPcm.h	2015-03-12 20:48:25.154096999 +0100
@@ -24,21 +24,19 @@
 #include "DVDCodecs/DVDCodecs.h"
 #include "DVDAudioCodecPcm.h"
 
-#define LPCM_BUFFER_SIZE (AVCODEC_MAX_AUDIO_FRAME_SIZE / 2)
-
 class CDVDAudioCodecLPcm : public CDVDAudioCodecPcm
 {
 public:
   CDVDAudioCodecLPcm();
-  virtual ~CDVDAudioCodecLPcm() {}
+  virtual ~CDVDAudioCodecLPcm();
   virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
-  virtual int Decode(BYTE* pData, int iSize);
+  virtual int Decode(uint8_t* pData, int iSize);
   virtual const char* GetName()  { return "lpcm"; }
 
 protected:
 
   int m_bufferSize;
-  BYTE m_buffer[LPCM_BUFFER_SIZE];
+  uint8_t *m_buffer;
 
-  CodecID m_codecID;
+  AVCodecID m_codecID;
 };
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.cpp
--- a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.cpp	2015-03-12 20:52:41.074096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.cpp	2015-03-12 20:48:25.154096999 +0100
@@ -67,12 +67,12 @@
   m_bufferSize = 0;
 
   if (
-      (hints.codec == CODEC_ID_AC3 && bSupportsAC3Out) ||
-      (hints.codec == CODEC_ID_DTS && bSupportsDTSOut) ||
+      (hints.codec == AV_CODEC_ID_AC3 && bSupportsAC3Out) ||
+      (hints.codec == AV_CODEC_ID_DTS && bSupportsDTSOut) ||
       (audioMode == AUDIO_HDMI &&
         (
-          (hints.codec == CODEC_ID_EAC3   && bSupportsAC3Out   ) ||
-          (hints.codec == CODEC_ID_TRUEHD && bSupportsTrueHDOut)
+          (hints.codec == AV_CODEC_ID_EAC3   && bSupportsAC3Out   ) ||
+          (hints.codec == AV_CODEC_ID_TRUEHD && bSupportsTrueHDOut)
         )
       )
   )
@@ -144,7 +144,7 @@
   m_bufferSize = 0;
 }
 
-int CDVDAudioCodecPassthrough::Decode(BYTE* pData, int iSize)
+int CDVDAudioCodecPassthrough::Decode(uint8_t* pData, int iSize)
 {
   if (iSize <= 0) return 0;
 
@@ -159,7 +159,7 @@
   return used;
 }
 
-int CDVDAudioCodecPassthrough::GetData(BYTE** dst)
+int CDVDAudioCodecPassthrough::GetData(uint8_t** dst)
 {
   int size = m_packer.GetSize();
   *dst     = m_packer.GetBuffer();
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.h b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.h
--- a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.h	2015-03-12 20:52:41.074096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.h	2015-03-12 20:48:25.154096999 +0100
@@ -36,8 +36,8 @@
 
   virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
   virtual void Dispose();
-  virtual int  Decode(BYTE* pData, int iSize);
-  virtual int  GetData(BYTE** dst);
+  virtual int  Decode(uint8_t* pData, int iSize);
+  virtual int  GetData(uint8_t** dst);
   virtual void Reset();
   virtual int  GetChannels               ();
   virtual int  GetEncodedChannels        ();
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPcm.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPcm.cpp
--- a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPcm.cpp	2015-03-12 20:52:41.074096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPcm.cpp	2015-03-12 20:48:25.154096999 +0100
@@ -76,7 +76,7 @@
  * \param samples output samples
  * \param src_len number of bytes in src
  */
-static inline void decode_to16(int bps, int le, int us, BYTE **src, short **samples, int src_len)
+static inline void decode_to16(int bps, int le, int us, uint8_t **src, short **samples, int src_len)
 {
     register int n = src_len / bps;
     if (le) *src += bps - 2;
@@ -87,7 +87,7 @@
     if (le) *src -= bps - 2;
 }
 
-const BYTE ff_reverse[256] =
+const uint8_t ff_reverse[256] =
     {
       0x00,0x80,0x40,0xC0,0x20,0xA0,0x60,0xE0,0x10,0x90,0x50,0xD0,0x30,0xB0,0x70,0xF0,
       0x08,0x88,0x48,0xC8,0x28,0xA8,0x68,0xE8,0x18,0x98,0x58,0xD8,0x38,0xB8,0x78,0xF8,
@@ -113,16 +113,18 @@
   m_iSourceSampleRate = 0;
   m_iSourceBitrate = 0;
   m_decodedDataSize = 0;
-  m_codecID = CODEC_ID_NONE;
+  m_codecID = AV_CODEC_ID_NONE;
   m_iOutputChannels = 0;
 
-  memset(m_decodedData, 0, sizeof(m_decodedData));
+  m_decodedData = NULL;
+  m_decodedDataBufSize = 0;
   memset(table, 0, sizeof(table));
 }
 
 CDVDAudioCodecPcm::~CDVDAudioCodecPcm()
 {
   Dispose();
+  delete m_decodedData;
 }
 
 bool CDVDAudioCodecPcm::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
@@ -136,12 +138,12 @@
 
   switch (m_codecID)
   {
-    case CODEC_ID_PCM_ALAW:
+    case AV_CODEC_ID_PCM_ALAW:
     {
       for (int i = 0; i < 256; i++) table[i] = alaw2linear(i);
       break;
     }
-    case CODEC_ID_PCM_MULAW:
+    case AV_CODEC_ID_PCM_MULAW:
     {
       for (int i = 0; i < 256; i++) table[i] = ulaw2linear(i);
       break;
@@ -162,46 +164,52 @@
 {
 }
 
-int CDVDAudioCodecPcm::Decode(BYTE* pData, int iSize)
+int CDVDAudioCodecPcm::Decode(uint8_t* pData, int iSize)
 {
     int n;
     short *samples;
-    BYTE *src;
+    uint8_t *src;
 
     samples = (short*)m_decodedData;
     src = pData;
     int buf_size = iSize;
 
-    if (iSize > AVCODEC_MAX_AUDIO_FRAME_SIZE / 2)
-        iSize = AVCODEC_MAX_AUDIO_FRAME_SIZE / 2;
+    if (iSize > m_decodedDataBufSize)
+    {
+        delete m_decodedData;
+        samples = m_decodedData = new short[iSize];
+        if(!m_decodedData)
+            return -1;
+        m_decodedDataBufSize = iSize;
+    }
 
     switch (m_codecID)
     {
-    case CODEC_ID_PCM_S32LE:
+    case AV_CODEC_ID_PCM_S32LE:
         decode_to16(4, 1, 0, &src, &samples, buf_size);
         break;
-    case CODEC_ID_PCM_S32BE:
+    case AV_CODEC_ID_PCM_S32BE:
         decode_to16(4, 0, 0, &src, &samples, buf_size);
         break;
-    case CODEC_ID_PCM_U32LE:
+    case AV_CODEC_ID_PCM_U32LE:
         decode_to16(4, 1, 1, &src, &samples, buf_size);
         break;
-    case CODEC_ID_PCM_U32BE:
+    case AV_CODEC_ID_PCM_U32BE:
         decode_to16(4, 0, 1, &src, &samples, buf_size);
         break;
-    case CODEC_ID_PCM_S24LE:
+    case AV_CODEC_ID_PCM_S24LE:
         decode_to16(3, 1, 0, &src, &samples, buf_size);
         break;
-    case CODEC_ID_PCM_S24BE:
+    case AV_CODEC_ID_PCM_S24BE:
         decode_to16(3, 0, 0, &src, &samples, buf_size);
         break;
-    case CODEC_ID_PCM_U24LE:
+    case AV_CODEC_ID_PCM_U24LE:
         decode_to16(3, 1, 1, &src, &samples, buf_size);
         break;
-    case CODEC_ID_PCM_U24BE:
+    case AV_CODEC_ID_PCM_U24BE:
         decode_to16(3, 0, 1, &src, &samples, buf_size);
         break;
-    case CODEC_ID_PCM_S24DAUD:
+    case AV_CODEC_ID_PCM_S24DAUD:
         n = buf_size / 3;
         for(;n>0;n--) {
           uint32_t v = src[0] << 16 | src[1] << 8 | src[2];
@@ -211,50 +219,50 @@
           src += 3;
         }
         break;
-    case CODEC_ID_PCM_S16LE:
+    case AV_CODEC_ID_PCM_S16LE:
         n = buf_size >> 1;
         for(;n>0;n--) {
             *samples++ = src[0] | (src[1] << 8);
             src += 2;
         }
         break;
-    case CODEC_ID_PCM_S16BE:
+    case AV_CODEC_ID_PCM_S16BE:
         n = buf_size >> 1;
         for(;n>0;n--) {
             *samples++ = (src[0] << 8) | src[1];
             src += 2;
         }
         break;
-    case CODEC_ID_PCM_U16LE:
+    case AV_CODEC_ID_PCM_U16LE:
         n = buf_size >> 1;
         for(;n>0;n--) {
             *samples++ = (src[0] | (src[1] << 8)) - 0x8000;
             src += 2;
         }
         break;
-    case CODEC_ID_PCM_U16BE:
+    case AV_CODEC_ID_PCM_U16BE:
         n = buf_size >> 1;
         for(;n>0;n--) {
             *samples++ = ((src[0] << 8) | src[1]) - 0x8000;
             src += 2;
         }
         break;
-    case CODEC_ID_PCM_S8:
+    case AV_CODEC_ID_PCM_S8:
         n = buf_size;
         for(;n>0;n--) {
             *samples++ = src[0] << 8;
             src++;
         }
         break;
-    case CODEC_ID_PCM_U8:
+    case AV_CODEC_ID_PCM_U8:
         n = buf_size;
         for(;n>0;n--) {
             *samples++ = ((int)src[0] - 128) << 8;
             src++;
         }
         break;
-    case CODEC_ID_PCM_ALAW:
-    case CODEC_ID_PCM_MULAW:
+    case AV_CODEC_ID_PCM_ALAW:
+    case AV_CODEC_ID_PCM_MULAW:
         n = buf_size;
         for(;n>0;n--) {
             *samples++ = table[src[0]];
@@ -265,13 +273,13 @@
         return -1;
     }
 
-    m_decodedDataSize = (BYTE*)samples - (BYTE*)m_decodedData;
+    m_decodedDataSize = (uint8_t*)samples - (uint8_t*)m_decodedData;
     return iSize;
 }
 
-int CDVDAudioCodecPcm::GetData(BYTE** dst)
+int CDVDAudioCodecPcm::GetData(uint8_t** dst)
 {
-  *dst = (BYTE*)m_decodedData;
+  *dst = (uint8_t*)m_decodedData;
   return m_decodedDataSize;
 }
 
@@ -281,7 +289,7 @@
   m_iSourceSampleRate = 0;
   m_iSourceBitrate = 0;
   m_decodedDataSize = 0;
-  m_codecID = CODEC_ID_NONE;
+  m_codecID = AV_CODEC_ID_NONE;
 }
 
 void CDVDAudioCodecPcm::Reset()
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPcm.h b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPcm.h
--- a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPcm.h	2015-03-12 20:52:41.074096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPcm.h	2015-03-12 20:48:25.154096999 +0100
@@ -29,8 +29,8 @@
   virtual ~CDVDAudioCodecPcm();
   virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
   virtual void Dispose();
-  virtual int Decode(BYTE* pData, int iSize);
-  virtual int GetData(BYTE** dst);
+  virtual int Decode(uint8_t* pData, int iSize);
+  virtual int GetData(uint8_t** dst);
   virtual void Reset();
   virtual int GetChannels();
   virtual CAEChannelInfo GetChannelMap();
@@ -41,10 +41,11 @@
 protected:
   virtual void SetDefault();
 
-  short m_decodedData[131072]; // could be a bit to big
+  short* m_decodedData;
+  int m_decodedDataBufSize;
   int m_decodedDataSize;
 
-  CodecID m_codecID;
+  AVCodecID m_codecID;
   int m_iSourceSampleRate;
   int m_iSourceChannels;
   int m_iSourceBitrate;
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Audio/Makefile.in b/xbmc/cores/dvdplayer/DVDCodecs/Audio/Makefile.in
--- a/xbmc/cores/dvdplayer/DVDCodecs/Audio/Makefile.in	2015-03-12 20:52:41.074096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Audio/Makefile.in	2015-03-12 20:48:25.154096999 +0100
@@ -8,10 +8,6 @@
 SRCS += DVDAudioCodecPassthrough.cpp
 SRCS += DVDAudioCodecPcm.cpp
 
-ifeq ($(findstring osx,@ARCH@),osx)
-SRCS += DVDAudioCodecPassthroughFFmpeg.cpp
-endif
-
 LIB=Audio.a
 
 include @abs_top_srcdir@/Makefile.include
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecs.h b/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecs.h
--- a/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecs.h	2015-03-12 20:52:41.074096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecs.h	2015-03-12 20:48:25.154096999 +0100
@@ -23,7 +23,6 @@
 #if (defined HAVE_CONFIG_H) && (!defined WIN32)
   #include "config.h"
 #endif
-// enum CodecID
 
 #include <string>
 #include <vector>
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecUtils.cpp b/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecUtils.cpp
--- a/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecUtils.cpp	2015-03-12 20:52:41.074096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecUtils.cpp	2015-03-12 20:48:25.154096999 +0100
@@ -38,7 +38,7 @@
     int h = iHeight / 2;
     int size = w * h;
     int totalsize = (iWidth * iHeight) + size * 2;
-    BYTE* data = new BYTE[totalsize];
+    uint8_t* data = new uint8_t[totalsize];
     if (data)
     {
       pPicture->data[0] = data;
@@ -68,7 +68,7 @@
 
 bool CDVDCodecUtils::CopyPicture(DVDVideoPicture* pDst, DVDVideoPicture* pSrc)
 {
-  BYTE *s, *d;
+  uint8_t *s, *d;
   int w = pSrc->iWidth;
   int h = pSrc->iHeight;
 
@@ -107,8 +107,8 @@
 
 bool CDVDCodecUtils::CopyPicture(YV12Image* pImage, DVDVideoPicture *pSrc)
 {
-  BYTE *s = pSrc->data[0];
-  BYTE *d = pImage->plane[0];
+  uint8_t *s = pSrc->data[0];
+  uint8_t *d = pImage->plane[0];
   int w = pImage->width * pImage->bpp;
   int h = pImage->height;
   if ((w == pSrc->iLineSize[0]) && ((unsigned int) pSrc->iLineSize[0] == pImage->stride[0]))
@@ -171,7 +171,7 @@
     int h = pPicture->iHeight / 2;
     int size = w * h;
     int totalsize = (pPicture->iWidth * pPicture->iHeight) + size * 2;
-    BYTE* data = new BYTE[totalsize];
+    uint8_t* data = new uint8_t[totalsize];
     if (data)
     {
       pPicture->data[0] = data;
@@ -226,7 +226,7 @@
     *pPicture = *pSrc;
 
     int totalsize = pPicture->iWidth * pPicture->iHeight * 2;
-    BYTE* data = new BYTE[totalsize];
+    uint8_t* data = new uint8_t[totalsize];
 
     if (data)
     {
@@ -280,8 +280,8 @@
 
 bool CDVDCodecUtils::CopyNV12Picture(YV12Image* pImage, DVDVideoPicture *pSrc)
 {
-  BYTE *s = pSrc->data[0];
-  BYTE *d = pImage->plane[0];
+  uint8_t *s = pSrc->data[0];
+  uint8_t *d = pImage->plane[0];
   int w = pSrc->iWidth;
   int h = pSrc->iHeight;
   // Copy Y
@@ -323,8 +323,8 @@
 
 bool CDVDCodecUtils::CopyYUV422PackedPicture(YV12Image* pImage, DVDVideoPicture *pSrc)
 {
-  BYTE *s = pSrc->data[0];
-  BYTE *d = pImage->plane[0];
+  uint8_t *s = pSrc->data[0];
+  uint8_t *d = pImage->plane[0];
   int w = pSrc->iWidth;
   int h = pSrc->iHeight;
 
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
--- a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp	2015-03-12 20:52:41.074096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp	2015-03-12 20:48:25.154096999 +0100
@@ -40,9 +40,6 @@
 #include "Audio/DVDAudioCodecLibMad.h"
 #include "Audio/DVDAudioCodecPcm.h"
 #include "Audio/DVDAudioCodecLPcm.h"
-#if defined(TARGET_DARWIN_OSX) || defined(TARGET_DARWIN_IOS)
-#include "Audio/DVDAudioCodecPassthroughFFmpeg.h"
-#endif
 #include "Audio/DVDAudioCodecPassthrough.h"
 #include "Overlay/DVDOverlayCodecSSA.h"
 #include "Overlay/DVDOverlayCodecText.h"
@@ -173,14 +170,14 @@
   CLog::Log(LOGDEBUG, "CDVDFactoryCodec: compiled in hardware support: %s", hwSupport.c_str());
 
   // dvd's have weird still-frames in it, which is not fully supported in ffmpeg
-  if(hint.stills && (hint.codec == CODEC_ID_MPEG2VIDEO || hint.codec == CODEC_ID_MPEG1VIDEO))
+  if(hint.stills && (hint.codec == AV_CODEC_ID_MPEG2VIDEO || hint.codec == AV_CODEC_ID_MPEG1VIDEO))
   {
     if( (pCodec = OpenCodec(new CDVDVideoCodecLibMpeg2(), hint, options)) ) return pCodec;
   }
 #if defined(HAVE_LIBVDADECODER)
   if (!hint.software && g_guiSettings.GetBool("videoplayer.usevda"))
   {
-    if (g_sysinfo.HasVDADecoder())
+    if (hint.codec == AV_CODEC_ID_H264 && !hint.ptsinvalid)
     {
       if (hint.codec == CODEC_ID_H264 && !hint.ptsinvalid)
       {
@@ -197,8 +194,8 @@
     {
       switch(hint.codec)
       {
-        case CODEC_ID_H264:
-          if (hint.codec == CODEC_ID_H264 && hint.ptsinvalid)
+        case AV_CODEC_ID_H264:
+          if (hint.codec == AV_CODEC_ID_H264 && hint.ptsinvalid)
             break;
           if ( (pCodec = OpenCodec(new CDVDVideoCodecVideoToolBox(), hint, options)) ) return pCodec;
         break;
@@ -216,13 +213,13 @@
     {
       switch(hint.codec)
       {
-        case CODEC_ID_VC1:
-        case CODEC_ID_WMV3:
-        case CODEC_ID_H264:
-        case CODEC_ID_MPEG2VIDEO:
-          if (hint.codec == CODEC_ID_H264 && hint.ptsinvalid)
+        case AV_CODEC_ID_VC1:
+        case AV_CODEC_ID_WMV3:
+        case AV_CODEC_ID_H264:
+        case AV_CODEC_ID_MPEG2VIDEO:
+          if (hint.codec == AV_CODEC_ID_H264 && hint.ptsinvalid)
             break;
-          if (hint.codec == CODEC_ID_MPEG2VIDEO && hint.width <= 720)
+          if (hint.codec == AV_CODEC_ID_MPEG2VIDEO && hint.width <= 720)
             break;
           if ( (pCodec = OpenCodec(new CDVDVideoCodecCrystalHD(), hint, options)) ) return pCodec;
         break;
@@ -236,7 +233,7 @@
 #if defined(HAVE_LIBOPENMAX)
   if (g_guiSettings.GetBool("videoplayer.useomx") && !hint.software )
   {
-      if (hint.codec == CODEC_ID_H264 || hint.codec == CODEC_ID_MPEG2VIDEO || hint.codec == CODEC_ID_VC1)
+      if (hint.codec == AV_CODEC_ID_H264 || hint.codec == AV_CODEC_ID_MPEG2VIDEO || hint.codec == AV_CODEC_ID_VC1)
     {
       if ( (pCodec = OpenCodec(new CDVDVideoCodecOpenMax(), hint, options)) ) return pCodec;
     }
@@ -266,59 +263,45 @@
   CDVDAudioCodec* pCodec = NULL;
   CDVDCodecOptions options;
 
-  if (passthrough)
-  {
-#if defined(TARGET_DARWIN_OSX) || defined(TARGET_DARWIN_IOS)
-    switch(hint.codec)
-    {
-      case CODEC_ID_AC3:
-      case CODEC_ID_DTS:
-        pCodec = OpenCodec( new CDVDAudioCodecPassthroughFFmpeg(), hint, options );
-        if( pCodec ) return pCodec;
-        break;
-      default:
-        break;      
-    }
-#endif
-    pCodec = OpenCodec( new CDVDAudioCodecPassthrough(), hint, options );
-    if( pCodec ) return pCodec;
-  }
+  // try passthrough first
+  pCodec = OpenCodec( new CDVDAudioCodecPassthrough(), hint, options );
+  if( pCodec ) return pCodec;
 
   switch (hint.codec)
   {
-  case CODEC_ID_MP2:
-  case CODEC_ID_MP3:
+  case AV_CODEC_ID_MP2:
+  case AV_CODEC_ID_MP3:
     {
       pCodec = OpenCodec( new CDVDAudioCodecLibMad(), hint, options );
       if( pCodec ) return pCodec;
       break;
     }
-  case CODEC_ID_PCM_S32LE:
-  case CODEC_ID_PCM_S32BE:
-  case CODEC_ID_PCM_U32LE:
-  case CODEC_ID_PCM_U32BE:
-  case CODEC_ID_PCM_S24LE:
-  case CODEC_ID_PCM_S24BE:
-  case CODEC_ID_PCM_U24LE:
-  case CODEC_ID_PCM_U24BE:
-  case CODEC_ID_PCM_S24DAUD:
-  case CODEC_ID_PCM_S16LE:
-  case CODEC_ID_PCM_S16BE:
-  case CODEC_ID_PCM_U16LE:
-  case CODEC_ID_PCM_U16BE:
-  case CODEC_ID_PCM_S8:
-  case CODEC_ID_PCM_U8:
-  case CODEC_ID_PCM_ALAW:
-  case CODEC_ID_PCM_MULAW:
+  case AV_CODEC_ID_PCM_S32LE:
+  case AV_CODEC_ID_PCM_S32BE:
+  case AV_CODEC_ID_PCM_U32LE:
+  case AV_CODEC_ID_PCM_U32BE:
+  case AV_CODEC_ID_PCM_S24LE:
+  case AV_CODEC_ID_PCM_S24BE:
+  case AV_CODEC_ID_PCM_U24LE:
+  case AV_CODEC_ID_PCM_U24BE:
+  case AV_CODEC_ID_PCM_S24DAUD:
+  case AV_CODEC_ID_PCM_S16LE:
+  case AV_CODEC_ID_PCM_S16BE:
+  case AV_CODEC_ID_PCM_U16LE:
+  case AV_CODEC_ID_PCM_U16BE:
+  case AV_CODEC_ID_PCM_S8:
+  case AV_CODEC_ID_PCM_U8:
+  case AV_CODEC_ID_PCM_ALAW:
+  case AV_CODEC_ID_PCM_MULAW:
     {
       pCodec = OpenCodec( new CDVDAudioCodecPcm(), hint, options );
       if( pCodec ) return pCodec;
       break;
     }
 #if 0
-  //case CODEC_ID_LPCM_S16BE:
-  //case CODEC_ID_LPCM_S20BE:
-  case CODEC_ID_LPCM_S24BE:
+  //case AV_CODEC_ID_LPCM_S16BE:
+  //case AV_CODEC_ID_LPCM_S20BE:
+  case AV_CODEC_ID_LPCM_S24BE:
     {
       pCodec = OpenCodec( new CDVDAudioCodecLPcm(), hint, options );
       if( pCodec ) return pCodec;
@@ -345,12 +328,18 @@
 
   switch (hint.codec)
   {
-    case CODEC_ID_TEXT:
+    case AV_CODEC_ID_TEXT:
+#if defined(LIBAVCODEC_FROM_FFMPEG) && LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(54,53,100)
+    // API changed in:
+    // ffmpeg: commit 2626cc4580bfd560c6983338d77b2c11c16af94f (11 Aug 2012)
+    //         release 1.0 (28 Sept 2012)
+    case AV_CODEC_ID_SUBRIP:
+#endif
       pCodec = OpenCodec(new CDVDOverlayCodecText(), hint, options);
       if( pCodec ) return pCodec;
       break;
 
-    case CODEC_ID_SSA:
+    case AV_CODEC_ID_SSA:
       pCodec = OpenCodec(new CDVDOverlayCodecSSA(), hint, options);
       if( pCodec ) return pCodec;
 
@@ -358,7 +347,7 @@
       if( pCodec ) return pCodec;
       break;
 
-    case CODEC_ID_MOV_TEXT:
+    case AV_CODEC_ID_MOV_TEXT:
       pCodec = OpenCodec(new CDVDOverlayCodecTX3G(), hint, options);
       if( pCodec ) return pCodec;
       break;
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecCC.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecCC.cpp
--- a/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecCC.cpp	2015-03-12 20:52:41.078096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecCC.cpp	2015-03-12 20:48:25.154096999 +0100
@@ -50,7 +50,7 @@
   m_cc_decoder = NULL;
 }
 /*
-int CDVDOverlayCodecCC::DecodeFieldData(BYTE* pData, int iSize)
+int CDVDOverlayCodecCC::DecodeFieldData(uint8_t* pData, int iSize)
 {
 }
 */
@@ -60,8 +60,8 @@
   if (!pPacket)
     return OC_ERROR;
 
-  BYTE *pData = pPacket->pData;
-  int iSize = pPacket->iSize;
+  uint8_t *pData = pPacket->pData;
+  int      iSize = pPacket->iSize;
 
   // minimum amount of data is even more for cc
   decode_cc(m_cc_decoder, pData, iSize);
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.cpp
--- a/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.cpp	2015-03-12 20:52:41.078096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.cpp	2015-03-12 20:48:25.154096999 +0100
@@ -60,7 +60,6 @@
   m_pCodecContext->debug_mv = 0;
   m_pCodecContext->debug = 0;
   m_pCodecContext->workaround_bugs = FF_BUG_AUTODETECT;
-  m_pCodecContext->sub_id = hints.identifier;
   m_pCodecContext->codec_tag = hints.codec_tag;
   m_pCodecContext->time_base.num = 1;
   m_pCodecContext->time_base.den = DVD_TIME_BASE;
@@ -182,7 +181,7 @@
 
   double pts_offset = 0.0;
  
-  if (m_pCodecContext->codec_id == CODEC_ID_HDMV_PGS_SUBTITLE && m_Subtitle.format == 0) 
+  if (m_pCodecContext->codec_id == AV_CODEC_ID_HDMV_PGS_SUBTITLE && m_Subtitle.format == 0)
   {
     // for pgs subtitles the packet pts of the end_segments are wrong
     // instead use the subtitle pts to calc the offset here
@@ -252,7 +251,7 @@
     overlay->iPTSStopTime  = m_StopTime;
     overlay->replace  = true;
     overlay->linesize = rect.w;
-    overlay->data     = (BYTE*)malloc(rect.w * rect.h);
+    overlay->data     = (uint8_t*)malloc(rect.w * rect.h);
     overlay->palette  = (uint32_t*)malloc(rect.nb_colors*4);
     overlay->palette_colors = rect.nb_colors;
     overlay->x        = rect.x;
@@ -302,8 +301,8 @@
     overlay->source_width  = m_width;
     overlay->source_height = m_height;
 
-    BYTE* s = rect.pict.data[0];
-    BYTE* t = overlay->data;
+    uint8_t* s = rect.pict.data[0];
+    uint8_t* t = overlay->data;
     for(int i=0;i<rect.h;i++)
     {
       memcpy(t, s, rect.w);
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecSSA.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecSSA.cpp
--- a/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecSSA.cpp	2015-03-12 20:52:41.078096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecSSA.cpp	2015-03-12 20:48:25.154096999 +0100
@@ -44,7 +44,7 @@
 
 bool CDVDOverlayCodecSSA::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
 {
-  if(hints.codec != CODEC_ID_SSA)
+  if(hints.codec != AV_CODEC_ID_SSA)
     return false;
 
   Dispose();
@@ -69,7 +69,7 @@
     return OC_ERROR;
   
   double pts = pPacket->dts != DVD_NOPTS_VALUE ? pPacket->dts : pPacket->pts;
-  BYTE *data = pPacket->pData;
+  uint8_t *data = pPacket->pData;
   int size = pPacket->iSize;
   double duration = pPacket->duration;
   if(duration == DVD_NOPTS_VALUE)
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecText.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecText.cpp
--- a/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecText.cpp	2015-03-12 20:52:41.078096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecText.cpp	2015-03-12 20:48:25.154096999 +0100
@@ -41,8 +41,8 @@
 
 bool CDVDOverlayCodecText::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
 {
-  m_bIsSSA = (hints.codec == CODEC_ID_SSA);
-  if(hints.codec == CODEC_ID_TEXT || hints.codec == CODEC_ID_SSA)
+  m_bIsSSA = (hints.codec == AV_CODEC_ID_SSA);
+  if(hints.codec == AV_CODEC_ID_TEXT || hints.codec == AV_CODEC_ID_SSA)
     return true;
   return false;
 }
@@ -61,8 +61,8 @@
   if(!pPacket)
     return OC_ERROR;
   
-  BYTE *data = pPacket->pData;
-  int size = pPacket->iSize;
+  uint8_t *data = pPacket->pData;
+  int      size = pPacket->iSize;
   
   m_pOverlay = new CDVDOverlayText();
   CDVDOverlayCodec::GetAbsoluteTimes(m_pOverlay->iPTSStartTime, m_pOverlay->iPTSStopTime, pPacket, m_pOverlay->replace);
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecTX3G.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecTX3G.cpp
--- a/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecTX3G.cpp	2015-03-12 20:52:41.078096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecTX3G.cpp	2015-03-12 20:48:25.154096999 +0100
@@ -75,7 +75,7 @@
 
 bool CDVDOverlayCodecTX3G::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
 {
-  if (hints.codec == CODEC_ID_MOV_TEXT)
+  if (hints.codec == AV_CODEC_ID_MOV_TEXT)
     return true;
   return false;
 }
@@ -91,7 +91,7 @@
   if (m_pOverlay)
     SAFE_RELEASE(m_pOverlay);
 
-  BYTE *data = pPacket->pData;
+  uint8_t *data = pPacket->pData;
   int size = pPacket->iSize;
 
   m_pOverlay = new CDVDOverlayText();
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayImage.h b/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayImage.h
--- a/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayImage.h	2015-03-12 20:52:41.078096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayImage.h	2015-03-12 20:48:25.154096999 +0100
@@ -45,7 +45,7 @@
   CDVDOverlayImage(const CDVDOverlayImage& src)
     : CDVDOverlay(src)
   {
-    data    = (BYTE*)malloc(src.linesize * src.height);
+    data    = (uint8_t*)malloc(src.linesize * src.height);
     memcpy(data, src.data, src.linesize * src.height);
 
     if(src.palette)
@@ -92,10 +92,10 @@
     source_width   = src.source_width;
     source_height  = src.source_height;
 
-    data = (BYTE*)malloc(height*linesize);
+    data = (uint8_t*)malloc(height*linesize);
 
-    BYTE* s = src.data_at(sub_x, sub_y);
-    BYTE* t = data;
+    uint8_t* s = src.data_at(sub_x, sub_y);
+    uint8_t* t = data;
 
     for(int row = 0;row < sub_h; ++row)
     {
@@ -123,7 +123,7 @@
     return new CDVDOverlayImage(*this);
   }
 
-  BYTE* data_at(int sub_x, int sub_y) const
+  uint8_t* data_at(int sub_x, int sub_y) const
   {
     int bpp;
     if(palette)
@@ -134,7 +134,7 @@
                  (sub_x - x)*bpp];
   }
 
-  BYTE*  data;
+  uint8_t*  data;
   int    linesize;
 
   uint32_t* palette;
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlaySpu.h b/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlaySpu.h
--- a/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlaySpu.h	2015-03-12 20:52:41.078096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlaySpu.h	2015-03-12 20:48:25.154096999 +0100
@@ -74,7 +74,7 @@
     memcpy(highlight_color, src.highlight_color, sizeof(highlight_color));
   }
 
-  BYTE result[2*65536 + 20]; // rle data
+  uint8_t result[2*65536 + 20]; // rle data
   int pTFData; // pointer to top field picture data (needs rle parsing)
   int pBFData; // pointer to bottom field picture data (needs rle parsing)
   int x;
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Video/CMakeLists.txt b/xbmc/cores/dvdplayer/DVDCodecs/Video/CMakeLists.txt
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/CMakeLists.txt	2015-03-12 20:52:41.078096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/CMakeLists.txt	2015-03-12 20:48:09.954096999 +0100
@@ -8,9 +8,9 @@
 	list(REMOVE_ITEM video_SRCS ./DXVA.cpp)
 endif()
 
-if (NOT TARGET_LINUX AND NOT TARGET_FREEBSD)
+if (NOT TARGET_LINUX)
 	list(REMOVE_ITEM video_SRCS ./VDPAU.cpp)
 	list(REMOVE_ITEM video_SRCS ./VAAPI.cpp)
 endif()
 
-add_sources(${video_SRCS})
+add_sources(${video_SRCS})
\ No newline at end of file
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Video/CrystalHD.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/CrystalHD.cpp
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/CrystalHD.cpp	2015-03-12 20:52:41.078096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/CrystalHD.cpp	2015-03-12 20:48:25.154096999 +0100
@@ -1647,10 +1647,10 @@
     default:
     case RENDER_FMT_NV12:
       // Y plane
-      pDvdVideoPicture->data[0] = (BYTE*)pBuffer->m_y_buffer_ptr;
+      pDvdVideoPicture->data[0] = (uint8_t*)pBuffer->m_y_buffer_ptr;
       pDvdVideoPicture->iLineSize[0] = pBuffer->m_width;
       // UV packed plane
-      pDvdVideoPicture->data[1] = (BYTE*)pBuffer->m_uv_buffer_ptr;
+      pDvdVideoPicture->data[1] = (uint8_t*)pBuffer->m_uv_buffer_ptr;
       pDvdVideoPicture->iLineSize[1] = pBuffer->m_width;
       // unused
       pDvdVideoPicture->data[2] = NULL;
@@ -1658,7 +1658,7 @@
     break;
     case RENDER_FMT_YUYV422:
       // YUV packed plane
-      pDvdVideoPicture->data[0] = (BYTE*)pBuffer->m_y_buffer_ptr;
+      pDvdVideoPicture->data[0] = (uint8_t*)pBuffer->m_y_buffer_ptr;
       pDvdVideoPicture->iLineSize[0] = pBuffer->m_width * 2;
       // unused
       pDvdVideoPicture->data[1] = NULL;
@@ -1669,13 +1669,13 @@
     break;
     case RENDER_FMT_YUV420P:
       // Y plane
-      pDvdVideoPicture->data[0] = (BYTE*)pBuffer->m_y_buffer_ptr;
+      pDvdVideoPicture->data[0] = (uint8_t*)pBuffer->m_y_buffer_ptr;
       pDvdVideoPicture->iLineSize[0] = pBuffer->m_width;
       // U plane
-      pDvdVideoPicture->data[1] = (BYTE*)pBuffer->m_u_buffer_ptr;
+      pDvdVideoPicture->data[1] = (uint8_t*)pBuffer->m_u_buffer_ptr;
       pDvdVideoPicture->iLineSize[1] = pBuffer->m_width / 2;
       // V plane
-      pDvdVideoPicture->data[2] = (BYTE*)pBuffer->m_v_buffer_ptr;
+      pDvdVideoPicture->data[2] = (uint8_t*)pBuffer->m_v_buffer_ptr;
       pDvdVideoPicture->iLineSize[2] = pBuffer->m_width / 2;
     break;
   }
@@ -1888,7 +1888,7 @@
   return true;
 }
 
-bool CCrystalHD::bitstream_convert(BYTE* pData, int iSize, uint8_t **poutbuf, int *poutbuf_size)
+bool CCrystalHD::bitstream_convert(uint8_t* pData, int iSize, uint8_t **poutbuf, int *poutbuf_size)
 {
   // based on h264_mp4toannexb_bsf.c (ffmpeg)
   // which is Copyright (c) 2007 Benoit Fouet <benoit.fouet@free.fr>
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCrystalHD.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCrystalHD.cpp
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCrystalHD.cpp	2015-03-12 20:52:41.078096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCrystalHD.cpp	2015-03-12 20:48:25.154096999 +0100
@@ -55,11 +55,11 @@
   {
     switch (hints.codec)
     {
-      case CODEC_ID_MPEG2VIDEO:
+      case AV_CODEC_ID_MPEG2VIDEO:
         m_CodecType = CRYSTALHD_CODEC_ID_MPEG2;
         m_pFormatName = "chd-mpeg2";
       break;
-      case CODEC_ID_H264:
+      case AV_CODEC_ID_H264:
         switch(hints.profile)
         {
           case FF_PROFILE_H264_HIGH_10:
@@ -86,11 +86,11 @@
 
         m_pFormatName = "chd-h264";
       break;
-      case CODEC_ID_VC1:
+      case AV_CODEC_ID_VC1:
         m_CodecType = CRYSTALHD_CODEC_ID_VC1;
         m_pFormatName = "chd-vc1";
       break;
-      case CODEC_ID_WMV3:
+      case AV_CODEC_ID_WMV3:
         m_CodecType = CRYSTALHD_CODEC_ID_WMV3;
         m_pFormatName = "chd-wmv3";
       break;
@@ -132,7 +132,7 @@
   }
 }
 
-int CDVDVideoCodecCrystalHD::Decode(BYTE *pData, int iSize, double dts, double pts)
+int CDVDVideoCodecCrystalHD::Decode(uint8_t *pData, int iSize, double dts, double pts)
 {
   if (!pData)
   {
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCrystalHD.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCrystalHD.h
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCrystalHD.h	2015-03-12 20:52:41.078096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCrystalHD.h	2015-03-12 20:48:25.154096999 +0100
@@ -34,7 +34,7 @@
   // Required overrides
   virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
   virtual void Dispose(void);
-  virtual int  Decode(BYTE *pData, int iSize, double dts, double pts);
+  virtual int  Decode(uint8_t *pData, int iSize, double dts, double pts);
   virtual void Reset(void);
   virtual bool GetPicture(DVDVideoPicture *pDvdVideoPicture);
   virtual void SetDropState(bool bDrop);
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp	2015-03-12 20:52:41.078096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp	2015-03-12 20:48:25.154096999 +0100
@@ -28,6 +28,7 @@
 #include "DVDClock.h"
 #include "DVDCodecs/DVDCodecs.h"
 #include "DVDCodecs/DVDCodecUtils.h"
+#include "DVDVideoPPFFmpeg.h"
 #if defined(_LINUX) || defined(_WIN32)
 #include "utils/CPUInfo.h"
 #endif
@@ -102,8 +103,8 @@
 #endif
 #ifdef HAVE_LIBVA
     // mpeg4 vaapi decoding is disabled
-    if(*cur == PIX_FMT_VAAPI_VLD && g_guiSettings.GetBool("videoplayer.usevaapi") 
-    && (avctx->codec_id != CODEC_ID_MPEG4 || g_advancedSettings.m_videoAllowMpeg4VAAPI)) 
+    if(*cur == PIX_FMT_VAAPI_VLD && CSettings::Get().GetBool("videoplayer.usevaapi")
+    && (avctx->codec_id != AV_CODEC_ID_MPEG4 || g_advancedSettings.m_videoAllowMpeg4VAAPI))
     {
       VAAPI::CDecoder* dec = new VAAPI::CDecoder();
       if(dec->Open(avctx, *cur))
@@ -127,7 +128,11 @@
   m_pFilterGraph  = NULL;
   m_pFilterIn     = NULL;
   m_pFilterOut    = NULL;
+#if defined(LIBAVFILTER_AVFRAME_BASED)
+  m_pFilterFrame  = NULL;
+#else
   m_pBufferRef    = NULL;
+#endif
 
   m_iPictureWidth = 0;
   m_iPictureHeight = 0;
@@ -156,6 +161,7 @@
   if(!m_dllAvUtil.Load()
   || !m_dllAvCodec.Load()
   || !m_dllSwScale.Load()
+  || !m_dllPostProc.Load()
   || !m_dllAvFilter.Load()
   ) return false;
 
@@ -176,7 +182,7 @@
   pCodec = NULL;
   m_pCodecContext = NULL;
 
-  if (hints.codec == CODEC_ID_H264)
+  if (hints.codec == AV_CODEC_ID_H264)
   {
     switch(hints.profile)
     {
@@ -254,8 +260,8 @@
   // ffmpeg with enabled neon will crash and burn if this is enabled
   m_pCodecContext->flags &= CODEC_FLAG_EMU_EDGE;
 #else
-  if (pCodec->id != CODEC_ID_H264 && pCodec->capabilities & CODEC_CAP_DR1
-      && pCodec->id != CODEC_ID_VP8
+  if (pCodec->id != AV_CODEC_ID_H264 && pCodec->capabilities & CODEC_CAP_DR1
+      && pCodec->id != AV_CODEC_ID_VP8
      )
     m_pCodecContext->flags |= CODEC_FLAG_EMU_EDGE;
 #endif
@@ -272,9 +278,6 @@
     memcpy(m_pCodecContext->extradata, hints.extradata, hints.extrasize);
   }
 
-  // set acceleration
-  m_pCodecContext->dsp_mask = 0;//FF_MM_FORCE | FF_MM_MMX | FF_MM_MMXEXT | FF_MM_SSE;
-
   // advanced setting override for skip loop filter (see avcodec.h for valid options)
   // TODO: allow per video setting?
   if (g_advancedSettings.m_iSkipLoopFilter != 0)
@@ -293,8 +296,8 @@
 
   int num_threads = std::min(8 /*MAX_THREADS*/, g_cpuInfo.getCPUCount());
   if( num_threads > 1 && !hints.software && m_pHardware == NULL // thumbnail extraction fails when run threaded
-  && ( pCodec->id == CODEC_ID_H264
-    || pCodec->id == CODEC_ID_MPEG4 ))
+  && ( pCodec->id == AV_CODEC_ID_H264
+    || pCodec->id == AV_CODEC_ID_MPEG4 ))
     m_pCodecContext->thread_count = num_threads;
 
   /* PLEX */
@@ -311,6 +314,11 @@
   m_pFrame = m_dllAvCodec.avcodec_alloc_frame();
   if (!m_pFrame) return false;
 
+#if defined(LIBAVFILTER_AVFRAME_BASED)
+  m_pFilterFrame = m_dllAvUtil.av_frame_alloc();
+  if (!m_pFilterFrame) return false;
+#endif
+
   UpdateName();
   return true;
 }
@@ -320,6 +328,10 @@
   if (m_pFrame) m_dllAvUtil.av_free(m_pFrame);
   m_pFrame = NULL;
 
+#if defined(LIBAVFILTER_AVFRAME_BASED)
+  m_dllAvUtil.av_frame_free(&m_pFilterFrame);
+#endif
+
   if (m_pCodecContext)
   {
     if (m_pCodecContext->codec) m_dllAvCodec.avcodec_close(m_pCodecContext);
@@ -339,6 +351,7 @@
   m_dllAvCodec.Unload();
   m_dllAvUtil.Unload();
   m_dllAvFilter.Unload();
+  m_dllPostProc.Unload();
 }
 
 void CDVDVideoCodecFFmpeg::SetDropState(bool bDrop)
@@ -426,7 +439,7 @@
   return u.pts_d;
 }
 
-int CDVDVideoCodecFFmpeg::Decode(BYTE* pData, int iSize, double dts, double pts)
+int CDVDVideoCodecFFmpeg::Decode(uint8_t* pData, int iSize, double dts, double pts)
 {
   int iGotPicture = 0, len = 0;
 
@@ -497,8 +510,8 @@
     m_iLastKeyframe = 300;
 
   /* h264 doesn't always have keyframes + won't output before first keyframe anyway */
-  if(m_pCodecContext->codec_id == CODEC_ID_H264
-  || m_pCodecContext->codec_id == CODEC_ID_SVQ3)
+  if(m_pCodecContext->codec_id == AV_CODEC_ID_H264
+  || m_pCodecContext->codec_id == AV_CODEC_ID_SVQ3)
     m_started = true;
 
   if(m_pHardware == NULL)
@@ -558,14 +571,16 @@
 
 bool CDVDVideoCodecFFmpeg::GetPictureCommon(DVDVideoPicture* pDvdVideoPicture)
 {
-  pDvdVideoPicture->iWidth = m_pCodecContext->width;
-  pDvdVideoPicture->iHeight = m_pCodecContext->height;
+  pDvdVideoPicture->iWidth = m_pFrame->width;
+  pDvdVideoPicture->iHeight = m_pFrame->height;
 
+#if !defined(LIBAVFILTER_AVFRAME_BASED)
   if(m_pBufferRef)
   {
     pDvdVideoPicture->iWidth  = m_pBufferRef->video->w;
     pDvdVideoPicture->iHeight = m_pBufferRef->video->h;
   }
+#endif
 
   /* crop of 10 pixels if demuxer asked it */
   if(m_pCodecContext->coded_width  && m_pCodecContext->coded_width  < (int)pDvdVideoPicture->iWidth
@@ -579,9 +594,11 @@
   double aspect_ratio;
 
   /* use variable in the frame */
-  AVRational pixel_aspect = m_pCodecContext->sample_aspect_ratio;
+  AVRational pixel_aspect = m_pFrame->sample_aspect_ratio;
+#if !defined(LIBAVFILTER_AVFRAME_BASED)
   if (m_pBufferRef)
     pixel_aspect = m_pBufferRef->video->sample_aspect_ratio;
+#endif
 
   if (pixel_aspect.num == 0)
     aspect_ratio = 0;
@@ -669,10 +686,12 @@
   pDvdVideoPicture->extended_format = 0;
 
   PixelFormat pix_fmt;
+#if !defined(LIBAVFILTER_AVFRAME_BASED)
   if(m_pBufferRef)
     pix_fmt = (PixelFormat)m_pBufferRef->format;
   else
-    pix_fmt = m_pCodecContext->pix_fmt;
+#endif
+    pix_fmt = (PixelFormat)m_pFrame->format;
 
   pDvdVideoPicture->format = CDVDCodecUtils::EFormatFromPixfmt(pix_fmt);
   return true;
@@ -750,7 +769,13 @@
     inputs->pad_idx = 0;
     inputs->next    = NULL;
 
+#if defined(HAVE_AVFILTER_GRAPH_PARSE_PTR)
+    if ((result = m_dllAvFilter.avfilter_graph_parse_ptr(m_pFilterGraph, (const char*)m_filters.c_str(), &inputs, &outputs, NULL)) < 0)
+#elif defined(AVFILTER_GRAPH_PARSE_TAKES_PTR_PTR_ARG)
     if ((result = m_dllAvFilter.avfilter_graph_parse(m_pFilterGraph, (const char*)m_filters.c_str(), &inputs, &outputs, NULL)) < 0)
+#else
+    if ((result = m_dllAvFilter.avfilter_graph_parse(m_pFilterGraph, (const char*)m_filters.c_str(), inputs, outputs, NULL)) < 0)
+#endif
     {
       CLog::Log(LOGERROR, "CDVDVideoCodecFFmpeg::FilterOpen - avfilter_graph_parse");
       return result;
@@ -779,11 +804,13 @@
 
 void CDVDVideoCodecFFmpeg::FilterClose()
 {
+#if !defined(LIBAVFILTER_AVFRAME_BASED)
   if(m_pBufferRef)
   {
     m_dllAvFilter.avfilter_unref_buffer(m_pBufferRef);
     m_pBufferRef = NULL;
   }
+#endif
 
   if (m_pFilterGraph)
   {
@@ -797,26 +824,48 @@
 
 int CDVDVideoCodecFFmpeg::FilterProcess(AVFrame* frame)
 {
-  int result, frames;
+  int result;
 
   if (frame)
   {
-#if LIBAVFILTER_VERSION_INT < AV_VERSION_INT(3,0,0)
-    result = m_dllAvFilter.av_vsrc_buffer_add_frame(m_pFilterIn, frame, 0);
+#if defined(LIBAVFILTER_AVFRAME_BASED)
+    // API changed in:
+    // ffmpeg: commit 7e350379f87e7f74420b4813170fe808e2313911 (28 Nov 2012)
+    //         not released (post 1.2)
+    // libav: commit 7e350379f87e7f74420b4813170fe808e2313911 (28 Nov 2012)
+    //        release v9 (5 January 2013)
+    result = m_dllAvFilter.av_buffersrc_add_frame(m_pFilterIn, frame);
 #else
+    // API changed in:
+    // ffmpeg: commit 7bac2a78c2241df4bcc1665703bb71afd9a3e692 (28 Apr 2012)
+    //         release 0.11 (25 May 2012)
     result = m_dllAvFilter.av_buffersrc_add_frame(m_pFilterIn, frame, 0);
 #endif
     if (result < 0)
     {
-#if LIBAVFILTER_VERSION_INT < AV_VERSION_INT(3,0,0)
-      CLog::Log(LOGERROR, "CDVDVideoCodecFFmpeg::FilterProcess - av_vsrc_buffer_add_frame");
-#else
       CLog::Log(LOGERROR, "CDVDVideoCodecFFmpeg::FilterProcess - av_buffersrc_add_frame");
-#endif
       return VC_ERROR;
     }
   }
 
+#if defined(LIBAVFILTER_AVFRAME_BASED)
+  result = m_dllAvFilter.av_buffersink_get_frame(m_pFilterOut, m_pFilterFrame);
+
+  if(result  == AVERROR(EAGAIN) || result == AVERROR_EOF)
+    return VC_BUFFER;
+  else if(result < 0)
+  {
+    CLog::Log(LOGERROR, "CDVDVideoCodecFFmpeg::FilterProcess - av_buffersink_get_frame");
+    return VC_ERROR;
+  }
+
+  m_dllAvUtil.av_frame_unref(m_pFrame);
+  m_dllAvUtil.av_frame_move_ref(m_pFrame, m_pFilterFrame);
+
+  return VC_PICTURE;
+#else
+  int frames;
+
   if(m_pBufferRef)
   {
     m_dllAvFilter.avfilter_unref_buffer(m_pBufferRef);
@@ -857,6 +906,7 @@
   }
 
   return VC_BUFFER;
+#endif
 }
 
 unsigned CDVDVideoCodecFFmpeg::GetConvergeCount()
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h	2015-03-12 20:52:41.078096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h	2015-03-12 20:48:25.154096999 +0100
@@ -27,6 +27,7 @@
 #include "DllAvUtil.h"
 #include "DllSwScale.h"
 #include "DllAvFilter.h"
+#include "DllPostProc.h"
 
 class CVDPAU;
 class CCriticalSection;
@@ -52,7 +53,7 @@
   virtual ~CDVDVideoCodecFFmpeg();
   virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
   virtual void Dispose();
-  virtual int Decode(BYTE* pData, int iSize, double dts, double pts);
+  virtual int Decode(uint8_t* pData, int iSize, double dts, double pts);
   virtual void Reset();
   bool GetPictureCommon(DVDVideoPicture* pDvdVideoPicture);
   virtual bool GetPicture(DVDVideoPicture* pDvdVideoPicture);
@@ -96,7 +97,11 @@
   AVFilterGraph*   m_pFilterGraph;
   AVFilterContext* m_pFilterIn;
   AVFilterContext* m_pFilterOut;
+#if defined(LIBAVFILTER_AVFRAME_BASED)
+  AVFrame*         m_pFilterFrame;
+#else
   AVFilterBufferRef* m_pBufferRef;
+#endif
 
   int m_iPictureWidth;
   int m_iPictureHeight;
@@ -111,6 +116,7 @@
   DllAvUtil  m_dllAvUtil;
   DllSwScale m_dllSwScale;
   DllAvFilter m_dllAvFilter;
+  DllPostProc m_dllPostProc;
 
   std::string m_name;
   bool              m_bSoftware;
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h	2015-03-12 20:52:41.078096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h	2015-03-12 20:48:25.154096999 +0100
@@ -48,7 +48,7 @@
   union
   {
     struct {
-      BYTE* data[4];      // [4] = alpha channel, currently not used
+      uint8_t* data[4];      // [4] = alpha channel, currently not used
       int iLineSize[4];   // [4] = alpha channel, currently not used
     };
     struct {
@@ -98,7 +98,7 @@
 
 struct DVDVideoUserData
 {
-  BYTE* data;
+  uint8_t* data;
   int size;
 };
 
@@ -148,7 +148,7 @@
    * returns one or a combination of VC_ messages
    * pData and iSize can be NULL, this means we should flush the rest of the data.
    */
-  virtual int Decode(BYTE* pData, int iSize, double dts, double pts) = 0;
+  virtual int Decode(uint8_t* pData, int iSize, double dts, double pts) = 0;
 
  /*
    * Reset the decoder.
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecLibMpeg2.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecLibMpeg2.cpp
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecLibMpeg2.cpp	2015-03-12 20:52:41.078096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecLibMpeg2.cpp	2015-03-12 20:48:25.154096999 +0100
@@ -23,12 +23,6 @@
 #include "DVDStreamInfo.h"
 #include "utils/log.h"
 
-/* I really don't want to include ffmpeg headers here, could */
-/* potentially interfere with libmpeg2's, so let's just define this */
-#ifndef _LINUX
-const int CODEC_ID_MPEG1VIDEO = 1;
-#endif
-
 enum MPEGProfile
 {
   MPEG_422_HL = 0x82,
@@ -113,9 +107,9 @@
         m_pVideoBuffer[i].iWidth = width;
         m_pVideoBuffer[i].iHeight = height;
 
-        m_pVideoBuffer[i].data[0] = (BYTE*)_aligned_malloc(iPixels, 16);    //Y
-        m_pVideoBuffer[i].data[1] = (BYTE*)_aligned_malloc(iChromaPixels, 16);  //U
-        m_pVideoBuffer[i].data[2] = (BYTE*)_aligned_malloc(iChromaPixels, 16);  //V
+        m_pVideoBuffer[i].data[0] = (uint8_t*)_aligned_malloc(iPixels, 16);    //Y
+        m_pVideoBuffer[i].data[1] = (uint8_t*)_aligned_malloc(iChromaPixels, 16);  //U
+        m_pVideoBuffer[i].data[2] = (uint8_t*)_aligned_malloc(iChromaPixels, 16);  //V
 
         //Set all data to 0 for less artifacts.. hmm.. what is black in YUV??
         memset( m_pVideoBuffer[i].data[0], 0, iPixels );
@@ -210,7 +204,7 @@
   m_hurry = bDrop ? 1 : 0;
 }
 
-int CDVDVideoCodecLibMpeg2::Decode(BYTE* pData, int iSize, double dts, double pts)
+int CDVDVideoCodecLibMpeg2::Decode(uint8_t* pData, int iSize, double dts, double pts)
 {
   int iState = 0;
   if (!m_pHandle) return VC_ERROR;
@@ -506,7 +500,7 @@
 {
   if (pDvdVideoUserData && m_pInfo && m_pInfo->user_data && m_pInfo->user_data_len > 0)
   {
-    pDvdVideoUserData->data = (BYTE*)m_pInfo->user_data;
+    pDvdVideoUserData->data = (uint8_t*)m_pInfo->user_data;
     pDvdVideoUserData->size = m_pInfo->user_data_len;
     return true;
   }
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecLibMpeg2.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecLibMpeg2.h
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecLibMpeg2.h	2015-03-12 20:52:41.078096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecLibMpeg2.h	2015-03-12 20:48:25.154096999 +0100
@@ -30,7 +30,7 @@
   virtual ~CDVDVideoCodecLibMpeg2();
   virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
   virtual void Dispose();
-  virtual int Decode(BYTE* pData, int iSize, double dts, double pts);
+  virtual int Decode(uint8_t* pData, int iSize, double dts, double pts);
   virtual void Reset();
   virtual bool GetPicture(DVDVideoPicture* pDvdVideoPicture);
   virtual bool GetUserData(DVDVideoUserData* pDvdVideoUserData);
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp	2015-03-12 20:52:41.078096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp	2015-03-12 20:48:25.154096999 +0100
@@ -58,7 +58,7 @@
 
     switch (hints.codec)
     {
-      case CODEC_ID_H264:
+      case AV_CODEC_ID_H264:
       {
         m_pFormatName = "omx-h264";
         if (hints.extrasize < 7 || hints.extradata == NULL)
@@ -72,13 +72,13 @@
           m_convert_bitstream = bitstream_convert_init(hints.extradata, hints.extrasize);
       }
       break;
-      case CODEC_ID_MPEG4:
+      case AV_CODEC_ID_MPEG4:
         m_pFormatName = "omx-mpeg4";
       break;
-      case CODEC_ID_MPEG2VIDEO:
+      case AV_CODEC_ID_MPEG2VIDEO:
         m_pFormatName = "omx-mpeg2";
       break;
-      case CODEC_ID_VC1:
+      case AV_CODEC_ID_VC1:
         m_pFormatName = "omx-vc1";
       break;
       default:
@@ -146,7 +146,7 @@
   m_omx_decoder->SetDropState(bDrop);
 }
 
-int CDVDVideoCodecOpenMax::Decode(BYTE* pData, int iSize, double dts, double pts)
+int CDVDVideoCodecOpenMax::Decode(uint8_t* pData, int iSize, double dts, double pts)
 {
   if (pData)
   {
@@ -254,7 +254,7 @@
   return true;
 }
 
-bool CDVDVideoCodecOpenMax::bitstream_convert(BYTE* pData, int iSize, uint8_t **poutbuf, int *poutbuf_size)
+bool CDVDVideoCodecOpenMax::bitstream_convert(uint8_t* pData, int iSize, uint8_t **poutbuf, int *poutbuf_size)
 {
   // based on h264_mp4toannexb_bsf.c (ffmpeg)
   // which is Copyright (c) 2007 Benoit Fouet <benoit.fouet@free.fr>
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h	2015-03-12 20:52:41.078096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h	2015-03-12 20:48:25.154096999 +0100
@@ -33,12 +33,12 @@
   // Required overrides
   virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
   virtual void Dispose(void);
-  virtual int  Decode(BYTE *pData, int iSize, double dts, double pts);
+  virtual int  Decode(uint8_t *pData, int iSize, double dts, double pts);
   virtual void Reset(void);
   virtual bool GetPicture(DVDVideoPicture *pDvdVideoPicture);
   virtual void SetDropState(bool bDrop);
   virtual const char* GetName(void) { return (const char*)m_pFormatName; }
-  
+
 protected:
   const char        *m_pFormatName;
   COpenMaxVideo     *m_omx_decoder;
@@ -46,8 +46,8 @@
 
   // bitstream to bytestream (Annex B) conversion support.
   bool bitstream_convert_init(void *in_extradata, int in_extrasize);
-  bool bitstream_convert(BYTE* pData, int iSize, uint8_t **poutbuf, int *poutbuf_size);
-  void bitstream_alloc_and_copy( uint8_t **poutbuf, int *poutbuf_size,
+  bool bitstream_convert(uint8_t* pData, int iSize, uint8_t **poutbuf, int *poutbuf_size);
+  static void bitstream_alloc_and_copy( uint8_t **poutbuf, int *poutbuf_size,
     const uint8_t *sps_pps, uint32_t sps_pps_size, const uint8_t *in, uint32_t in_size);
 
   typedef struct omx_bitstream_ctx {
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVDA.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVDA.cpp
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVDA.cpp	2015-03-12 20:52:41.078096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVDA.cpp	2015-03-12 20:48:25.154096999 +0100
@@ -667,7 +667,7 @@
     int profile = hints.profile;
     extrasize = hints.extrasize;
     extradata = (uint8_t*)hints.extradata;
-    
+
     switch(profile)
     {
       case FF_PROFILE_H264_HIGH_10:
@@ -688,7 +688,7 @@
         __FUNCTION__, width, height);
       return false;
     }
-    
+
     if (Cocoa_GPUForDisplayIsNvidiaPureVideo3() && !CDVDCodecUtils::IsVP3CompatibleWidth(width))
     {
       CLog::Log(LOGNOTICE, "%s - Nvidia 9400 GPU hardware limitation, cannot decode a width of %d", __FUNCTION__, width);
@@ -697,11 +697,9 @@
 
     switch (hints.codec)
     {
-      case CODEC_ID_H264:
-        // source must be H.264 with valid avcC atom data in extradata
-        if (extrasize < 7 || extradata == NULL)
-        {
-          CLog::Log(LOGNOTICE, "%s - avcC atom too data small or missing", __FUNCTION__);
+      case AV_CODEC_ID_H264:
+        m_bitstream = new CBitstreamConverter;
+        if (!m_bitstream->Open(hints.codec, (uint8_t*)hints.extradata, hints.extrasize, false))
           return false;
         }
         // valid avcC atom data always starts with the value 1 (version)
@@ -855,9 +853,9 @@
       m_videobuffer.iLineSize[2] = width/2; //V
       m_videobuffer.iLineSize[3] = 0;
 
-      m_videobuffer.data[0] = (BYTE*)malloc(16 + iPixels);
-      m_videobuffer.data[1] = (BYTE*)malloc(16 + iChromaPixels);
-      m_videobuffer.data[2] = (BYTE*)malloc(16 + iChromaPixels);
+      m_videobuffer.data[0] = (uint8_t*)malloc(16 + iPixels);
+      m_videobuffer.data[1] = (uint8_t*)malloc(16 + iChromaPixels);
+      m_videobuffer.data[2] = (uint8_t*)malloc(16 + iChromaPixels);
       m_videobuffer.data[3] = NULL;
 
       // set all data to 0 for less artifacts.. hmm.. what is black in YUV??
@@ -967,7 +965,7 @@
   m_DropPictures = bDrop;
 }
 
-int CDVDVideoCodecVDA::Decode(BYTE* pData, int iSize, double dts, double pts)
+int CDVDVideoCodecVDA::Decode(uint8_t* pData, int iSize, double dts, double pts)
 {
   CCocoaAutoPool pool;
   //
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVDA.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVDA.h
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVDA.h	2015-03-12 20:52:41.078096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVDA.h	2015-03-12 20:48:25.154096999 +0100
@@ -47,7 +47,7 @@
   // Required overrides
   virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
   virtual void Dispose(void);
-  virtual int  Decode(BYTE *pData, int iSize, double dts, double pts);
+  virtual int  Decode(uint8_t *pData, int iSize, double dts, double pts);
   virtual void Reset(void);
   virtual bool GetPicture(DVDVideoPicture *pDvdVideoPicture);
   virtual bool ClearPicture(DVDVideoPicture* pDvdVideoPicture);
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVideoToolBox.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVideoToolBox.cpp
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVideoToolBox.cpp	2015-03-12 20:52:41.078096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVideoToolBox.cpp	2015-03-12 20:48:25.154096999 +0100
@@ -538,7 +538,7 @@
   esds->esid            = 0;
   esds->stream_priority = 0;      // 16 ? 0x1f
   
-  esds->objectTypeId    = 32;     // 32 = CODEC_ID_MPEG4, 33 = CODEC_ID_H264
+  esds->objectTypeId    = 32;     // 32 = AV_CODEC_ID_MPEG4, 33 = AV_CODEC_ID_H264
   // the following fields is made of 6 bits to identify the streamtype (4 for video, 5 for audio)
   // plus 1 bit to indicate upstream and 1 bit set to 1 (reserved)
   esds->streamType      = 0x11;
@@ -1095,7 +1095,7 @@
     
     switch (hints.codec)
     {
-      case CODEC_ID_MPEG4:
+      case AV_CODEC_ID_MPEG4:
         if (extrasize)
         {
           AVIOContext *pb;
@@ -1127,12 +1127,12 @@
         m_pFormatName = "vtb-mpeg4";
       break;
 
-      case CODEC_ID_MPEG2VIDEO:
+      case AV_CODEC_ID_MPEG2VIDEO:
         m_fmt_desc = CreateFormatDescription(kVTFormatMPEG2Video, width, height);
         m_pFormatName = "vtb-mpeg2";
       break;
 
-      case CODEC_ID_H264:
+      case AV_CODEC_ID_H264:
         if (extrasize < 7 || extradata == NULL)
         {
           //m_fmt_desc = CreateFormatDescription(kVTFormatH264, width, height);
@@ -1330,7 +1330,7 @@
   m_DropPictures = bDrop;
 }
 
-int CDVDVideoCodecVideoToolBox::Decode(BYTE* pData, int iSize, double dts, double pts)
+int CDVDVideoCodecVideoToolBox::Decode(uint8_t* pData, int iSize, double dts, double pts)
 {
   if (pData)
   {
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVideoToolBox.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVideoToolBox.h
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVideoToolBox.h	2015-03-12 20:52:41.078096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVideoToolBox.h	2015-03-12 20:48:25.154096999 +0100
@@ -50,7 +50,7 @@
   // Required overrides
   virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
   virtual void Dispose(void);
-  virtual int  Decode(BYTE *pData, int iSize, double dts, double pts);
+  virtual int  Decode(uint8_t *pData, int iSize, double dts, double pts);
   virtual void Reset(void);
   virtual bool GetPicture(DVDVideoPicture *pDvdVideoPicture);
   virtual bool ClearPicture(DVDVideoPicture* pDvdVideoPicture);
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoPPFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoPPFFmpeg.cpp
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoPPFFmpeg.cpp	2015-03-12 20:52:41.078096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoPPFFmpeg.cpp	2015-03-12 20:48:25.154096999 +0100
@@ -186,9 +186,9 @@
     m_FrameBuffer.iWidth = pSource->iWidth;
     m_FrameBuffer.iHeight = pSource->iHeight;
 
-    m_FrameBuffer.data[0] = (BYTE*)_aligned_malloc(m_FrameBuffer.iLineSize[0] * m_FrameBuffer.iHeight  , 16);
-    m_FrameBuffer.data[1] = (BYTE*)_aligned_malloc(m_FrameBuffer.iLineSize[1] * m_FrameBuffer.iHeight/2, 16);
-    m_FrameBuffer.data[2] = (BYTE*)_aligned_malloc(m_FrameBuffer.iLineSize[2] * m_FrameBuffer.iHeight/2, 16);
+    m_FrameBuffer.data[0] = (uint8_t*)_aligned_malloc(m_FrameBuffer.iLineSize[0] * m_FrameBuffer.iHeight  , 16);
+    m_FrameBuffer.data[1] = (uint8_t*)_aligned_malloc(m_FrameBuffer.iLineSize[1] * m_FrameBuffer.iHeight/2, 16);
+    m_FrameBuffer.data[2] = (uint8_t*)_aligned_malloc(m_FrameBuffer.iLineSize[2] * m_FrameBuffer.iHeight/2, 16);
 
     if( !m_FrameBuffer.data[0] || !m_FrameBuffer.data[1] || !m_FrameBuffer.data[2])
     {
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Video/DXVA.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DXVA.cpp
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DXVA.cpp	2015-03-12 20:52:41.078096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DXVA.cpp	2015-03-12 20:48:25.154096999 +0100
@@ -95,19 +95,19 @@
 
 /* XXX Prefered modes must come first */
 static const dxva2_mode_t dxva2_modes[] = {
-    { "MPEG2 VLD",    &DXVA2_ModeMPEG2_VLD,     CODEC_ID_MPEG2VIDEO },
-    { "MPEG1/2 VLD",  &DXVA_ModeMPEG2and1_VLD,  CODEC_ID_MPEG2VIDEO },
+    { "MPEG2 VLD",    &DXVA2_ModeMPEG2_VLD,     AV_CODEC_ID_MPEG2VIDEO },
+    { "MPEG1/2 VLD",  &DXVA_ModeMPEG2and1_VLD,  AV_CODEC_ID_MPEG2VIDEO },
     { "MPEG2 MoComp", &DXVA2_ModeMPEG2_MoComp,  0 },
     { "MPEG2 IDCT",   &DXVA2_ModeMPEG2_IDCT,    0 },
 
     // Intel drivers return standard modes in addition to the Intel specific ones. Try the Intel specific first, they work better for Sandy Bridges.
-    { "Intel H.264 VLD, no FGT",                                      &DXVADDI_Intel_ModeH264_E, CODEC_ID_H264 },
+    { "Intel H.264 VLD, no FGT",                                      &DXVADDI_Intel_ModeH264_E, AV_CODEC_ID_H264 },
     { "Intel H.264 inverse discrete cosine transform (IDCT), no FGT", &DXVADDI_Intel_ModeH264_C, 0 },
     { "Intel H.264 motion compensation (MoComp), no FGT",             &DXVADDI_Intel_ModeH264_A, 0 },
     { "Intel VC-1 VLD",                                               &DXVADDI_Intel_ModeVC1_E,  0 },
 
-    { "H.264 variable-length decoder (VLD), FGT",               &DXVA2_ModeH264_F, CODEC_ID_H264 },
-    { "H.264 VLD, no FGT",                                      &DXVA2_ModeH264_E, CODEC_ID_H264 },
+    { "H.264 variable-length decoder (VLD), FGT",               &DXVA2_ModeH264_F, AV_CODEC_ID_H264 },
+    { "H.264 VLD, no FGT",                                      &DXVA2_ModeH264_E, AV_CODEC_ID_H264 },
     { "H.264 IDCT, FGT",                                        &DXVA2_ModeH264_D, 0,            },
     { "H.264 inverse discrete cosine transform (IDCT), no FGT", &DXVA2_ModeH264_C, 0,            },
     { "H.264 MoComp, FGT",                                      &DXVA2_ModeH264_B, 0,            },
@@ -120,10 +120,10 @@
     { "Windows Media Video 9 MoComp",           &DXVA2_ModeWMV9_B, 0 },
     { "Windows Media Video 9 post processing",  &DXVA2_ModeWMV9_A, 0 },
 
-    { "VC-1 VLD",             &DXVA2_ModeVC1_D,    CODEC_ID_VC1 },
-    { "VC-1 VLD",             &DXVA2_ModeVC1_D,    CODEC_ID_WMV3 },
-    { "VC-1 VLD 2010",        &DXVA_ModeVC1_D2010, CODEC_ID_VC1 },
-    { "VC-1 VLD 2010",        &DXVA_ModeVC1_D2010, CODEC_ID_WMV3 },
+    { "VC-1 VLD",             &DXVA2_ModeVC1_D,    AV_CODEC_ID_VC1 },
+    { "VC-1 VLD",             &DXVA2_ModeVC1_D,    AV_CODEC_ID_WMV3 },
+    { "VC-1 VLD 2010",        &DXVA_ModeVC1_D2010, AV_CODEC_ID_VC1 },
+    { "VC-1 VLD 2010",        &DXVA_ModeVC1_D2010, AV_CODEC_ID_WMV3 },
     { "VC-1 IDCT",            &DXVA2_ModeVC1_C,    0 },
     { "VC-1 MoComp",          &DXVA2_ModeVC1_B,    0 },
     { "VC-1 post processing", &DXVA2_ModeVC1_A,    0 },
@@ -435,7 +435,7 @@
 static bool CheckCompatibility(AVCodecContext *avctx)
 {
   // The incompatibilities are all for H264
-  if(avctx->codec_id != CODEC_ID_H264)
+  if(avctx->codec_id != AV_CODEC_ID_H264)
     return true;
 
   // Macroblock width incompatibility
@@ -626,7 +626,7 @@
 
   if(m_refs == 0)
   {
-    if(avctx->codec_id == CODEC_ID_H264)
+    if(avctx->codec_id == AV_CODEC_ID_H264)
       m_refs = 16;
     else
       m_refs = 2;
@@ -771,9 +771,9 @@
   }
 
   // Status reports are available only for the DXVA2_ModeH264 and DXVA2_ModeVC1 modes
-  if(avctx->codec_id != CODEC_ID_H264
-  && avctx->codec_id != CODEC_ID_VC1
-  && avctx->codec_id != CODEC_ID_WMV3)
+  if(avctx->codec_id != AV_CODEC_ID_H264
+  && avctx->codec_id != AV_CODEC_ID_VC1
+  && avctx->codec_id != AV_CODEC_ID_WMV3)
     return 0;
 
   DXVA2_DecodeExecuteParams params = {};
@@ -786,7 +786,7 @@
   params.pExtensionData = &data;
   data.Function = DXVA_STATUS_REPORTING_FUNCTION;
   data.pPrivateOutputData    = &status;
-  data.PrivateOutputDataSize = avctx->codec_id == CODEC_ID_H264 ? sizeof(DXVA_Status_H264) : sizeof(DXVA_Status_VC1);
+  data.PrivateOutputDataSize = avctx->codec_id == AV_CODEC_ID_H264 ? sizeof(DXVA_Status_H264) : sizeof(DXVA_Status_VC1);
   HRESULT hr;
   if(FAILED( hr = m_decoder->Execute(&params)))
   {
@@ -794,7 +794,7 @@
     return VC_ERROR;
   }
 
-  if(avctx->codec_id == CODEC_ID_H264)
+  if(avctx->codec_id == AV_CODEC_ID_H264)
   {
     if(status.h264.bStatus)
       CLog::Log(LOGWARNING, "DXVA - decoder problem of status %d with %d", status.h264.bStatus, status.h264.bBufType);
@@ -939,7 +939,7 @@
 
   pic->reordered_opaque = avctx->reordered_opaque;
   pic->type = FF_BUFFER_TYPE_USER;
-  pic->age  = 256*256*256*64; // as everybody else, i've got no idea about this one
+  // pic->age  = 256*256*256*64;	// decrepated.
   for(unsigned i = 0; i < 4; i++)
   {
     pic->data[i] = NULL;
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp	2015-03-12 20:52:41.078096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp	2015-03-12 20:48:25.158096999 +0100
@@ -115,7 +115,7 @@
 
   switch (hints.codec)
   {
-    case CODEC_ID_H264:
+    case AV_CODEC_ID_H264:
     {
       switch(hints.profile)
       {
@@ -140,7 +140,7 @@
       }
     }
     break;
-    case CODEC_ID_MPEG4:
+    case AV_CODEC_ID_MPEG4:
       // (role name) video_decoder.mpeg4
       // MPEG-4, DivX 4/5 and Xvid compatible
       decoder_name = OMX_MPEG4_DECODER;
@@ -154,12 +154,12 @@
       m_pFormatName = "omx-mpeg4";
     break;
     */
-    case CODEC_ID_MPEG2VIDEO:
+    case AV_CODEC_ID_MPEG2VIDEO:
       // (role name) video_decoder.mpeg2
       // MPEG-2
       decoder_name = OMX_MPEG2V_DECODER;
     break;
-    case CODEC_ID_VC1:
+    case AV_CODEC_ID_VC1:
       // (role name) video_decoder.vc1
       // VC-1, WMV9
       decoder_name = OMX_VC1_DECODER;
@@ -271,7 +271,7 @@
   }
 }
 
-int COpenMaxVideo::Decode(BYTE* pData, int iSize, double dts, double pts)
+int COpenMaxVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
 {
   if (pData)
   {
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h	2015-03-12 20:52:41.078096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h	2015-03-12 20:48:25.158096999 +0100
@@ -46,7 +46,7 @@
   // Required overrides
   bool Open(CDVDStreamInfo &hints);
   void Close(void);
-  int  Decode(BYTE *pData, int iSize, double dts, double pts);
+  int  Decode(uint8_t *pData, int iSize, double dts, double pts);
   void Reset(void);
   bool GetPicture(DVDVideoPicture *pDvdVideoPicture);
   void SetDropState(bool bDrop);
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp	2015-03-12 20:52:41.078096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp	2015-03-12 20:48:25.158096999 +0100
@@ -268,14 +268,14 @@
 
   vector<VAProfile> accepted;
   switch (avctx->codec_id) {
-    case CODEC_ID_MPEG2VIDEO:
+    case AV_CODEC_ID_MPEG2VIDEO:
       accepted.push_back(VAProfileMPEG2Main);
       break;
-    case CODEC_ID_MPEG4:
-    case CODEC_ID_H263:
+    case AV_CODEC_ID_MPEG4:
+    case AV_CODEC_ID_H263:
       accepted.push_back(VAProfileMPEG4AdvancedSimple);
       break;
-    case CODEC_ID_H264:
+    case AV_CODEC_ID_H264:
     {
 #ifdef FF_PROFILE_H264_BASELINE
       if  (avctx->profile == FF_PROFILE_H264_BASELINE)
@@ -294,10 +294,10 @@
       }
       break;
     }
-    case CODEC_ID_WMV3:
+    case AV_CODEC_ID_WMV3:
       accepted.push_back(VAProfileVC1Main);
       break;
-    case CODEC_ID_VC1:
+    case AV_CODEC_ID_VC1:
       accepted.push_back(VAProfileVC1Advanced);
       break;
     default:
@@ -383,7 +383,7 @@
   m_refs = avctx->refs;
   if(m_refs == 0)
   {
-    if(avctx->codec_id == CODEC_ID_H264)
+    if(avctx->codec_id == AV_CODEC_ID_H264)
       m_refs = 16;
     else
       m_refs = 2;
diff -ur a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp	2015-03-12 20:48:25.158096999 +0100
@@ -162,6 +162,9 @@
     return false;
   }
 
+  if ((avctx->codec_id == AV_CODEC_ID_MPEG4) && !g_advancedSettings.m_videoAllowMpeg4VDPAU)
+    return false;
+
   if (!dl_handle)
   {
     dl_handle  = dlopen("libvdpau.so.1", RTLD_LAZY);
@@ -188,10 +191,10 @@
     SpewHardwareAvailable();
 
     VdpDecoderProfile profile = 0;
-    if(avctx->codec_id == CODEC_ID_H264)
+    if(avctx->codec_id == AV_CODEC_ID_H264)
       profile = VDP_DECODER_PROFILE_H264_HIGH;
 #ifdef VDP_DECODER_PROFILE_MPEG4_PART2_ASP
-    else if(avctx->codec_id == CODEC_ID_MPEG4)
+    else if(avctx->codec_id == AV_CODEC_ID_MPEG4)
       profile = VDP_DECODER_PROFILE_MPEG4_PART2_ASP;
 #endif
     if(profile)
diff -ur a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxBXA.cpp b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxBXA.cpp
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxBXA.cpp	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxBXA.cpp	2015-03-12 20:48:25.158096999 +0100
@@ -68,7 +68,7 @@
   if(!pInput || !pInput->IsStreamType(DVDSTREAM_TYPE_FILE))
     return false;
 
-  if(pInput->Read((BYTE *)&m_header, sizeof(Demux_BXA_FmtHeader)) < 1)
+  if(pInput->Read((uint8_t *)&m_header, sizeof(Demux_BXA_FmtHeader)) < 1)
     return false;
 
   // file valid?
@@ -90,7 +90,7 @@
   m_stream->iBitRate        = m_header.sampleRate * m_header.channels * m_header.bitsPerSample;
   m_stream->iChannels       = m_header.channels;
   m_stream->type            = STREAM_AUDIO;
-  m_stream->codec           = CODEC_ID_PCM_S16LE;
+  m_stream->codec           = AV_CODEC_ID_PCM_S16LE;
 
   return true;
 }
diff -ur a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemux.cpp b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemux.cpp
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemux.cpp	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemux.cpp	2015-03-12 20:48:25.158096999 +0100
@@ -31,8 +31,8 @@
 {
   char sInfo[64];
 
-  if (codec == CODEC_ID_AC3) strcpy(sInfo, "AC3 ");
-  else if (codec == CODEC_ID_DTS)
+  if (codec == AV_CODEC_ID_AC3) strcpy(sInfo, "AC3 ");
+  else if (codec == AV_CODEC_ID_DTS)
   {
 #ifdef FF_PROFILE_DTS_HD_MA
     if (profile == FF_PROFILE_DTS_HD_MA)
@@ -43,7 +43,8 @@
 #endif
       strcpy(sInfo, "DTS ");
   }
-  else if (codec == CODEC_ID_MP2) strcpy(sInfo, "MP2 ");
+  else if (codec == AV_CODEC_ID_MP2) strcpy(sInfo, "MP2 ");
+  else if (codec == AV_CODEC_ID_TRUEHD) strcpy(sInfo, "Dolby TrueHD ");
   else strcpy(sInfo, "");
 
   if (iChannels == 1) strcat(sInfo, "Mono");
diff -ur a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp	2015-03-12 20:48:25.158096999 +0100
@@ -52,6 +52,9 @@
 /* PLEX */
 #include "guilib/LocalizeStrings.h"
 #include "FileSystem/PlexFile.h"
+#include <boost/foreach.hpp>
+
+typedef std::pair<std::string, std::string> stringPair;
 /* END PLEX */
 
 void CDemuxStreamAudioFFmpeg::GetStreamInfo(std::string& strInfo)
@@ -98,6 +101,7 @@
 
 // these need to be put somewhere that are compiled, we should have some better place for it
 
+int DllAvFormat::m_avformat_refcnt = 0;
 CCriticalSection DllAvCodec::m_critSection;
 static CCriticalSection m_logSection;
 std::map<uintptr_t, CStdString> g_logbuffer;
@@ -188,7 +192,7 @@
   return pInputStream->Read(buf, size);
 }
 /*
-static int dvd_file_write(URLContext *h, BYTE* buf, int size)
+static int dvd_file_write(URLContext *h, uint8_t* buf, int size)
 {
   return -1;
 }
@@ -305,13 +309,13 @@
       {
         url.SetProtocol("mmst");
         strFile = url.Get();
-      } 
+      }
     }
     /* PLEX - We need to translate the plexserver:// URL here */
     else if (protocol == "plexserver")
     {
       url.SetProtocolOptions("");
-      
+
       XFILE::CPlexFile::BuildHTTPURL(url);
       strFile = url.Get();
     }
@@ -356,14 +360,16 @@
       if (trySPDIFonly || (iformat && strcmp(iformat->name, "wav") == 0))
       {
         AVProbeData pd;
-        BYTE probe_buffer[FFMPEG_FILE_BUFFER_SIZE + AVPROBE_PADDING_SIZE];
+        uint8_t probe_buffer[FFMPEG_FILE_BUFFER_SIZE + AVPROBE_PADDING_SIZE];
 
         // init probe data
         pd.buf = probe_buffer;
         pd.filename = strFile.c_str();
 
+        // av_probe_input_buffer might have changed the buffer_size beyond our allocated amount
+        int buffer_size = std::min((int) FFMPEG_FILE_BUFFER_SIZE, m_ioContext->buffer_size);
         // read data using avformat's buffers
-        pd.buf_size = m_dllAvFormat.avio_read(m_ioContext, pd.buf, m_ioContext->max_packet_size ? m_ioContext->max_packet_size : m_ioContext->buffer_size);
+        pd.buf_size = m_dllAvFormat.avio_read(m_ioContext, pd.buf, m_ioContext->max_packet_size ? m_ioContext->max_packet_size : buffer_size);
         if (pd.buf_size <= 0)
         {
           /* PLEX */
@@ -451,18 +457,28 @@
 
     m_pFormatContext->pb = m_ioContext;
 
+    AVDictionary *options = NULL;
+    if(strcmp(iformat->name, "mp3") == 0
+      || strcmp(iformat->name, "mp2") == 0 )
+    {
+      CLog::Log(LOGDEBUG, "%s - setting usetoc to 0 for accurate VBR MP3 seek", __FUNCTION__);
+      av_dict_set(&options, "usetoc", "0", 0);
+    }
+
     /* PLEX changed the seterror and friends */
     int res;
-    if ((res=m_dllAvFormat.avformat_open_input(&m_pFormatContext, strFile.c_str(), iformat, NULL) < 0))
+    if (res=avformat_open_input(&m_pFormatContext, strFile.c_str(), iformat, &options) < 0)
     {
       SetError(GetErrorString(res));
       CLog::Log(LOGERROR, "%s - Error, could not open file %s", __FUNCTION__, strFile.c_str());
       Dispose();
+      av_dict_free(&options);
       return false;
     }
     /* END PLEX */
+    av_dict_free(&options);
   }
-  
+
   // Avoid detecting framerate if advancedsettings.xml says so
   m_pFormatContext->fps_probe_size = (g_advancedSettings.m_videoFpsDetect == 0) ? 0 : -1;
 
@@ -486,7 +502,9 @@
     if (iErr < 0)
     {
       CLog::Log(LOGWARNING,"could not find codec parameters for %s", strFile.c_str());
-      if (m_pInput->IsStreamType(DVDSTREAM_TYPE_DVD) || (m_pFormatContext->nb_streams == 1 && m_pFormatContext->streams[0]->codec->codec_id == CODEC_ID_AC3))
+      if (m_pInput->IsStreamType(DVDSTREAM_TYPE_DVD)
+      ||  m_pInput->IsStreamType(DVDSTREAM_TYPE_BLURAY)
+      || (m_pFormatContext->nb_streams == 1 && m_pFormatContext->streams[0]->codec->codec_id == AV_CODEC_ID_AC3))
       {
         // special case, our codecs can still handle it.
       }
@@ -640,12 +658,22 @@
 
   AVDictionary *options = NULL;
 
-  if (protocol.Equals("http") || protocol.Equals("https"))
+  if (protocol.Equals("http") || protocol.Equals("https") || protocol.Equals("plexserver"))
   {
     std::map<CStdString, CStdString> protocolOptions;
     url.GetProtocolOptions(protocolOptions);
     std::string headers;
     bool hasUserAgent = false;
+
+    /* PLEX */
+    if (protocol.Equals("plexserver"))
+    {
+      std::vector<stringPair> hdrs = XFILE::CPlexFile::GetHeaderList();
+      BOOST_FOREACH(stringPair sp, hdrs)
+        headers.append(sp.first).append(": ").append(sp.second).append("\r\n");
+    }
+    /* END PLEX */
+
     for(std::map<CStdString, CStdString>::const_iterator it = protocolOptions.begin(); it != protocolOptions.end(); ++it)
     {
       const CStdString &name = it->first;
@@ -690,7 +718,8 @@
 
   if(timestamp > starttime)
     timestamp -= starttime;
-  else if( timestamp + 0.1f > starttime )
+  // allow for largest possible difference in pts and dts for a single packet
+  else if( timestamp + 0.5f > starttime )
     timestamp = 0;
 
   return timestamp*DVD_TIME_BASE;
@@ -789,7 +818,7 @@
         }
 
         // we need to get duration slightly different for matroska embedded text subtitels
-        if(m_bMatroska && stream->codec->codec_id == CODEC_ID_TEXT && pkt.convergence_duration != 0)
+        if(m_bMatroska && stream->codec->codec_id == AV_CODEC_ID_TEXT && pkt.convergence_duration != 0)
           pkt.duration = pkt.convergence_duration;
 
         if(m_bAVI && stream->codec && stream->codec->codec_type == AVMEDIA_TYPE_VIDEO)
@@ -915,6 +944,18 @@
     CSingleLock lock(m_critSection);
     ret = m_dllAvFormat.av_seek_frame(m_pFormatContext, -1, seek_pts, backwords ? AVSEEK_FLAG_BACKWARD : 0);
 
+    // demuxer will return failure, if you seek behind eof
+    if (ret < 0 && m_pFormatContext->duration && seek_pts >= (m_pFormatContext->duration + m_pFormatContext->start_time))
+      ret = 0;
+    else if (ret < 0 && m_pInput->IsEOF())
+      ret = 0;
+
+    // demuxer will return failure, if you seek behind eof
+    if (ret < 0 && m_pFormatContext->duration && seek_pts >= (m_pFormatContext->duration + m_pFormatContext->start_time))
+      ret = 0;
+    else if (ret < 0 && m_pInput->IsEOF())
+      ret = 0;
+
     if(ret >= 0)
       UpdateCurrentPTS();
   }
@@ -928,10 +969,6 @@
   if(startpts)
     *startpts = DVD_MSEC_TO_TIME(time);
 
-  // demuxer will return failure, if you seek to eof
-  if (m_pInput->IsEOF() && ret <= 0)
-    return true;
-
   return (ret >= 0);
 }
 
@@ -949,9 +986,11 @@
 void CDVDDemuxFFmpeg::UpdateCurrentPTS()
 {
   m_iCurrentPts = DVD_NOPTS_VALUE;
-  for(unsigned int i = 0; i < m_pFormatContext->nb_streams; i++)
+
+  int idx = av_find_default_stream_index(m_pFormatContext);
+  if (idx >= 0)
   {
-    AVStream *stream = m_pFormatContext->streams[i];
+    AVStream *stream = m_pFormatContext->streams[idx];
     if(stream && stream->cur_dts != (int64_t)AV_NOPTS_VALUE)
     {
       double ts = ConvertTimestamp(stream->cur_dts, stream->time_base.den, stream->time_base.num);
@@ -1024,8 +1063,10 @@
         st->iSampleRate = pStream->codec->sample_rate;
         st->iBlockAlign = pStream->codec->block_align;
         st->iBitRate = pStream->codec->bit_rate;
-        st->iBitsPerSample = pStream->codec->bits_per_coded_sample;
-	
+        st->iBitsPerSample = pStream->codec->bits_per_raw_sample;
+        if (st->iBitsPerSample == 0)
+          st->iBitsPerSample = pStream->codec->bits_per_coded_sample;
+
         if(m_dllAvUtil.av_dict_get(pStream->metadata, "title", NULL, 0))
           st->m_description = m_dllAvUtil.av_dict_get(pStream->metadata, "title", NULL, 0)->value;
 
@@ -1041,7 +1082,7 @@
           st->bVFR = false;
 
         // never trust pts in avi files with h264.
-        if (m_bAVI && pStream->codec->codec_id == CODEC_ID_H264)
+        if (m_bAVI && pStream->codec->codec_id == AV_CODEC_ID_H264)
           st->bPTSInvalid = true;
 
         //average fps is more accurate for mkv files
@@ -1083,20 +1124,20 @@
         /* END PLEX */
 
         AVDictionaryEntry *rtag = m_dllAvUtil.av_dict_get(pStream->metadata, "rotate", NULL, 0);
-        if (rtag) 
-          st->iOrientation = atoi(rtag->value); 
-        
+        if (rtag)
+          st->iOrientation = atoi(rtag->value);
+
         if ( m_pInput->IsStreamType(DVDSTREAM_TYPE_DVD) )
         {
-          if (pStream->codec->codec_id == CODEC_ID_PROBE)
+          if (pStream->codec->codec_id == AV_CODEC_ID_PROBE)
           {
-            // fix MPEG-1/MPEG-2 video stream probe returning CODEC_ID_PROBE for still frames.
+            // fix MPEG-1/MPEG-2 video stream probe returning AV_CODEC_ID_PROBE for still frames.
             // ffmpeg issue 1871, regression from ffmpeg r22831.
             if ((pStream->id & 0xF0) == 0xE0)
             {
-              pStream->codec->codec_id = CODEC_ID_MPEG2VIDEO;
+              pStream->codec->codec_id = AV_CODEC_ID_MPEG2VIDEO;
               pStream->codec->codec_tag = MKTAG('M','P','2','V');
-              CLog::Log(LOGERROR, "%s - CODEC_ID_PROBE detected, forcing CODEC_ID_MPEG2VIDEO", __FUNCTION__);
+              CLog::Log(LOGERROR, "%s - AV_CODEC_ID_PROBE detected, forcing AV_CODEC_ID_MPEG2VIDEO", __FUNCTION__);
             }
           }
         }
@@ -1110,8 +1151,7 @@
       }
     case AVMEDIA_TYPE_SUBTITLE:
       {
-#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(52,38,1)
-        if (pStream->codec->codec_id == CODEC_ID_DVB_TELETEXT && g_guiSettings.GetBool("videoplayer.teletextenabled"))
+        if (pStream->codec->codec_id == AV_CODEC_ID_DVB_TELETEXT && g_guiSettings.GetBool("videoplayer.teletextenabled"))
         {
           CDemuxStreamTeletext* st = new CDemuxStreamTeletext();
           m_streams[iId] = st;
@@ -1119,23 +1159,21 @@
           break;
         }
         else
-#endif
         {
           CDemuxStreamSubtitleFFmpeg* st = new CDemuxStreamSubtitleFFmpeg(this, pStream);
           m_streams[iId] = st;
-          st->identifier = pStream->codec->sub_id;
-	    
+
           if(m_dllAvUtil.av_dict_get(pStream->metadata, "title", NULL, 0))
             st->m_description = m_dllAvUtil.av_dict_get(pStream->metadata, "title", NULL, 0)->value;
-	
+
           break;
         }
       }
     case AVMEDIA_TYPE_ATTACHMENT:
       { //mkv attachments. Only bothering with fonts for now.
-        if(pStream->codec->codec_id == CODEC_ID_TTF
+        if(pStream->codec->codec_id == AV_CODEC_ID_TTF
 #if (!defined USE_EXTERNAL_FFMPEG)
-          || pStream->codec->codec_id == CODEC_ID_OTF
+          || pStream->codec->codec_id == AV_CODEC_ID_OTF
 #endif
           )
         {
@@ -1202,7 +1240,7 @@
     if( pStream->codec->extradata && pStream->codec->extradata_size > 0 )
     {
       m_streams[iId]->ExtraSize = pStream->codec->extradata_size;
-      m_streams[iId]->ExtraData = new BYTE[pStream->codec->extradata_size];
+      m_streams[iId]->ExtraData = new uint8_t[pStream->codec->extradata_size];
       memcpy(m_streams[iId]->ExtraData, pStream->codec->extradata, pStream->codec->extradata_size);
     }
 
@@ -1217,19 +1255,19 @@
       // id's reported from libdvdnav
       switch(m_streams[iId]->codec)
       {
-        case CODEC_ID_AC3:
+        case AV_CODEC_ID_AC3:
           m_streams[iId]->iPhysicalId = pStream->id - 128;
           break;
-        case CODEC_ID_DTS:
+        case AV_CODEC_ID_DTS:
           m_streams[iId]->iPhysicalId = pStream->id - 136;
           break;
-        case CODEC_ID_MP2:
+        case AV_CODEC_ID_MP2:
           m_streams[iId]->iPhysicalId = pStream->id - 448;
           break;
-        case CODEC_ID_PCM_S16BE:
+        case AV_CODEC_ID_PCM_S16BE:
           m_streams[iId]->iPhysicalId = pStream->id - 160;
           break;
-        case CODEC_ID_DVD_SUBTITLE:
+        case AV_CODEC_ID_DVD_SUBTITLE:
           m_streams[iId]->iPhysicalId = pStream->id - 0x20;
           break;
         default:
@@ -1380,7 +1418,7 @@
 
 #ifdef FF_PROFILE_DTS_HD_MA
     /* use profile to determine the DTS type */
-    if (stream->codec == CODEC_ID_DTS)
+    if (stream->codec == AV_CODEC_ID_DTS)
     {
       if (stream->profile == FF_PROFILE_DTS_HD_MA)
         strName = "dtshd_ma";
diff -ur a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemux.h b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemux.h
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemux.h	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemux.h	2015-03-12 20:48:25.158096999 +0100
@@ -35,7 +35,7 @@
   #include "config.h"
 #endif
 #ifndef _LINUX
-enum CodecID;
+// enum CodecID; // auto defined when neccesary
 #include <libavcodec/avcodec.h>
 #else
 extern "C" {
@@ -88,7 +88,7 @@
   {
     iId = 0;
     iPhysicalId = 0;
-    codec = (CodecID)0; // CODEC_ID_NONE
+    codec = (AVCodecID)0; // AV_CODEC_ID_NONE
     codec_fourcc = 0;
     profile = FF_PROFILE_UNKNOWN;
     level = 0;
@@ -123,7 +123,7 @@
 
   int iId;         // most of the time starting from 0
   int iPhysicalId; // id
-  CodecID codec;
+  AVCodecID codec;
   unsigned int codec_fourcc; // if available
   int profile; // encoder profile of the stream reported by the decoder. used to qualify hw decoders.
   int level;   // encoder level of the stream reported by the decoder. used to qualify hw decoders.
@@ -220,11 +220,8 @@
 public:
   CDemuxStreamSubtitle() : CDemuxStream()
   {
-    identifier = 0;
     type = STREAM_SUBTITLE;
   }
-
-  int identifier;
 };
 
 class CDemuxStreamTeletext : public CDemuxStream
diff -ur a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxHTSP.cpp b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxHTSP.cpp
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxHTSP.cpp	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxHTSP.cpp	2015-03-12 20:48:25.158096999 +0100
@@ -290,39 +290,45 @@
 
     if(!strcmp(type, "AC3")) {
       st.a = new CDemuxStreamAudioHTSP(this, type);
-      st.a->codec = CODEC_ID_AC3;
+      st.a->codec = AV_CODEC_ID_AC3;
     } else if(!strcmp(type, "EAC3")) {
       st.a = new CDemuxStreamAudioHTSP(this, type);
-      st.a->codec = CODEC_ID_EAC3;
+      st.a->codec = AV_CODEC_ID_EAC3;
     } else if(!strcmp(type, "MPEG2AUDIO")) {
       st.a = new CDemuxStreamAudioHTSP(this, type);
-      st.a->codec = CODEC_ID_MP2;
+      st.a->codec = AV_CODEC_ID_MP2;
     } else if(!strcmp(type, "AAC")) {
       st.a = new CDemuxStreamAudioHTSP(this, type);
-      st.a->codec = CODEC_ID_AAC;
+      st.a->codec = AV_CODEC_ID_AAC;
     } else if(!strcmp(type, "MPEG2VIDEO")) {
       st.v = new CDemuxStreamVideoHTSP(this, type);
-      st.v->codec = CODEC_ID_MPEG2VIDEO;
+      st.v->codec = AV_CODEC_ID_MPEG2VIDEO;
       st.v->iWidth  = htsmsg_get_u32_or_default(sub, "width" , 0);
       st.v->iHeight = htsmsg_get_u32_or_default(sub, "height", 0);
     } else if(!strcmp(type, "H264")) {
       st.v = new CDemuxStreamVideoHTSP(this, type);
-      st.v->codec = CODEC_ID_H264;
+      st.v->codec = AV_CODEC_ID_H264;
       st.v->iWidth  = htsmsg_get_u32_or_default(sub, "width" , 0);
       st.v->iHeight = htsmsg_get_u32_or_default(sub, "height", 0);
     } else if(!strcmp(type, "DVBSUB")) {
       st.s = new CDemuxStreamSubtitle();
-      st.s->codec = CODEC_ID_DVB_SUBTITLE;
+      st.s->codec = AV_CODEC_ID_DVB_SUBTITLE;
       uint32_t composition_id = 0, ancillary_id = 0;
       htsmsg_get_u32(sub, "composition_id", &composition_id);
       htsmsg_get_u32(sub, "ancillary_id"  , &ancillary_id);
-      st.s->identifier = (composition_id & 0xffff) | ((ancillary_id & 0xffff) << 16);
+      if(composition_id || ancillary_id)
+      {
+        st.s->ExtraData = new uint8_t[4];
+        st.s->ExtraSize = 4;
+        ((uint16_t*)st.s->ExtraData)[0] = composition_id;
+        ((uint16_t*)st.s->ExtraData)[1] = ancillary_id;
+      }
     } else if(!strcmp(type, "TEXTSUB")) {
       st.s = new CDemuxStreamSubtitle();
-      st.s->codec = CODEC_ID_TEXT;
+      st.s->codec = AV_CODEC_ID_TEXT;
     } else if(!strcmp(type, "TELETEXT")) {
       st.t = new CDemuxStreamTeletext();
-      st.t->codec = CODEC_ID_DVB_TELETEXT;
+      st.t->codec = AV_CODEC_ID_DVB_TELETEXT;
     } else {
       continue;
     }
diff -ur a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.cpp b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.cpp
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.cpp	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.cpp	2015-03-12 20:48:25.158096999 +0100
@@ -60,10 +60,10 @@
 {
   switch (codec)
   {
-    case CODEC_ID_MPEG2VIDEO:
+    case AV_CODEC_ID_MPEG2VIDEO:
       strInfo = "mpeg2video";
       break;
-    case CODEC_ID_H264:
+    case AV_CODEC_ID_H264:
       strInfo = "h264";
       break;
     default:
@@ -75,19 +75,19 @@
 {
   switch (codec)
   {
-    case CODEC_ID_AC3:
+    case AV_CODEC_ID_AC3:
       strInfo = "ac3";
       break;
-    case CODEC_ID_EAC3:
+    case AV_CODEC_ID_EAC3:
       strInfo = "eac3";
       break;
-    case CODEC_ID_MP2:
+    case AV_CODEC_ID_MP2:
       strInfo = "mpeg2audio";
       break;
-    case CODEC_ID_AAC:
+    case AV_CODEC_ID_AAC:
       strInfo = "aac";
       break;
-    case CODEC_ID_DTS:
+    case AV_CODEC_ID_DTS:
       strInfo = "dts";
       break;
     default:
@@ -349,7 +349,7 @@
       {
         st = dynamic_cast<CDemuxStreamAudioPVRClient*>(stm);
         if (!st
-            || (st->codec != (CodecID)props.stream[i].iCodecId)
+            || (st->codec != (AVCodecID)props.stream[i].iCodecId)
             || (st->iChannels != props.stream[i].iChannels))
           DisposeStream(i);
       }
@@ -375,7 +375,7 @@
       {
         st = dynamic_cast<CDemuxStreamVideoPVRClient*>(stm);
         if (!st
-            || (st->codec != (CodecID)props.stream[i].iCodecId)
+            || (st->codec != (AVCodecID)props.stream[i].iCodecId)
             || (st->iWidth != props.stream[i].iWidth)
             || (st->iHeight != props.stream[i].iHeight))
           DisposeStream(i);
@@ -395,11 +395,11 @@
       m_streams[i] = st;
       st->m_parser_split = true;
     }
-    else if (props.stream[i].iCodecId == CODEC_ID_DVB_TELETEXT)
+    else if (props.stream[i].iCodecId == AV_CODEC_ID_DVB_TELETEXT)
     {
       if (stm)
       {
-        if (stm->codec != (CodecID)props.stream[i].iCodecId)
+        if (stm->codec != (AVCodecID)props.stream[i].iCodecId)
           DisposeStream(i);
       }
       if (!m_streams[i])
@@ -411,14 +411,20 @@
       if (stm)
       {
         st = dynamic_cast<CDemuxStreamSubtitlePVRClient*>(stm);
-        if (!st || (st->codec != (CodecID)props.stream[i].iCodecId))
+        if (!st || (st->codec != (AVCodecID)props.stream[i].iCodecId))
           DisposeStream(i);
       }
       if (!m_streams[i])
       {
         st = new CDemuxStreamSubtitlePVRClient(this);
       }
-      st->identifier = props.stream[i].iIdentifier;
+      if(props.stream[i].iIdentifier)
+      {
+        st->ExtraData = new uint8_t[4];
+        st->ExtraSize = 4;
+        ((uint16_t*)st->ExtraData)[0] = (props.stream[i].iIdentifier >> 0) & 0xFFFFu;
+        ((uint16_t*)st->ExtraData)[1] = (props.stream[i].iIdentifier >> 4) & 0xFFFFu;
+      }
       m_streams[i] = st;
     }
     else
@@ -428,7 +434,7 @@
       m_streams[i] = new CDemuxStream();
     }
 
-    m_streams[i]->codec       = (CodecID)props.stream[i].iCodecId;
+    m_streams[i]->codec       = (AVCodecID)props.stream[i].iCodecId;
     m_streams[i]->iId         = i;
     m_streams[i]->iPhysicalId = props.stream[i].iPhysicalId;
     m_streams[i]->language[0] = props.stream[i].strLanguage[0];
@@ -475,19 +481,19 @@
   CDemuxStream *stream = GetStream(iStreamId);
   if (stream)
   {
-    if (stream->codec == CODEC_ID_AC3)
+    if (stream->codec == AV_CODEC_ID_AC3)
       strName = "ac3";
-    else if (stream->codec == CODEC_ID_MP2)
+    else if (stream->codec == AV_CODEC_ID_MP2)
       strName = "mp2";
-    else if (stream->codec == CODEC_ID_AAC)
+    else if (stream->codec == AV_CODEC_ID_AAC)
       strName = "aac";
-    else if (stream->codec == CODEC_ID_DTS)
+    else if (stream->codec == AV_CODEC_ID_DTS)
       strName = "dca";
-    else if (stream->codec == CODEC_ID_MPEG2VIDEO)
+    else if (stream->codec == AV_CODEC_ID_MPEG2VIDEO)
       strName = "mpeg2video";
-    else if (stream->codec == CODEC_ID_H264)
+    else if (stream->codec == AV_CODEC_ID_H264)
       strName = "h264";
-    else if (stream->codec == CODEC_ID_EAC3)
+    else if (stream->codec == AV_CODEC_ID_EAC3)
       strName = "eac3";
   }
 }
diff -ur a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxShoutcast.cpp b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxShoutcast.cpp
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxShoutcast.cpp	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxShoutcast.cpp	2015-03-12 20:48:25.158096999 +0100
@@ -86,12 +86,12 @@
       stricmp(strMimeType.c_str(), CONTENT_TYPE_AACPLUS) == 0)
   {
     // need an aac decoder first
-    m_pDemuxStream->codec = CODEC_ID_AAC;
+    m_pDemuxStream->codec = AV_CODEC_ID_AAC;
   }
   else // (stricmp(strMimeType, CONTENT_TYPE_MP3) == 0)
   {
     // default to mp3
-    m_pDemuxStream->codec = CODEC_ID_MP3;
+    m_pDemuxStream->codec = AV_CODEC_ID_MP3;
   }
 
   return true;
@@ -151,8 +151,8 @@
   {
     // we already have read m_iMetaStreamInterval bytes of streaming data
     // metadata follows
-    BYTE l;
-    iRead = m_pInput->Read(&l, 1);
+    uint8_t l;
+    int iRead = m_pInput->Read(&l, 1);
     if (iRead > 0)
     {
       int iMetaLength = l * 16;
@@ -160,7 +160,7 @@
       if (iMetaLength > 0)
       {
         // iMetaLength cannot be larger then 16 * 255
-        BYTE buffer[16 * 255];
+        uint8_t buffer[16 * 255];
 
         // skip meta data for now
         m_pInput->Read(buffer, iMetaLength);
diff -ur a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.cpp b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.cpp
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.cpp	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.cpp	2015-03-12 20:48:25.158096999 +0100
@@ -70,7 +70,7 @@
         * Note, if the first 23 bits of the additional bytes are not 0 then damaged
         * MPEG bitstreams could cause overread and segfault
         */
-      pPacket->pData =(BYTE*)_aligned_malloc(iDataSize + FF_INPUT_BUFFER_PADDING_SIZE, 16);
+      pPacket->pData =(uint8_t*)_aligned_malloc(iDataSize + FF_INPUT_BUFFER_PADDING_SIZE, 16);
       if (!pPacket->pData)
       {
         FreeDemuxPacket(pPacket);
diff -ur a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxVobsub.cpp b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxVobsub.cpp
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxVobsub.cpp	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxVobsub.cpp	2015-03-12 20:48:25.158096999 +0100
@@ -71,7 +71,7 @@
 
   CDVDStreamInfo hints;
   CDVDCodecOptions options;
-  hints.codec = CODEC_ID_DVD_SUBTITLE;
+  hints.codec = AV_CODEC_ID_DVD_SUBTITLE;
 
   char line[2048];
   DECLARE_UNUSED(bool,res)
@@ -211,7 +211,7 @@
   else
     stream->iPhysicalId = -1;
 
-  stream->codec = CODEC_ID_DVD_SUBTITLE;
+  stream->codec = AV_CODEC_ID_DVD_SUBTITLE;
   stream->iId = m_Streams.size();
 
   state.id = stream->iId;
diff -ur a/xbmc/cores/dvdplayer/DVDDemuxSPU.cpp b/xbmc/cores/dvdplayer/DVDDemuxSPU.cpp
--- a/xbmc/cores/dvdplayer/DVDDemuxSPU.cpp	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDDemuxSPU.cpp	2015-03-12 20:48:25.158096999 +0100
@@ -71,7 +71,7 @@
   memset(&m_spuData, 0, sizeof(m_spuData));
 }
 
-CDVDOverlaySpu* CDVDDemuxSPU::AddData(BYTE* data, int iSize, double pts)
+CDVDOverlaySpu* CDVDDemuxSPU::AddData(uint8_t* data, int iSize, double pts)
 {
   SPUData* pSPUData = &m_spuData;
 
@@ -110,7 +110,7 @@
   // allocate data if not already done ( done in blocks off 16384 bytes )
   // or allocate some more if 16384 bytes is not enough
   if((pSPUData->iSize + iSize) > pSPUData->iAllocatedSize)
-    pSPUData->data = (BYTE*)realloc(pSPUData->data, ALIGN(pSPUData->iSize + iSize, 0x4000));
+    pSPUData->data = (uint8_t*)realloc(pSPUData->data, ALIGN(pSPUData->iSize + iSize, 0x4000));
 
   if(!pSPUData->data)
     return NULL; // crap realloc failed, this will have leaked some memory due to odd realloc
@@ -150,7 +150,7 @@
 CDVDOverlaySpu* CDVDDemuxSPU::ParsePacket(SPUData* pSPUData)
 {
   unsigned int alpha[4];
-  BYTE* pUnparsedData = NULL;
+  uint8_t* pUnparsedData = NULL;
 
   if (pSPUData->iNeededSize != pSPUData->iSize)
   {
@@ -163,7 +163,7 @@
   }
 
   CDVDOverlaySpu* pSPUInfo = new CDVDOverlaySpu();
-  BYTE* p = pSPUData->data; // pointer to walk through all data
+  uint8_t* p = pSPUData->data; // pointer to walk through all data
 
   // get data length
   unsigned __int16 datalength = p[2] << 8 | p[3]; // datalength + 4 control bytes
@@ -235,7 +235,7 @@
 
             for (int i = 0; i < 4 ; i++) // emphasis 1, emphasis 2, pattern, back ground
             {
-              BYTE* iColor = m_clut[idx[i]];
+              uint8_t* iColor = m_clut[idx[i]];
 
               pSPUInfo->color[3 - i][0] = iColor[0]; // Y
               pSPUInfo->color[3 - i][1] = iColor[1]; // Cr
@@ -327,7 +327,7 @@
 /*****************************************************************************
  * AddNibble: read a nibble from a source packet and add it to our integer.
  *****************************************************************************/
-inline unsigned int AddNibble( unsigned int i_code, BYTE* p_src, unsigned int* pi_index )
+inline unsigned int AddNibble( unsigned int i_code, uint8_t* p_src, unsigned int* pi_index )
 {
   if ( *pi_index & 0x1 )
   {
@@ -346,9 +346,9 @@
  * convenient structure for later decoding. For more information on the
  * subtitles format, see http://sam.zoy.org/doc/dvd/subtitles/index.html
  *****************************************************************************/
-CDVDOverlaySpu* CDVDDemuxSPU::ParseRLE(CDVDOverlaySpu* pSPU, BYTE* pUnparsedData)
+CDVDOverlaySpu* CDVDDemuxSPU::ParseRLE(CDVDOverlaySpu* pSPU, uint8_t* pUnparsedData)
 {
-  BYTE* p_src = pUnparsedData;
+  uint8_t* p_src = pUnparsedData;
 
   unsigned int i_code = 0;
 
@@ -431,9 +431,9 @@
       /* Check we aren't overwriting our data range
          This occurs on "The Triplets of BelleVille" region 4 disk (NTSC)"
          where we use around 96k rather than 64k + 20bytes */
-      if ((BYTE *)p_dest >= pSPU->result + sizeof(pSPU->result))
+      if ((uint8_t *)p_dest >= pSPU->result + sizeof(pSPU->result))
       {
-        CLog::Log(LOGERROR, "ParseRLE: Overrunning our data range.  Need %li bytes", (long)((BYTE *)p_dest - pSPU->result));
+        CLog::Log(LOGERROR, "ParseRLE: Overrunning our data range.  Need %li bytes", (long)((uint8_t *)p_dest - pSPU->result));
         return NULL;
       }
       *p_dest++ = i_code;
@@ -468,9 +468,9 @@
       /* Check we aren't overwriting our data range
          This occurs on "The Triplets of BelleVille" region 4 disk (NTSC)"
          where we use around 96k rather than 64k + 20bytes */
-      if ((BYTE *)p_dest >= pSPU->result + sizeof(pSPU->result))
+      if ((uint8_t *)p_dest >= pSPU->result + sizeof(pSPU->result))
       {
-        CLog::Log(LOGERROR, "ParseRLE: Overrunning our data range.  Need %li bytes", (long)((BYTE *)p_dest - pSPU->result));
+        CLog::Log(LOGERROR, "ParseRLE: Overrunning our data range.  Need %li bytes", (long)((uint8_t *)p_dest - pSPU->result));
         return NULL;
       }
       *p_dest++ = i_width << 2;
@@ -534,19 +534,19 @@
   const int COLOR_SHADE = 1;
   const int COLOR_BORDER = 2;
 
-  //BYTE custom_subtitle_color[4][3] = { // blue, yellow and something else (xine)
+  //uint8_t custom_subtitle_color[4][3] = { // blue, yellow and something else (xine)
   //  { 0x80, 0x90, 0x80 }, // inner color
   //  { 0x00, 0x90, 0x00 }, // shade color
   //  { 0x00, 0x90, 0xff }  // border color
   //};
 
-  BYTE custom_subtitle_color[4][3] = { // inner color white, gray shading and a black border
+  uint8_t custom_subtitle_color[4][3] = { // inner color white, gray shading and a black border
     { 0xff, 0x80, 0x80 }, // inner color, white
     { 0x80, 0x80, 0x80 }, // shade color, gray
     { 0x00, 0x80, 0x80 }  // border color, black
   };
 
-  //BYTE custom_subtitle_color[4][3] = { // completely white and a black border
+  //uint8_t custom_subtitle_color[4][3] = { // completely white and a black border
   //  { 0xff, 0x80, 0x80 }, // inner color, white
   //  { 0xff, 0x80, 0x80 }, // shade color, white
   //  { 0x00, 0x80, 0x80 }  // border color, black
diff -ur a/xbmc/cores/dvdplayer/DVDDemuxSPU.h b/xbmc/cores/dvdplayer/DVDDemuxSPU.h
--- a/xbmc/cores/dvdplayer/DVDDemuxSPU.h	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDDemuxSPU.h	2015-03-12 20:48:25.158096999 +0100
@@ -26,7 +26,7 @@
 
 typedef struct SPUData
 {
-  BYTE* data;
+  uint8_t* data;
   unsigned int iSize; // current data size
   unsigned int iNeededSize; // wanted packet size
   unsigned int iAllocatedSize;
@@ -43,11 +43,11 @@
   CDVDDemuxSPU();
   virtual ~CDVDDemuxSPU();
 
-  CDVDOverlaySpu* AddData(BYTE* data, int iSize, double pts); // returns a packet from ParsePacket if possible
+  CDVDOverlaySpu* AddData(uint8_t* data, int iSize, double pts); // returns a packet from ParsePacket if possible
 
-  CDVDOverlaySpu* ParseRLE(CDVDOverlaySpu* pSPU, BYTE* pUnparsedData);
-  void FindSubtitleColor(int last_color, int stats[4], CDVDOverlaySpu* pSPU);
-  bool CanDisplayWithAlphas(int a[4], int stats[4]);
+  CDVDOverlaySpu* ParseRLE(CDVDOverlaySpu* pSPU, uint8_t* pUnparsedData);
+  static void FindSubtitleColor(int last_color, int stats[4], CDVDOverlaySpu* pSPU);
+  static bool CanDisplayWithAlphas(int a[4], int stats[4]);
 
   void Reset();
   void FlushCurrentPacket(); // flushes current unparsed data
@@ -55,7 +55,7 @@
   // m_clut set by libdvdnav once in a time
   // color lokup table is representing 16 different yuv colors
   // [][0] = Y, [][1] = Cr, [][2] = Cb
-  BYTE m_clut[16][3];
+  uint8_t m_clut[16][3];
   bool m_bHasClut;
 
 protected:
diff -ur a/xbmc/cores/dvdplayer/DVDFileInfo.cpp b/xbmc/cores/dvdplayer/DVDFileInfo.cpp
--- a/xbmc/cores/dvdplayer/DVDFileInfo.cpp	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDFileInfo.cpp	2015-03-12 20:48:25.158096999 +0100
@@ -171,7 +171,7 @@
     CDVDStreamInfo hint(*pDemuxer->GetStream(nVideoStream), true);
     hint.software = true;
 
-    if (hint.codec == CODEC_ID_MPEG2VIDEO || hint.codec == CODEC_ID_MPEG1VIDEO)
+    if (hint.codec == AV_CODEC_ID_MPEG2VIDEO || hint.codec == AV_CODEC_ID_MPEG1VIDEO)
     {
       // libmpeg2 is not thread safe so use ffmepg for mpeg2/mpeg1 thumb extraction
       CDVDCodecOptions dvdOptions;
@@ -242,7 +242,7 @@
             DllSwScale dllSwScale;
             dllSwScale.Load();
 
-            BYTE *pOutBuf = new BYTE[nWidth * nHeight * 4];
+            uint8_t *pOutBuf = new uint8_t[nWidth * nHeight * 4];
             struct SwsContext *context = dllSwScale.sws_getContext(picture.iWidth, picture.iHeight,
                   PIX_FMT_YUV420P, nWidth, nHeight, PIX_FMT_BGRA, SWS_FAST_BILINEAR | SwScaleCPUFlags(), NULL, NULL, NULL);
             uint8_t *src[] = { picture.data[0], picture.data[1], picture.data[2], 0 };
diff -ur a/xbmc/cores/dvdplayer/DVDInputStreams/DVDFactoryInputStream.cpp b/xbmc/cores/dvdplayer/DVDInputStreams/DVDFactoryInputStream.cpp
--- a/xbmc/cores/dvdplayer/DVDInputStreams/DVDFactoryInputStream.cpp	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDInputStreams/DVDFactoryInputStream.cpp	2015-03-12 20:48:09.958096999 +0100
@@ -153,7 +153,6 @@
 #endif
 
   // our file interface handles all these types of streams
-  #ifdef TARGET_RASPBERRY_PI
   /* PLEX */
   if ((file.substr(0, 13) == "plexserver://") && (g_guiSettings.GetBool("videoplayer.useffmpegavio")))
   {
@@ -169,7 +168,6 @@
   }
   else
   /* END PLEX */
-  #endif
     return (new CDVDInputStreamFile());
 
 }
diff -ur a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamBluray.cpp b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamBluray.cpp
--- a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamBluray.cpp	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamBluray.cpp	2015-03-12 20:48:25.158096999 +0100
@@ -44,7 +44,7 @@
   if (file)
   {
     CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - Closed file (%p)\n", file);
-    
+
     delete static_cast<CFile*>(file->internal);
     delete file;
   }
@@ -432,7 +432,151 @@
   m_title = NULL;
 }
 
-int CDVDInputStreamBluray::Read(BYTE* buf, int buf_size)
+void CDVDInputStreamBluray::ProcessEvent() {
+
+  int pid = -1;
+  switch (m_event.event) {
+
+  case BD_EVENT_ERROR:
+    CLog::Log(LOGERROR, "CDVDInputStreamBluray - BD_EVENT_ERROR");
+    break;
+
+  case BD_EVENT_ENCRYPTED:
+    CLog::Log(LOGERROR, "CDVDInputStreamBluray - BD_EVENT_ENCRYPTED");
+    break;
+
+  /* playback control */
+
+  case BD_EVENT_SEEK:
+    CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_SEEK");
+    //m_player->OnDVDNavResult(NULL, 1);
+    //m_dll->bd_read_skip_still(m_bd);
+    //m_hold = HOLD_HELD;
+    break;
+
+  case BD_EVENT_STILL_TIME:
+    CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_STILL_TIME %d", m_event.param);
+    pid = m_event.param;
+    m_player->OnDVDNavResult((void*) &pid, 5);
+    m_hold = HOLD_STILL;
+    break;
+
+  case BD_EVENT_STILL:
+    CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_STILL %d",
+        m_event.param);
+    break;
+
+    /* playback position */
+
+  case BD_EVENT_ANGLE:
+    CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_ANGLE %d",
+        m_event.param);
+    m_angle = m_event.param;
+    if (m_title)
+      m_dll->bd_free_title_info(m_title);
+    m_title = m_dll->bd_get_playlist_info(m_bd, m_playlist, m_angle);
+    break;
+
+  case BD_EVENT_END_OF_TITLE:
+    CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_END_OF_TITLE %d",
+        m_event.param);
+    /* when a title ends, playlist WILL eventually change */
+    if (m_title)
+      m_dll->bd_free_title_info(m_title);
+    m_title = NULL;
+    break;
+
+  case BD_EVENT_TITLE:
+    CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_TITLE %d",
+        m_event.param);
+    break;
+
+  case BD_EVENT_PLAYLIST:
+    CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_PLAYLIST %d",
+        m_event.param);
+    m_playlist = m_event.param;
+    if(m_title)
+      m_dll->bd_free_title_info(m_title);
+    m_title = m_dll->bd_get_playlist_info(m_bd, m_playlist, m_angle);
+    break;
+
+  case BD_EVENT_PLAYITEM:
+    CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_PLAYITEM %d",
+        m_event.param);
+    m_clip    = m_event.param;
+    break;
+
+  case BD_EVENT_CHAPTER:
+    CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_CHAPTER %d",
+        m_event.param);
+    break;
+
+    /* stream selection */
+
+  case BD_EVENT_AUDIO_STREAM:
+    pid = -1;
+    if (m_title && m_title->clip_count > m_clip
+        && m_title->clips[m_clip].audio_stream_count
+            > (uint8_t) (m_event.param - 1))
+      pid = m_title->clips[m_clip].audio_streams[m_event.param - 1].pid;
+    CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_AUDIO_STREAM %d %d",
+        m_event.param, pid);
+    m_player->OnDVDNavResult((void*) &pid, 2);
+    break;
+
+  case BD_EVENT_PG_TEXTST:
+    CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_PG_TEXTST %d",
+        m_event.param);
+    pid = m_event.param;
+    m_player->OnDVDNavResult((void*) &pid, 4);
+    break;
+
+  case BD_EVENT_PG_TEXTST_STREAM:
+    pid = -1;
+    if (m_title && m_title->clip_count > m_clip
+        && m_title->clips[m_clip].pg_stream_count
+            > (uint8_t) (m_event.param - 1))
+      pid = m_title->clips[m_clip].pg_streams[m_event.param - 1].pid;
+    CLog::Log(LOGDEBUG,
+        "CDVDInputStreamBluray - BD_EVENT_PG_TEXTST_STREAM %d, %d",
+        m_event.param, pid);
+    m_player->OnDVDNavResult((void*) &pid, 3);
+    break;
+
+#ifdef HAVE_LIBBLURAY_BDJ
+  case BD_EVENT_MENU:
+    CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_PG_TEXTST %d",
+        m_event.param);
+    m_menu = !!m_event.param;
+    break;
+
+  case BD_EVENT_IDLE:
+    Sleep(100);
+    break;
+#endif
+
+  case BD_EVENT_IG_STREAM:
+  case BD_EVENT_SECONDARY_AUDIO:
+  case BD_EVENT_SECONDARY_AUDIO_STREAM:
+  case BD_EVENT_SECONDARY_VIDEO:
+  case BD_EVENT_SECONDARY_VIDEO_SIZE:
+  case BD_EVENT_SECONDARY_VIDEO_STREAM:
+
+  case BD_EVENT_NONE:
+    break;
+
+  default:
+    CLog::Log(LOGWARNING,
+        "CDVDInputStreamBluray - unhandled libbluray event %d [param %d]",
+        m_event.event, m_event.param);
+    break;
+  }
+
+  /* event has been consumed */
+  m_event.event = BD_EVENT_NONE;
+}
+
+int CDVDInputStreamBluray::Read(uint8_t* buf, int buf_size)
 {
   if(m_navmode)
   {
diff -ur a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamBluray.h b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamBluray.h
--- a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamBluray.h	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamBluray.h	2015-03-12 20:48:25.158096999 +0100
@@ -47,7 +47,7 @@
   virtual ~CDVDInputStreamBluray();
   virtual bool Open(const char* strFile, const std::string &content);
   virtual void Close();
-  virtual int Read(BYTE* buf, int buf_size);
+  virtual int Read(uint8_t* buf, int buf_size);
   virtual int64_t Seek(int64_t offset, int whence);
   virtual bool Pause(double dTime) { return false; };
   virtual bool IsEOF();
diff -ur a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamFFmpeg.cpp
--- a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamFFmpeg.cpp	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamFFmpeg.cpp	2015-03-12 20:48:25.158096999 +0100
@@ -74,7 +74,7 @@
   CDVDInputStream::Close();
 }
 
-int CDVDInputStreamFFmpeg::Read(BYTE* buf, int buf_size)
+int CDVDInputStreamFFmpeg::Read(uint8_t* buf, int buf_size)
 {
   return -1;
 }
diff -ur a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamFFmpeg.h b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamFFmpeg.h
--- a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamFFmpeg.h	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamFFmpeg.h	2015-03-12 20:48:25.158096999 +0100
@@ -31,7 +31,7 @@
   virtual ~CDVDInputStreamFFmpeg();
   virtual bool Open(const char* strFile, const std::string &content);
   virtual void Close();
-  virtual int Read(BYTE* buf, int buf_size);
+  virtual int Read(uint8_t* buf, int buf_size);
   virtual int64_t Seek(int64_t offset, int whence);
   virtual bool Pause(double dTime) { return false; };
   virtual bool IsEOF();
diff -ur a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamFile.cpp b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamFile.cpp
--- a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamFile.cpp	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamFile.cpp	2015-03-12 20:48:25.158096999 +0100
@@ -121,7 +121,7 @@
   m_eof = true;
 }
 
-int CDVDInputStreamFile::Read(BYTE* buf, int buf_size)
+int CDVDInputStreamFile::Read(uint8_t* buf, int buf_size)
 {
   if(!m_pFile) return -1;
 
diff -ur a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamFile.h b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamFile.h
--- a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamFile.h	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamFile.h	2015-03-12 20:48:25.158096999 +0100
@@ -29,7 +29,7 @@
   virtual ~CDVDInputStreamFile();
   virtual bool Open(const char* strFile, const std::string &content);
   virtual void Close();
-  virtual int Read(BYTE* buf, int buf_size);
+  virtual int Read(uint8_t* buf, int buf_size);
   virtual int64_t Seek(int64_t offset, int whence);
   virtual bool Pause(double dTime) { return false; };
   virtual bool IsEOF();
diff -ur a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStream.h b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStream.h
--- a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStream.h	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStream.h	2015-03-12 20:48:25.158096999 +0100
@@ -145,7 +145,7 @@
   virtual ~CDVDInputStream();
   virtual bool Open(const char* strFileName, const std::string& content);
   virtual void Close() = 0;
-  virtual int Read(BYTE* buf, int buf_size) = 0;
+  virtual int Read(uint8_t* buf, int buf_size) = 0;
   virtual int64_t Seek(int64_t offset, int whence) = 0;
   virtual bool Pause(double dTime) = 0;
   virtual int64_t GetLength() = 0;
diff -ur a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHTSP.cpp b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHTSP.cpp
--- a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHTSP.cpp	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHTSP.cpp	2015-03-12 20:48:25.158096999 +0100
@@ -122,7 +122,7 @@
   m_read.Clear();
 }
 
-int CDVDInputStreamHTSP::Read(BYTE* buf, int buf_size)
+int CDVDInputStreamHTSP::Read(uint8_t* buf, int buf_size)
 {
   size_t count = m_read.Size();
   if(count == 0)
diff -ur a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHTSP.h b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHTSP.h
--- a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHTSP.h	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHTSP.h	2015-03-12 20:48:25.158096999 +0100
@@ -32,7 +32,7 @@
   virtual ~CDVDInputStreamHTSP();
   virtual bool    Open(const char* file, const std::string &content);
   virtual void    Close();
-  virtual int     Read(BYTE* buf, int buf_size);
+  virtual int     Read(uint8_t* buf, int buf_size);
   virtual int64_t Seek(int64_t offset, int whence) { return -1; }
   virtual bool Pause(double dTime) { return false; };
   virtual bool    IsEOF();
diff -ur a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHttp.cpp b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHttp.cpp
--- a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHttp.cpp	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHttp.cpp	2015-03-12 20:48:25.158096999 +0100
@@ -91,7 +91,7 @@
   m_pFile = NULL;
 }
 
-int CDVDInputStreamHttp::Read(BYTE* buf, int buf_size)
+int CDVDInputStreamHttp::Read(uint8_t* buf, int buf_size)
 {
   unsigned int ret = 0;
   if (m_pFile) ret = m_pFile->Read(buf, buf_size);
diff -ur a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHttp.h b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHttp.h
--- a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHttp.h	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHttp.h	2015-03-12 20:48:25.158096999 +0100
@@ -35,7 +35,7 @@
   virtual ~CDVDInputStreamHttp();
   virtual bool Open(const char* strFile, const std::string& content);
   virtual void Close();
-  virtual int Read(BYTE* buf, int buf_size);
+  virtual int Read(uint8_t* buf, int buf_size);
   virtual int64_t Seek(int64_t offset, int whence);
   virtual bool IsEOF();
   virtual int64_t GetLength();
diff -ur a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamMemory.cpp b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamMemory.cpp
--- a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamMemory.cpp	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamMemory.cpp	2015-03-12 20:48:25.158096999 +0100
@@ -58,7 +58,7 @@
   CDVDInputStream::Close();
 }
 
-int CDVDInputStreamMemory::Read(BYTE* buf, int buf_size)
+int CDVDInputStreamMemory::Read(uint8_t* buf, int buf_size)
 {
   int iBytesToCopy = buf_size;
   int iBytesLeft = m_iDataSize - m_iDataPos;
diff -ur a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamMemory.h b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamMemory.h
--- a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamMemory.h	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamMemory.h	2015-03-12 20:48:25.158096999 +0100
@@ -29,13 +29,13 @@
   virtual ~CDVDInputStreamMemory();
   virtual bool Open(const char* strFile, const std::string& content);
   virtual void Close();
-  virtual int Read(BYTE* buf, int buf_size);
+  virtual int Read(uint8_t* buf, int buf_size);
   virtual int64_t Seek(int64_t offset, int whence);
   virtual bool IsEOF();
   virtual int64_t GetLength();
 
 protected:
-  BYTE* m_pData;
+  uint8_t* m_pData;
   int   m_iDataSize;
   int   m_iDataPos;
 };
diff -ur a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamNavigator.cpp b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamNavigator.cpp
--- a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamNavigator.cpp	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamNavigator.cpp	2015-03-12 20:48:25.158096999 +0100
@@ -222,7 +222,7 @@
   m_bEOF = true;
 }
 
-int CDVDInputStreamNavigator::Read(BYTE* buf, int buf_size)
+int CDVDInputStreamNavigator::Read(uint8_t* buf, int buf_size)
 {
   if (!m_dvdnav || m_bEOF) return 0;
   if (buf_size < DVD_VIDEO_BLOCKSIZE)
@@ -253,7 +253,7 @@
     return -1;
 }
 
-int CDVDInputStreamNavigator::ProcessBlock(BYTE* dest_buffer, int* read)
+int CDVDInputStreamNavigator::ProcessBlock(uint8_t* dest_buffer, int* read)
 {
   if (!m_dvdnav) return -1;
 
@@ -1184,7 +1184,7 @@
     CLog::Log(LOGWARNING, "CDVDInputStreamNavigator::SetNavigatorState - Failed to set state (%s), retrying after read", m_dll.dvdnav_err_to_string(m_dvdnav));
 
     /* vm won't be started until after first read, this should really be handled internally */
-    BYTE buffer[DVD_VIDEO_BLOCKSIZE];
+    uint8_t buffer[DVD_VIDEO_BLOCKSIZE];
     Read(buffer,DVD_VIDEO_BLOCKSIZE);
 
     if( DVDNAV_STATUS_ERR == m_dll.dvdnav_set_state(m_dvdnav, &save_state) )
diff -ur a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamNavigator.h b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamNavigator.h
--- a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamNavigator.h	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamNavigator.h	2015-03-12 20:48:25.158096999 +0100
@@ -66,7 +66,7 @@
 
   virtual bool Open(const char* strFile, const std::string& content);
   virtual void Close();
-  virtual int Read(BYTE* buf, int buf_size);
+  virtual int Read(uint8_t* buf, int buf_size);
   virtual int64_t Seek(int64_t offset, int whence);
   virtual bool Pause(double dTime) { return false; };
   virtual int GetBlockSize() { return DVDSTREAM_BLOCK_SIZE_DVD; }
@@ -127,7 +127,7 @@
   double GetTimeStampCorrection() { return (double)(m_iVobUnitCorrection * 1000) / 90; }
 protected:
 
-  int ProcessBlock(BYTE* buffer, int* read);
+  int ProcessBlock(uint8_t* buffer, int* read);
 
   void CheckButtons();
 
@@ -172,7 +172,7 @@
 
   IDVDPlayer* m_pDVDPlayer;
 
-  BYTE m_lastblock[DVD_VIDEO_BLOCKSIZE];
-  int  m_lastevent;
+  uint8_t m_lastblock[DVD_VIDEO_BLOCKSIZE];
+  int     m_lastevent;
 };
 
diff -ur a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamPVRManager.cpp b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamPVRManager.cpp
--- a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamPVRManager.cpp	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamPVRManager.cpp	2015-03-12 20:48:25.158096999 +0100
@@ -165,7 +165,7 @@
   CLog::Log(LOGDEBUG, "CDVDInputStreamPVRManager::Close - stream closed");
 }
 
-int CDVDInputStreamPVRManager::Read(BYTE* buf, int buf_size)
+int CDVDInputStreamPVRManager::Read(uint8_t* buf, int buf_size)
 {
   if(!m_pFile) return -1;
 
diff -ur a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamPVRManager.h b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamPVRManager.h
--- a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamPVRManager.h	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamPVRManager.h	2015-03-12 20:48:25.158096999 +0100
@@ -46,7 +46,7 @@
   virtual ~CDVDInputStreamPVRManager();
   virtual bool Open(const char* strFile, const std::string &content);
   virtual void Close();
-  virtual int Read(BYTE* buf, int buf_size);
+  virtual int Read(uint8_t* buf, int buf_size);
   virtual int64_t Seek(int64_t offset, int whence);
   virtual bool Pause(double dTime) { return false; }
   virtual bool IsEOF();
diff -ur a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamRTMP.cpp b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamRTMP.cpp
--- a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamRTMP.cpp	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamRTMP.cpp	2015-03-12 20:48:25.158096999 +0100
@@ -185,7 +185,7 @@
   m_bPaused = false;
 }
 
-int CDVDInputStreamRTMP::Read(BYTE* buf, int buf_size)
+int CDVDInputStreamRTMP::Read(uint8_t* buf, int buf_size)
 {
   int i = m_libRTMP.Read(m_rtmp, (char *)buf, buf_size);
   if (i < 0)
diff -ur a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamRTMP.h b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamRTMP.h
--- a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamRTMP.h	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamRTMP.h	2015-03-12 20:48:25.158096999 +0100
@@ -33,7 +33,7 @@
   virtual ~CDVDInputStreamRTMP();
   virtual bool    Open(const char* strFile, const std::string &content);
   virtual void    Close();
-  virtual int     Read(BYTE* buf, int buf_size);
+  virtual int     Read(uint8_t* buf, int buf_size);
   virtual int64_t Seek(int64_t offset, int whence);
   bool            SeekTime(int iTimeInMsec);
   virtual bool Pause(double dTime);
diff -ur a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamStack.cpp b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamStack.cpp
--- a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamStack.cpp	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamStack.cpp	2015-03-12 20:48:25.158096999 +0100
@@ -106,7 +106,7 @@
   m_eof = true;
 }
 
-int CDVDInputStreamStack::Read(BYTE* buf, int buf_size)
+int CDVDInputStreamStack::Read(uint8_t* buf, int buf_size)
 {
   if(m_file == NULL || m_eof)
     return 0;
diff -ur a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamStack.h b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamStack.h
--- a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamStack.h	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamStack.h	2015-03-12 20:48:25.158096999 +0100
@@ -31,7 +31,7 @@
 
   virtual bool    Open(const char* path, const std::string &content);
   virtual void    Close();
-  virtual int     Read(BYTE* buf, int buf_size);
+  virtual int     Read(uint8_t* buf, int buf_size);
   virtual int64_t Seek(int64_t offset, int whence);
   virtual bool Pause(double dTime) { return false; };
   virtual bool    IsEOF();
diff -ur a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamTV.cpp b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamTV.cpp
--- a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamTV.cpp	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamTV.cpp	2015-03-12 20:48:25.158096999 +0100
@@ -98,7 +98,7 @@
   m_eof = true;
 }
 
-int CDVDInputStreamTV::Read(BYTE* buf, int buf_size)
+int CDVDInputStreamTV::Read(uint8_t* buf, int buf_size)
 {
   if(!m_pFile) return -1;
 
diff -ur a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamTV.h b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamTV.h
--- a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamTV.h	2015-03-12 20:52:41.082096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamTV.h	2015-03-12 20:48:25.158096999 +0100
@@ -38,7 +38,7 @@
   virtual ~CDVDInputStreamTV();
   virtual bool    Open(const char* strFile, const std::string &content);
   virtual void    Close();
-  virtual int     Read(BYTE* buf, int buf_size);
+  virtual int     Read(uint8_t* buf, int buf_size);
   virtual int64_t Seek(int64_t offset, int whence);
   virtual bool Pause(double dTime) { return false; };
   virtual bool    IsEOF();
diff -ur a/xbmc/cores/dvdplayer/DVDMessage.cpp b/xbmc/cores/dvdplayer/DVDMessage.cpp
--- a/xbmc/cores/dvdplayer/DVDMessage.cpp	2015-03-12 20:52:41.086096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDMessage.cpp	2015-03-12 20:48:25.158096999 +0100
@@ -57,7 +57,7 @@
   delete m_p;
 }
 
-bool CDVDMsgGeneralSynchronize::Wait(unsigned long milliseconds, unsigned int source)
+bool CDVDMsgGeneralSynchronize::Wait(unsigned int milliseconds, unsigned int source)
 {
   if(source == 0)
     source = SYNCSOURCE_OWNER;
diff -ur a/xbmc/cores/dvdplayer/DVDMessage.h b/xbmc/cores/dvdplayer/DVDMessage.h
--- a/xbmc/cores/dvdplayer/DVDMessage.h	2015-03-12 20:52:41.086096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDMessage.h	2015-03-12 20:48:25.158096999 +0100
@@ -160,7 +160,7 @@
 
   // waits until all threads waiting, released the object
   // if abort is set somehow
-  bool Wait(unsigned long  ms   , unsigned int source);
+  bool Wait(unsigned int   ms   , unsigned int source);
   void Wait(volatile bool *abort, unsigned int source);
 private:
   class CDVDMsgGeneralSynchronizePriv* m_p;
@@ -299,7 +299,7 @@
 class CDVDMsgSubtitleClutChange : public CDVDMsg
 {
 public:
-  CDVDMsgSubtitleClutChange(BYTE* data) : CDVDMsg(SUBTITLE_CLUTCHANGE) { memcpy(m_data, data, 16*4); }
-  BYTE m_data[16][4];
+  CDVDMsgSubtitleClutChange(uint8_t* data) : CDVDMsg(SUBTITLE_CLUTCHANGE) { memcpy(m_data, data, 16*4); }
+  uint8_t m_data[16][4];
 private:
 };
diff -ur a/xbmc/cores/dvdplayer/DVDMessageTracker.h b/xbmc/cores/dvdplayer/DVDMessageTracker.h
--- a/xbmc/cores/dvdplayer/DVDMessageTracker.h	2015-03-12 20:52:41.086096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDMessageTracker.h	2015-03-12 20:48:25.158096999 +0100
@@ -41,7 +41,7 @@
 
   CDVDMsg* m_pMsg;
   bool m_debug_logged;
-  DWORD m_time_created;
+  unsigned int m_time_created;
 
 };
 
diff -ur a/xbmc/cores/dvdplayer/DVDOverlayRenderer.cpp b/xbmc/cores/dvdplayer/DVDOverlayRenderer.cpp
--- a/xbmc/cores/dvdplayer/DVDOverlayRenderer.cpp	2015-03-12 20:52:41.086096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDOverlayRenderer.cpp	2015-03-12 20:48:25.158096999 +0100
@@ -74,8 +74,8 @@
 
   while(img)
   {
-    DWORD color = img->color;
-    BYTE alpha = (BYTE)(color &0xff);
+    unsigned int color = img->color;
+    uint8_t alpha = (uint8_t)(color &0xff);
 
     // fully transparent or width or height is 0 -> not displayed
     if(alpha == 255 || img->w == 0 || img->h == 0)
@@ -89,9 +89,9 @@
     double g = ((color >> 16) & 0xff) / 255.0;
     double b = ((color >> 8 ) & 0xff) / 255.0;
 
-    BYTE luma  = (BYTE)(        255 * CLAMP( 0.299 * r + 0.587 * g + 0.114 * b,  0.0, 1.0));
-    BYTE v     = (BYTE)(127.5 + 255 * CLAMP( 0.500 * r - 0.419 * g - 0.081 * b, -0.5, 0.5));
-    BYTE u     = (BYTE)(127.5 + 255 * CLAMP(-0.169 * r - 0.331 * g + 0.500 * b, -0.5, 0.5));
+    uint8_t luma  = (uint8_t)(        255 * CLAMP( 0.299 * r + 0.587 * g + 0.114 * b,  0.0, 1.0));
+    uint8_t v     = (uint8_t)(127.5 + 255 * CLAMP( 0.500 * r - 0.419 * g - 0.081 * b, -0.5, 0.5));
+    uint8_t u     = (uint8_t)(127.5 + 255 * CLAMP(-0.169 * r - 0.331 * g + 0.500 * b, -0.5, 0.5));
 
     int y = std::max(0,std::min(img->dst_y, pPicture->height-img->h));
     int x = std::max(0,std::min(img->dst_x, pPicture->width-img->w));
@@ -101,9 +101,9 @@
       if(y + i >= pPicture->height)
         break;
 
-      BYTE* line = img->bitmap + img->stride*i;
+      uint8_t* line = img->bitmap + img->stride*i;
 
-      BYTE* target[3];
+      uint8_t* target[3];
       target[0] = pPicture->data[0] + pPicture->stride[0]*(i + y) + x;
       target[1] = pPicture->data[1] + pPicture->stride[1]*((i + y)>>1) + (x>>1);
       target[2] = pPicture->data[2] + pPicture->stride[2]*((i + y)>>1) + (x>>1);
@@ -131,23 +131,23 @@
 
 void CDVDOverlayRenderer::Render(DVDPictureRenderer* pPicture, CDVDOverlayImage* pOverlay)
 {
-  BYTE* palette[4];
+  uint8_t* palette[4];
   for(int i=0;i<4;i++)
-    palette[i] = (BYTE*)calloc(1, pOverlay->palette_colors);
+    palette[i] = (uint8_t*)calloc(1, pOverlay->palette_colors);
 
   for(int i=0;i<pOverlay->palette_colors;i++)
   {
     uint32_t color = pOverlay->palette[i];
 
-    palette[3][i] = (BYTE)((color >> 24) & 0xff);
+    palette[3][i] = (uint8_t)((color >> 24) & 0xff);
 
     double r = ((color >> 16) & 0xff) / 255.0;
     double g = ((color >> 8 ) & 0xff) / 255.0;
     double b = ((color >> 0 ) & 0xff) / 255.0;
 
-    palette[0][i] = (BYTE)(255 * CLAMP(0.299 * r + 0.587 * g + 0.114 * b, 0.0, 1.0));
-    palette[1][i] = (BYTE)(127.5 + 255 * CLAMP( 0.500 * r - 0.419 * g - 0.081 * b, -0.5, 0.5));
-    palette[2][i] = (BYTE)(127.5 + 255 * CLAMP(-0.169 * r - 0.331 * g + 0.500 * b, -0.5, 0.5));
+    palette[0][i] = (uint8_t)(255 * CLAMP(0.299 * r + 0.587 * g + 0.114 * b, 0.0, 1.0));
+    palette[1][i] = (uint8_t)(127.5 + 255 * CLAMP( 0.500 * r - 0.419 * g - 0.081 * b, -0.5, 0.5));
+    palette[2][i] = (uint8_t)(127.5 + 255 * CLAMP(-0.169 * r - 0.331 * g + 0.500 * b, -0.5, 0.5));
   }
 
   // we try o fit it in if it's outside the image
@@ -159,9 +159,9 @@
     if(y + i >= pPicture->height)
       break;
 
-    BYTE* line = pOverlay->data + pOverlay->linesize*i;
+    uint8_t* line = pOverlay->data + pOverlay->linesize*i;
 
-    BYTE* target[3];
+    uint8_t* target[3];
     target[0] = pPicture->data[0] + pPicture->stride[0]*(i + y) + x;
     target[1] = pPicture->data[1] + pPicture->stride[1]*((i + y)>>1) + (x>>1);
     target[2] = pPicture->data[2] + pPicture->stride[2]*((i + y)>>1) + (x>>1);
diff -ur a/xbmc/cores/dvdplayer/DVDOverlayRenderer.h b/xbmc/cores/dvdplayer/DVDOverlayRenderer.h
--- a/xbmc/cores/dvdplayer/DVDOverlayRenderer.h	2015-03-12 20:52:41.086096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDOverlayRenderer.h	2015-03-12 20:48:25.158096999 +0100
@@ -32,7 +32,7 @@
 
 typedef struct stDVDPictureRenderer
 {
-  BYTE* data[4];
+  uint8_t* data[4];
   int stride[4];
 
   int width;
diff -ur a/xbmc/cores/dvdplayer/DVDPlayerAudio.h b/xbmc/cores/dvdplayer/DVDPlayerAudio.h
--- a/xbmc/cores/dvdplayer/DVDPlayerAudio.h	2015-03-12 20:52:41.086096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDPlayerAudio.h	2015-03-12 20:48:25.162096999 +0100
@@ -38,8 +38,6 @@
 class IAudioCallback;
 class CDVDAudioCodec;
 
-enum CodecID;
-
 #define DECODE_FLAG_DROP    1
 #define DECODE_FLAG_RESYNC  2
 #define DECODE_FLAG_ERROR   4
@@ -48,7 +46,7 @@
 
 typedef struct stDVDAudioFrame
 {
-  BYTE* data;
+  uint8_t* data;
   double pts;
   double duration;
   unsigned int size;
@@ -148,7 +146,7 @@
     }
 
     CDVDMsgDemuxerPacket*  msg;
-    BYTE*                  data;
+    uint8_t*               data;
     int                    size;
     double                 dts;
 
diff -ur a/xbmc/cores/dvdplayer/DVDPlayer.cpp b/xbmc/cores/dvdplayer/DVDPlayer.cpp
--- a/xbmc/cores/dvdplayer/DVDPlayer.cpp	2015-03-12 20:52:41.086096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDPlayer.cpp	2015-03-12 20:48:25.162096999 +0100
@@ -502,7 +502,7 @@
       if(dialog)
       {
         dialog->Show();
-        while(!m_ready.WaitMSec(1))
+        while(!m_ready.WaitMSec(100))
         {
           /* PLEX */
           if (dialog->IsCanceled())
@@ -851,25 +851,13 @@
   RelinkPlexStreams();
   /* END PLEX */
 
-#if 0
   int64_t len = m_pInputStream->GetLength();
   int64_t tim = m_pDemuxer->GetStreamLength();
-  if(len > 0 && tim > 0)
-    //m_pInputStream->SetReadRate(len * 1000 / tim);
-  {
-    //cap to intital read rate to 40 megabits/second if less than average bitrate * 1.25
-    m_readRate = std::min((unsigned int)((len * 1000 / tim) * 1.25), (unsigned int) (40000000 / 8));
-    m_pInputStream->SetReadRate(m_readRate);
-  }
-#else
-  /* There is probably a good reason why we limit the readRate in upsteam
-   * But I am just going to ignore that until I run into any problems.
-   */
-  m_readRate = g_advancedSettings.m_cacheReadRate;
-  m_pInputStream->SetReadRate(m_readRate);
-#endif
+  if(len > 0 && tim > 0)  
+    m_pInputStream->SetReadRate(g_advancedSettings.m_readBufferFactor * len * 1000 / tim);
 
   return true;
+
 }
 
 #ifndef __PLEX__
@@ -2255,9 +2243,9 @@
         if(!msg.GetTrickPlay())
         {
           g_infoManager.SetDisplayAfterSeek(100000);
-          if(msg.GetFlush())
-            SetCaching(CACHESTATE_FLUSH);
         }
+        if(msg.GetFlush())
+          SetCaching(CACHESTATE_FLUSH);
 
         double start = DVD_NOPTS_VALUE;
 
@@ -3569,10 +3557,10 @@
           m_dvd.iDVDStillStartTime = XbmcThreads::SystemClockMillis();
 
           /* adjust for the output delay in the video queue */
-          DWORD time = 0;
+          unsigned int time = 0;
           if( m_CurrentVideo.stream && m_dvd.iDVDStillTime > 0 )
           {
-            time = (DWORD)(m_dvdPlayerVideo.GetOutputDelay() / ( DVD_TIME_BASE / 1000 ));
+            time = (unsigned int)(m_dvdPlayerVideo.GetOutputDelay() / ( DVD_TIME_BASE / 1000 ));
             if( time < 10000 && time > 0 )
               m_dvd.iDVDStillTime += time;
           }
@@ -3586,7 +3574,7 @@
       break;
     case DVDNAV_SPU_CLUT_CHANGE:
       {
-        m_dvdPlayerSubtitle.SendMessage(new CDVDMsgSubtitleClutChange((BYTE*)pData));
+        m_dvdPlayerSubtitle.SendMessage(new CDVDMsgSubtitleClutChange((uint8_t*)pData));
       }
       break;
     case DVDNAV_SPU_STREAM_CHANGE:
diff -ur a/xbmc/cores/dvdplayer/DVDPlayerSubtitle.cpp b/xbmc/cores/dvdplayer/DVDPlayerSubtitle.cpp
--- a/xbmc/cores/dvdplayer/DVDPlayerSubtitle.cpp	2015-03-12 20:52:41.086096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDPlayerSubtitle.cpp	2015-03-12 20:48:25.162096999 +0100
@@ -86,7 +86,7 @@
         }
       }
     }
-    else if (m_streaminfo.codec == CODEC_ID_DVD_SUBTITLE)
+    else if (m_streaminfo.codec == AV_CODEC_ID_DVD_SUBTITLE)
     {
       CDVDOverlaySpu* pSPUInfo = m_dvdspus.AddData(pPacket->pData, pPacket->iSize, pPacket->pts);
       if (pSPUInfo)
@@ -104,8 +104,8 @@
     CDVDMsgSubtitleClutChange* pData = (CDVDMsgSubtitleClutChange*)pMsg;
     for (int i = 0; i < 16; i++)
     {
-      BYTE* color = m_dvdspus.m_clut[i];
-      BYTE* t = (BYTE*)pData->m_data[i];
+      uint8_t* color = m_dvdspus.m_clut[i];
+      uint8_t* t = (uint8_t*)pData->m_data[i];
 
 // pData->m_data[i] points to an uint32_t
 // Byte swapping is needed between big and little endian systems
@@ -171,7 +171,7 @@
   }
 
   // dvd's use special subtitle decoder
-  if(hints.codec == CODEC_ID_DVD_SUBTITLE && filename == "dvd")
+  if(hints.codec == AV_CODEC_ID_DVD_SUBTITLE && filename == "dvd")
     return true;
 
   m_pOverlayCodec = CDVDFactoryCodec::CreateOverlayCodec(hints);
diff -ur a/xbmc/cores/dvdplayer/DVDPlayerTeletext.cpp b/xbmc/cores/dvdplayer/DVDPlayerTeletext.cpp
--- a/xbmc/cores/dvdplayer/DVDPlayerTeletext.cpp	2015-03-12 20:52:41.086096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDPlayerTeletext.cpp	2015-03-12 20:48:25.162096999 +0100
@@ -113,10 +113,8 @@
 
 bool CDVDTeletextData::CheckStream(CDVDStreamInfo &hints)
 {
-#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(52,38,1)
-  if (hints.codec == CODEC_ID_DVB_TELETEXT)
+  if (hints.codec == AV_CODEC_ID_DVB_TELETEXT)
     return true;
-#endif
 
   return false;
 }
@@ -125,14 +123,12 @@
 {
   m_messageQueue.Init();
 
-#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(52,38,1)
-  if (hints.codec == CODEC_ID_DVB_TELETEXT)
+  if (hints.codec == AV_CODEC_ID_DVB_TELETEXT)
   {
     CLog::Log(LOGNOTICE, "Creating teletext data thread");
     Create();
     return true;
   }
-#endif
 
   return false;
 }
diff -ur a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp	2015-03-12 20:52:41.086096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp	2015-03-12 20:48:25.162096999 +0100
@@ -797,7 +797,7 @@
 void CDVDPlayerVideo::ProcessVideoUserData(DVDVideoUserData* pVideoUserData, double pts)
 {
   // check userdata type
-  BYTE* data = pVideoUserData->data;
+  uint8_t* data = pVideoUserData->data;
   int size = pVideoUserData->size;
 
   if (size >= 2)
@@ -1415,7 +1415,7 @@
   int black  = 16; // what is black in the image
   int level  = 8;  // how high above this should we detect
   int multi  = 4;  // what multiple of last line should failing line be to accept
-  BYTE *s;
+  uint8_t *s;
   int last, detect, black2;
 
   // top and bottom levels
diff -ur a/xbmc/cores/dvdplayer/DVDPlayerVideo.h b/xbmc/cores/dvdplayer/DVDPlayerVideo.h
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.h	2015-03-12 20:52:41.086096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.h	2015-03-12 20:48:25.162096999 +0100
@@ -31,7 +31,6 @@
 #include "cores/VideoRenderers/RenderManager.h"
 #endif
 
-enum CodecID;
 class CDemuxStreamVideo;
 class CDVDOverlayCodecCC;
 
diff -ur a/xbmc/cores/dvdplayer/DVDStreamInfo.cpp b/xbmc/cores/dvdplayer/DVDStreamInfo.cpp
--- a/xbmc/cores/dvdplayer/DVDStreamInfo.cpp	2015-03-12 20:52:41.086096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDStreamInfo.cpp	2015-03-12 20:48:25.162096999 +0100
@@ -38,7 +38,7 @@
 
 void CDVDStreamInfo::Clear()
 {
-  codec = CODEC_ID_NONE;
+  codec = AV_CODEC_ID_NONE;
   type = STREAM_NONE;
   software = false;
   codec_tag  = 0;
@@ -67,7 +67,6 @@
   bitrate    = 0;
   bitspersample = 0;
 
-  identifier = 0;
   orientation = 0;
 }
 
@@ -108,7 +107,6 @@
   ||  bitspersample != right.bitspersample ) return false;
 
   // SUBTITLE
-  if( identifier != right.identifier ) return false;
 
   return true;
 }
@@ -164,7 +162,6 @@
   bitspersample = right.bitspersample;
 
   // SUBTITLE
-  identifier = right.identifier;
 }
 
 void CDVDStreamInfo::Assign(const CDemuxStream& right, bool withextradata)
@@ -209,7 +206,5 @@
   }
   else if(  right.type == STREAM_SUBTITLE )
   {
-    const CDemuxStreamSubtitle *stream = static_cast<const CDemuxStreamSubtitle*>(&right);
-    identifier = stream->identifier;
   }
 }
diff -ur a/xbmc/cores/dvdplayer/DVDStreamInfo.h b/xbmc/cores/dvdplayer/DVDStreamInfo.h
--- a/xbmc/cores/dvdplayer/DVDStreamInfo.h	2015-03-12 20:52:41.086096999 +0100
+++ b/xbmc/cores/dvdplayer/DVDStreamInfo.h	2015-03-12 20:48:25.162096999 +0100
@@ -23,10 +23,7 @@
 #if (defined HAVE_CONFIG_H) && (!defined WIN32)
   #include "config.h"
 #endif
-#ifndef _LINUX
-enum StreamType;
-enum CodecID;
-#else
+
 #include "DVDDemuxers/DVDDemux.h"
 extern "C" {
 #if (defined USE_EXTERNAL_FFMPEG)
@@ -39,7 +36,6 @@
   #include "libavcodec/avcodec.h"
 #endif
 }
-#endif
 
 class CDemuxStream;
 
@@ -59,7 +55,7 @@
   void Assign(const CDVDStreamInfo &right, bool withextradata);
   void Assign(const CDemuxStream &right, bool withextradata);
 
-  CodecID codec;
+  AVCodecID codec;
   StreamType type;
   bool software;  //force software decoding
 
@@ -87,7 +83,6 @@
   int bitspersample;
 
   // SUBTITLE
-  int identifier;
 
   // CODEC EXTRADATA
   void*        extradata; // extra data for codec to use
diff -ur a/xbmc/cores/omxplayer/DllOMX.h b/xbmc/cores/omxplayer/DllOMX.h
--- a/xbmc/cores/omxplayer/DllOMX.h	2015-03-12 20:52:41.090096999 +0100
+++ b/xbmc/cores/omxplayer/DllOMX.h	2015-03-12 20:48:09.966096999 +0100
@@ -90,7 +90,7 @@
 class DllOMX : public DllDynamic, DllOMXInterface
 {
   //DECLARE_DLL_WRAPPER(DllLibOpenMax, "/usr/lib/libnvomx.so")
-  DECLARE_DLL_WRAPPER(DllOMX, "/opt/vc/lib/libopenmaxil.so")
+  DECLARE_DLL_WRAPPER(DllOMX, "/usr/lib/libopenmaxil.so")
 
   DEFINE_METHOD0(OMX_ERRORTYPE, OMX_Init)
   DEFINE_METHOD0(OMX_ERRORTYPE, OMX_Deinit)
@@ -114,6 +114,7 @@
 public:
   virtual bool Load()
   {
+    CLog::Log(LOGDEBUG, "DllOMX: dlloaded openmax library in omx core");
     return DllDynamic::Load();
   }
 };
diff -ur a/xbmc/cores/omxplayer/OMXAudioCodecOMX.cpp b/xbmc/cores/omxplayer/OMXAudioCodecOMX.cpp
--- a/xbmc/cores/omxplayer/OMXAudioCodecOMX.cpp	2015-03-12 20:52:41.090096999 +0100
+++ b/xbmc/cores/omxplayer/OMXAudioCodecOMX.cpp	2015-03-12 20:48:25.162096999 +0100
@@ -26,70 +26,27 @@
 
 #include "cores/AudioEngine/Utils/AEUtil.h"
 
-#define MAX_AUDIO_FRAME_SIZE (AVCODEC_MAX_AUDIO_FRAME_SIZE*2)
-
-template <class AudioDataType>
-static inline void _Upmix(AudioDataType *input,
-  unsigned int channelsInput, AudioDataType *output,
-  unsigned int channelsOutput, unsigned int frames)
-{
-  unsigned int unused = channelsOutput - channelsInput;
-  AudioDataType *_input  = input;
-  AudioDataType *_output = output;
-
-  for (unsigned int i = 0; i < frames; i++)
-  {
-    // get input channels
-    for(unsigned int j = 0; j < channelsInput; j++)
-      *_output++ = *_input++;
-    // set unused channels
-    for(unsigned int j = 0; j < unused; j++)
-      *_output++ = 0;
-  }
-}
-
-void COMXAudioCodecOMX::Upmix(void *input,
-  unsigned int channelsInput,  void *output,
-  unsigned int channelsOutput, unsigned int frames, AEDataFormat dataFormat)
-{
-  // input channels must be less than output channels
-  if (channelsInput >= channelsOutput)
-    return;
-
-  switch (CAEUtil::DataFormatToBits(dataFormat))
-  {
-    case 8:  _Upmix ( (unsigned char *) input, channelsInput, (unsigned char *) output, channelsOutput, frames ); break;
-    case 16: _Upmix ( (short         *) input, channelsInput, (short         *) output, channelsOutput, frames ); break;
-    case 32: _Upmix ( (float         *) input, channelsInput, (float         *) output, channelsOutput, frames ); break;
-    default: _Upmix ( (int           *) input, channelsInput, (int           *) output, channelsOutput, frames ); break;
-  }
-}
-
 COMXAudioCodecOMX::COMXAudioCodecOMX()
 {
-  m_iBufferSize2 = 0;
-  m_pBuffer2     = (BYTE*)_aligned_malloc(MAX_AUDIO_FRAME_SIZE + FF_INPUT_BUFFER_PADDING_SIZE, 16);
-  memset(m_pBuffer2, 0, MAX_AUDIO_FRAME_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);
-
-  m_iBufferUpmixSize = 0;
-  m_pBufferUpmix = (BYTE*)_aligned_malloc(MAX_AUDIO_FRAME_SIZE + FF_INPUT_BUFFER_PADDING_SIZE, 16);
-  memset(m_pBufferUpmix, 0, MAX_AUDIO_FRAME_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);
+  m_pBufferOutput = NULL;
+  m_iBufferOutputAlloced = 0;
 
-  m_iBuffered = 0;
   m_pCodecContext = NULL;
   m_pConvert = NULL;
   m_bOpenedCodec = false;
 
   m_channels = 0;
-  m_layout = 0;
   m_pFrame1 = NULL;
+  m_bGotFrame = false;
   m_iSampleFormat = AV_SAMPLE_FMT_NONE;
+  m_desiredSampleFormat = AV_SAMPLE_FMT_NONE;
 }
 
 COMXAudioCodecOMX::~COMXAudioCodecOMX()
 {
-  _aligned_free(m_pBuffer2);
-  _aligned_free(m_pBufferUpmix);
+  m_dllAvUtil.av_free(m_pBufferOutput);
+  m_pBufferOutput = NULL;
+  m_iBufferOutputAlloced = 0;
   Dispose();
 }
 
@@ -110,6 +67,7 @@
     return false;
   }
 
+  m_bFirstFrame = true;
   m_pCodecContext = m_dllAvCodec.avcodec_alloc_context3(pCodec);
   m_pCodecContext->debug_mv = 0;
   m_pCodecContext->debug = 0;
@@ -145,6 +103,7 @@
   m_pFrame1 = m_dllAvCodec.avcodec_alloc_frame();
   m_bOpenedCodec = true;
   m_iSampleFormat = AV_SAMPLE_FMT_NONE;
+  m_desiredSampleFormat = m_pCodecContext->sample_fmt == AV_SAMPLE_FMT_S16 ? AV_SAMPLE_FMT_S16 : AV_SAMPLE_FMT_FLTP;
   return true;
 }
 
@@ -158,6 +117,8 @@
 
   if (m_pCodecContext)
   {
+    if (m_pCodecContext->extradata) m_dllAvUtil.av_free(m_pCodecContext->extradata);
+    m_pCodecContext->extradata = NULL;
     if (m_bOpenedCodec) m_dllAvCodec.avcodec_close(m_pCodecContext);
     m_bOpenedCodec = false;
     m_dllAvUtil.av_free(m_pCodecContext);
@@ -168,9 +129,7 @@
   m_dllAvUtil.Unload();
   m_dllSwResample.Unload();
 
-  m_iBufferSize1 = 0;
-  m_iBufferSize2 = 0;
-  m_iBuffered = 0;
+  m_bGotFrame = false;
 }
 
 int COMXAudioCodecOMX::Decode(BYTE* pData, int iSize)
@@ -178,10 +137,8 @@
   int iBytesUsed, got_frame;
   if (!m_pCodecContext) return -1;
 
-  m_iBufferSize1 = AVCODEC_MAX_AUDIO_FRAME_SIZE;
-  m_iBufferSize2 = 0;
-
   AVPacket avpkt;
+  m_bGotFrame = false;
   m_dllAvCodec.av_init_packet(&avpkt);
   avpkt.data = pData;
   avpkt.size = iSize;
@@ -191,12 +148,8 @@
                                                  , &avpkt);
   if (iBytesUsed < 0 || !got_frame)
   {
-    m_iBufferSize1 = 0;
-    m_iBufferSize2 = 0;
     return iBytesUsed;
   }
-  m_iBufferSize1 = m_dllAvUtil.av_samples_get_buffer_size(NULL, m_pCodecContext->channels, m_pFrame1->nb_samples, m_pCodecContext->sample_fmt, 1);
-
   /* some codecs will attempt to consume more data than what we gave */
   if (iBytesUsed > iSize)
   {
@@ -204,115 +157,131 @@
     iBytesUsed = iSize;
   }
 
-  if(m_iBufferSize1 == 0 && iBytesUsed >= 0)
-    m_iBuffered += iBytesUsed;
-  else
-    m_iBuffered = 0;
+  if (m_bFirstFrame)
+  {
+    CLog::Log(LOGDEBUG, "COMXAudioCodecOMX::Decode(%p,%d) format=%d(%d) chan=%d samples=%d size=%d data=%p,%p,%p,%p,%p,%p,%p,%p",
+             pData, iSize, m_pCodecContext->sample_fmt, m_desiredSampleFormat, m_pCodecContext->channels, m_pFrame1->nb_samples,
+             m_pFrame1->linesize[0],
+             m_pFrame1->data[0], m_pFrame1->data[1], m_pFrame1->data[2], m_pFrame1->data[3], m_pFrame1->data[4], m_pFrame1->data[5], m_pFrame1->data[6], m_pFrame1->data[7]
+             );
+  }
+
+  m_bGotFrame = true;
+  return iBytesUsed;
+}
+
+int COMXAudioCodecOMX::GetData(BYTE** dst)
+{
+  if (!m_bGotFrame)
+    return 0;
 
-  if(m_pCodecContext->sample_fmt != AV_SAMPLE_FMT_S16 && m_iBufferSize1 > 0)
+  /* input audio is aligned */
+  int inputSize = m_dllAvUtil.av_samples_get_buffer_size(NULL, m_pCodecContext->channels, m_pFrame1->nb_samples, m_pCodecContext->sample_fmt, 0);
+  /* output audio will be packed */
+  int outputSize = m_dllAvUtil.av_samples_get_buffer_size(NULL, m_pCodecContext->channels, m_pFrame1->nb_samples, m_desiredSampleFormat, 1);
+
+  if (m_iBufferOutputAlloced < outputSize)
+  {
+     m_dllAvUtil.av_free(m_pBufferOutput);
+     m_pBufferOutput = (BYTE*)m_dllAvUtil.av_malloc(outputSize + FF_INPUT_BUFFER_PADDING_SIZE);
+     m_iBufferOutputAlloced = outputSize;
+  }
+  *dst = m_pBufferOutput;
+
+  /* need to convert format */
+  if(m_pCodecContext->sample_fmt != m_desiredSampleFormat)
   {
-    if(m_pConvert && m_pCodecContext->sample_fmt != m_iSampleFormat)
+    if(m_pConvert && (m_pCodecContext->sample_fmt != m_iSampleFormat || m_channels != m_pCodecContext->channels))
+    {
       m_dllSwResample.swr_free(&m_pConvert);
+      m_channels = m_pCodecContext->channels;
+    }
 
     if(!m_pConvert)
     {
       m_iSampleFormat = m_pCodecContext->sample_fmt;
       m_pConvert = m_dllSwResample.swr_alloc_set_opts(NULL,
                       m_dllAvUtil.av_get_default_channel_layout(m_pCodecContext->channels), 
-                      AV_SAMPLE_FMT_S16, m_pCodecContext->sample_rate,
+                      m_desiredSampleFormat, m_pCodecContext->sample_rate,
                       m_dllAvUtil.av_get_default_channel_layout(m_pCodecContext->channels), 
                       m_pCodecContext->sample_fmt, m_pCodecContext->sample_rate,
                       0, NULL);
-    }
 
-    if(!m_pConvert || m_dllSwResample.swr_init(m_pConvert) < 0)
-    {
-      CLog::Log(LOGERROR, "COMXAudioCodecOMX::Decode - Unable to convert %d to AV_SAMPLE_FMT_S16", m_pCodecContext->sample_fmt);
-      m_iBufferSize1 = 0;
-      m_iBufferSize2 = 0;
-      return iBytesUsed;
+      if(!m_pConvert || m_dllSwResample.swr_init(m_pConvert) < 0)
+      {
+        CLog::Log(LOGERROR, "COMXAudioCodecOMX::Decode - Unable to initialise convert format %d to %d", m_pCodecContext->sample_fmt, m_desiredSampleFormat);
+        return 0;
+      }
     }
 
-    int len = m_iBufferSize1 / m_dllAvUtil.av_get_bytes_per_sample(m_pCodecContext->sample_fmt);
-    if(m_dllSwResample.swr_convert(m_pConvert, &m_pBuffer2, len, (const uint8_t**)m_pFrame1->data, m_pFrame1->nb_samples) < 0)
+    /* use unaligned flag to keep output packed */
+    uint8_t *out_planes[m_pCodecContext->channels];
+    if(m_dllAvUtil.av_samples_fill_arrays(out_planes, NULL, m_pBufferOutput, m_pCodecContext->channels, m_pFrame1->nb_samples, m_desiredSampleFormat, 1) < 0 ||
+       m_dllSwResample.swr_convert(m_pConvert, out_planes, m_pFrame1->nb_samples, (const uint8_t **)m_pFrame1->data, m_pFrame1->nb_samples) < 0)
     {
-      CLog::Log(LOGERROR, "COMXAudioCodecOMX::Decode - Unable to convert %d to AV_SAMPLE_FMT_S16", (int)m_pCodecContext->sample_fmt);
-      m_iBufferSize1 = 0;
-      m_iBufferSize2 = 0;
-      return iBytesUsed;
+      CLog::Log(LOGERROR, "COMXAudioCodecOMX::Decode - Unable to convert format %d to %d", (int)m_pCodecContext->sample_fmt, m_desiredSampleFormat);
+      outputSize = 0;
     }
-
-    m_iBufferSize1 = 0;
-    m_iBufferSize2 = len * m_dllAvUtil.av_get_bytes_per_sample(AV_SAMPLE_FMT_S16);
   }
-
-  return iBytesUsed;
-}
-
-int COMXAudioCodecOMX::GetData(BYTE** dst)
-{
-  unsigned int size = 0;
-  BYTE *src = NULL;
-
-  if(m_iBufferSize1)
-  {
-    *dst = m_pFrame1->data[0];
-    src = m_pFrame1->data[0];
-    size = m_iBufferSize1;
-  }
-  if(m_iBufferSize2)
+  else
   {
-    *dst = m_pBuffer2;
-    src = m_pBuffer2;
-    size = m_iBufferSize2;
+    /* if it is already contiguous, just return decoded frame */
+    if (inputSize == outputSize)
+    {
+      *dst = m_pFrame1->data[0];
+    }
+    else
+    {
+      /* copy to a contiguous buffer */
+      uint8_t *out_planes[m_pCodecContext->channels];
+      if (m_dllAvUtil.av_samples_fill_arrays(out_planes, NULL, m_pBufferOutput, m_pCodecContext->channels, m_pFrame1->nb_samples, m_desiredSampleFormat, 1) < 0 ||
+        m_dllAvUtil.av_samples_copy(out_planes, m_pFrame1->data, 0, 0, m_pFrame1->nb_samples, m_pCodecContext->channels, m_desiredSampleFormat) < 0 )
+      {
+        outputSize = 0;
+      }
+    }
   }
 
-  if(m_pCodecContext->channels > 4 && size)
+  if (m_bFirstFrame)
   {
-    unsigned int m_frameSize = (CAEUtil::DataFormatToBits(AE_FMT_S16LE) >> 3) * m_pCodecContext->channels;
-    unsigned int frames = size / m_frameSize;
-
-    memset(m_pBufferUpmix, 0, MAX_AUDIO_FRAME_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);
-
-    Upmix(src, m_pCodecContext->channels, m_pBufferUpmix, 8, frames, AE_FMT_S16LE);
-
-    m_iBufferUpmixSize = frames * 8 * (CAEUtil::DataFormatToBits(AE_FMT_S16LE) >> 3);
-
-    *dst = m_pBufferUpmix;
-    size = m_iBufferUpmixSize;
+    CLog::Log(LOGDEBUG, "COMXAudioCodecOMX::GetData size=%d/%d cont=%d buf=%p", inputSize, outputSize, inputSize == outputSize, *dst);
+    m_bFirstFrame = false;
   }
-
-  return size;
+  return outputSize;
 }
 
 void COMXAudioCodecOMX::Reset()
 {
   if (m_pCodecContext) m_dllAvCodec.avcodec_flush_buffers(m_pCodecContext);
-  m_iBufferSize1 = 0;
-  m_iBufferSize2 = 0;
-  m_iBuffered = 0;
+  m_bGotFrame = false;
 }
 
 int COMXAudioCodecOMX::GetChannels()
 {
-  return (m_pCodecContext->channels > 4) ? 8 : m_pCodecContext->channels;
+  if (!m_pCodecContext)
+    return 0;
+  return m_pCodecContext->channels;
 }
 
 int COMXAudioCodecOMX::GetSampleRate()
 {
-  if (m_pCodecContext) return m_pCodecContext->sample_rate;
-  return 0;
+  if (!m_pCodecContext)
+    return 0;
+  return m_pCodecContext->sample_rate;
 }
 
 int COMXAudioCodecOMX::GetBitsPerSample()
 {
-  return 16;
+  if (!m_pCodecContext)
+    return 0;
+  return m_pCodecContext->sample_fmt == AV_SAMPLE_FMT_S16 ? 16 : 32;
 }
 
 int COMXAudioCodecOMX::GetBitRate()
 {
-  if (m_pCodecContext) return m_pCodecContext->bit_rate;
-  return 0;
+  if (!m_pCodecContext)
+    return 0;
+  return m_pCodecContext->bit_rate;
 }
 
 static unsigned count_bits(int64_t value)
@@ -323,16 +292,9 @@
   return bits;
 }
 
-void COMXAudioCodecOMX::BuildChannelMap()
+uint64_t COMXAudioCodecOMX::GetChannelMap()
 {
-  if (m_channels == m_pCodecContext->channels && m_layout == m_pCodecContext->channel_layout)
-    return; //nothing to do here
-
-  m_channels = m_pCodecContext->channels;
-  m_layout   = m_pCodecContext->channel_layout;
-
-  int64_t layout;
-
+  uint64_t layout;
   int bits = count_bits(m_pCodecContext->channel_layout);
   if (bits == m_pCodecContext->channels)
     layout = m_pCodecContext->channel_layout;
@@ -341,38 +303,5 @@
     CLog::Log(LOGINFO, "COMXAudioCodecOMX::GetChannelMap - FFmpeg reported %d channels, but the layout contains %d ignoring", m_pCodecContext->channels, bits);
     layout = m_dllAvUtil.av_get_default_channel_layout(m_pCodecContext->channels);
   }
-
-  m_channelLayout.Reset();
-
-  if (layout & AV_CH_FRONT_LEFT           ) m_channelLayout += AE_CH_FL  ;
-  if (layout & AV_CH_FRONT_RIGHT          ) m_channelLayout += AE_CH_FR  ;
-  if (layout & AV_CH_FRONT_CENTER         ) m_channelLayout += AE_CH_FC  ;
-  if (layout & AV_CH_LOW_FREQUENCY        ) m_channelLayout += AE_CH_LFE ;
-  if (layout & AV_CH_BACK_LEFT            ) m_channelLayout += AE_CH_BL  ;
-  if (layout & AV_CH_BACK_RIGHT           ) m_channelLayout += AE_CH_BR  ;
-  if (layout & AV_CH_FRONT_LEFT_OF_CENTER ) m_channelLayout += AE_CH_FLOC;
-  if (layout & AV_CH_FRONT_RIGHT_OF_CENTER) m_channelLayout += AE_CH_FROC;
-  if (layout & AV_CH_BACK_CENTER          ) m_channelLayout += AE_CH_BC  ;
-  if (layout & AV_CH_SIDE_LEFT            ) m_channelLayout += AE_CH_SL  ;
-  if (layout & AV_CH_SIDE_RIGHT           ) m_channelLayout += AE_CH_SR  ;
-  if (layout & AV_CH_TOP_CENTER           ) m_channelLayout += AE_CH_TC  ;
-  if (layout & AV_CH_TOP_FRONT_LEFT       ) m_channelLayout += AE_CH_TFL ;
-  if (layout & AV_CH_TOP_FRONT_CENTER     ) m_channelLayout += AE_CH_TFC ;
-  if (layout & AV_CH_TOP_FRONT_RIGHT      ) m_channelLayout += AE_CH_TFR ;
-  if (layout & AV_CH_TOP_BACK_LEFT        ) m_channelLayout += AE_CH_BL  ;
-  if (layout & AV_CH_TOP_BACK_CENTER      ) m_channelLayout += AE_CH_BC  ;
-  if (layout & AV_CH_TOP_BACK_RIGHT       ) m_channelLayout += AE_CH_BR  ;
-
-  //terminate the channel map
-  if(m_pCodecContext->channels > 4)
-  {
-    for(int i = m_pCodecContext->channels; i < 8; i++)
-      m_channelLayout += AE_CH_RAW;
-  }
-}
-
-CAEChannelInfo COMXAudioCodecOMX::GetChannelMap()
-{
-  BuildChannelMap();
-  return m_channelLayout;
+  return layout;
 }
diff -ur a/xbmc/cores/omxplayer/OMXAudioCodecOMX.h b/xbmc/cores/omxplayer/OMXAudioCodecOMX.h
--- a/xbmc/cores/omxplayer/OMXAudioCodecOMX.h	2015-03-12 20:52:41.090096999 +0100
+++ b/xbmc/cores/omxplayer/OMXAudioCodecOMX.h	2015-03-12 20:48:25.162096999 +0100
@@ -32,8 +32,6 @@
 class COMXAudioCodecOMX
 {
 public:
-  void Upmix(void *input, unsigned int channelsInput,  void *output,
-    unsigned int channelsOutput, unsigned int frames, AEDataFormat dataFormat);
   COMXAudioCodecOMX();
   virtual ~COMXAudioCodecOMX();
   bool Open(CDVDStreamInfo &hints);
@@ -42,37 +40,30 @@
   int GetData(BYTE** dst);
   void Reset();
   int GetChannels();
-  virtual CAEChannelInfo GetChannelMap();
+  uint64_t GetChannelMap();
   int GetSampleRate();
   int GetBitsPerSample();
-  const char* GetName() { return "FFmpeg"; }
-  int GetBufferSize() { return m_iBuffered; }
+  static const char* GetName() { return "FFmpeg"; }
   int GetBitRate();
 
 protected:
   AVCodecContext* m_pCodecContext;
   SwrContext*     m_pConvert;
   enum AVSampleFormat m_iSampleFormat;
-  CAEChannelInfo      m_channelLayout;
+  enum AVSampleFormat m_desiredSampleFormat;
 
   AVFrame* m_pFrame1;
-  int   m_iBufferSize1;
 
-  BYTE *m_pBuffer2;
-  int   m_iBufferSize2;
-
-  BYTE *m_pBufferUpmix;
-  int   m_iBufferUpmixSize;
+  BYTE *m_pBufferOutput;
+  int   m_iBufferOutputAlloced;
 
   bool m_bOpenedCodec;
-  int m_iBuffered;
 
   int     m_channels;
-  uint64_t m_layout;
 
+  bool m_bFirstFrame;
+  bool m_bGotFrame;
   DllAvCodec m_dllAvCodec;
   DllAvUtil m_dllAvUtil;
   DllSwResample m_dllSwResample;
-
-  void BuildChannelMap();
 };
diff -ur a/xbmc/cores/omxplayer/OMXAudio.cpp b/xbmc/cores/omxplayer/OMXAudio.cpp
--- a/xbmc/cores/omxplayer/OMXAudio.cpp	2015-03-12 20:52:41.090096999 +0100
+++ b/xbmc/cores/omxplayer/OMXAudio.cpp	2015-03-12 20:48:25.162096999 +0100
@@ -36,56 +36,18 @@
 #include "settings/Settings.h"
 #include "guilib/LocalizeStrings.h"
 #include "cores/AudioEngine/Utils/AEConvert.h"
+#include "cores/AudioEngine/AEFactory.h"
 
 using namespace std;
 
-#define OMX_MAX_CHANNELS 10
-
-static enum AEChannel OMXChannelMap[OMX_MAX_CHANNELS] = 
-{
-  AE_CH_FL      , AE_CH_FR, 
-  AE_CH_FC      , AE_CH_LFE, 
-  AE_CH_BL      , AE_CH_BR,
-  AE_CH_SL      , AE_CH_SR,
-  AE_CH_BC      , AE_CH_RAW
-};
-
-static enum OMX_AUDIO_CHANNELTYPE OMXChannels[OMX_MAX_CHANNELS] =
-{
-  OMX_AUDIO_ChannelLF, OMX_AUDIO_ChannelRF,
-  OMX_AUDIO_ChannelCF, OMX_AUDIO_ChannelLFE,
-  OMX_AUDIO_ChannelLR, OMX_AUDIO_ChannelRR,
-  OMX_AUDIO_ChannelLS, OMX_AUDIO_ChannelRS,
-  OMX_AUDIO_ChannelCS, OMX_AUDIO_ChannelNone
-};
-
-static unsigned int WAVEChannels[OMX_MAX_CHANNELS] =
-{
-  SPEAKER_FRONT_LEFT,       SPEAKER_FRONT_RIGHT,
-  SPEAKER_TOP_FRONT_CENTER, SPEAKER_LOW_FREQUENCY,
-  SPEAKER_BACK_LEFT,        SPEAKER_BACK_RIGHT,
-  SPEAKER_SIDE_LEFT,        SPEAKER_SIDE_RIGHT,
-  SPEAKER_BACK_CENTER,      SPEAKER_SIDE_RIGHT
-};
+// the size of the audio_render output port buffers
+#define AUDIO_DECODE_OUTPUT_BUFFER (32*1024)
 
 static const uint16_t AC3Bitrates[] = {32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 448, 512, 576, 640};
 static const uint16_t AC3FSCod   [] = {48000, 44100, 32000, 0};
 
 static const uint16_t DTSFSCod   [] = {0, 8000, 16000, 32000, 0, 0, 11025, 22050, 44100, 0, 0, 12000, 24000, 48000, 0, 0};
 
-// 7.1 downmixing coefficients
-const float downmixing_coefficients_8[OMX_AUDIO_MAXCHANNELS] = {
-  //        L       R
-  /* L */   1,      0,
-  /* R */   0,      1,
-  /* C */   0.7071, 0.7071,
-  /* LFE */ 0.7071, 0.7071,
-  /* Ls */  0.7071, 0,
-  /* Rs */  0,      0.7071,
-  /* Lr */  0.7071, 0,
-  /* Rr */  0,      0.7071
-};
-
 //////////////////////////////////////////////////////////////////////
 // Construction/Destruction
 //////////////////////////////////////////////////////////////////////
@@ -93,30 +55,41 @@
 COMXAudio::COMXAudio() :
   m_pCallback       (NULL   ),
   m_Initialized     (false  ),
-  m_Pause           (false  ),
-  m_CanPause        (false  ),
   m_CurrentVolume   (0      ),
+  m_Mute            (false  ),
+  m_drc             (0      ),
   m_Passthrough     (false  ),
   m_HWDecode        (false  ),
   m_BytesPerSec     (0      ),
   m_BufferLen       (0      ),
   m_ChunkLen        (0      ),
+  m_InputChannels   (0      ),
   m_OutputChannels  (0      ),
   m_BitsPerSample   (0      ),
+  m_maxLevel        (0.0f   ),
+  m_amplification   (1.0f   ),
+  m_attenuation     (1.0f   ),
+  m_submitted       (0.0f   ),
   m_omx_clock       (NULL   ),
   m_av_clock        (NULL   ),
-  m_first_frame     (true   ),
+  m_settings_changed(false  ),
+  m_setStartTime    (false  ),
   m_LostSync        (true   ),
   m_SampleRate      (0      ),
   m_eEncoding       (OMX_AUDIO_CodingPCM),
   m_extradata       (NULL   ),
   m_extrasize       (0      ),
   m_last_pts        (DVD_NOPTS_VALUE),
-  m_omx_render      (NULL   )
+  m_submitted_eos   (false  ),
+  m_failed_eos      (false  )
 {
   m_vizBufferSize   = m_vizRemapBufferSize = VIS_PACKET_SIZE * sizeof(float);
   m_vizRemapBuffer  = (uint8_t *)_aligned_malloc(m_vizRemapBufferSize,16);
   m_vizBuffer       = (uint8_t *)_aligned_malloc(m_vizBufferSize,16);
+
+  CAEFactory::Suspend();
+  while (!CAEFactory::IsSuspended())
+    Sleep(10);
 }
 
 COMXAudio::~COMXAudio()
@@ -125,44 +98,327 @@
 
   _aligned_free(m_vizRemapBuffer);
   _aligned_free(m_vizBuffer);
-}
 
+  CAEFactory::Resume();
+}
 
-CAEChannelInfo COMXAudio::GetChannelLayout(AEAudioFormat format)
+bool COMXAudio::PortSettingsChanged()
 {
-  unsigned int count = 0;
+  CSingleLock lock (m_critSection);
+  OMX_ERRORTYPE omx_err   = OMX_ErrorNone;
 
-  if(format.m_dataFormat == AE_FMT_AC3 ||
-    format.m_dataFormat == AE_FMT_DTS ||
-    format.m_dataFormat == AE_FMT_EAC3)
-    count = 2;
-  else if (format.m_dataFormat == AE_FMT_TRUEHD ||
-    format.m_dataFormat == AE_FMT_DTSHD)
-    count = 8;
-  else
+  if (m_settings_changed)
+  {
+    m_omx_decoder.DisablePort(m_omx_decoder.GetOutputPort(), true);
+    m_omx_decoder.EnablePort(m_omx_decoder.GetOutputPort(), true);
+    return true;
+  }
+
+  if(!m_Passthrough)
+  {
+    if(!m_omx_mixer.Initialize("OMX.broadcom.audio_mixer", OMX_IndexParamAudioInit))
+      return false;
+  }
+  if(g_guiSettings.GetBool("audiooutput.dualaudio"))
+  {
+    if(!m_omx_splitter.Initialize("OMX.broadcom.audio_splitter", OMX_IndexParamAudioInit))
+      return false;
+  }
+  if (g_guiSettings.GetBool("audiooutput.dualaudio") || g_guiSettings.GetInt("audiooutput.mode") == AUDIO_ANALOG)
+  {
+    if(!m_omx_render_analog.Initialize("OMX.broadcom.audio_render", OMX_IndexParamAudioInit))
+      return false;
+  }
+  if (g_guiSettings.GetBool("audiooutput.dualaudio") || g_guiSettings.GetInt("audiooutput.mode") == AUDIO_HDMI)
+  {
+    if(!m_omx_render_hdmi.Initialize("OMX.broadcom.audio_render", OMX_IndexParamAudioInit))
+      return false;
+  }
+
+  SetDynamicRangeCompression((long)(g_settings.m_currentVideoSettings.m_VolumeAmplification * 100));
+  UpdateAttenuation();
+
+  if( m_omx_mixer.IsInitialized() )
+  {
+    /* setup mixer output */
+    OMX_INIT_STRUCTURE(m_pcm_output);
+    m_pcm_output.nPortIndex = m_omx_decoder.GetOutputPort();
+    omx_err = m_omx_decoder.GetParameter(OMX_IndexParamAudioPcm, &m_pcm_output);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - error m_omx_decoder GetParameter omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+
+    memcpy(m_pcm_output.eChannelMapping, m_output_channels, sizeof(m_output_channels));
+    // round up to power of 2
+    m_pcm_output.nChannels = m_OutputChannels > 4 ? 8 : m_OutputChannels > 2 ? 4 : m_OutputChannels;
+    /* limit samplerate (through resampling) if requested */
+    m_pcm_output.nSamplingRate = std::min(std::max((int)m_pcm_output.nSamplingRate, 8000), 192000);
+
+    m_pcm_output.nPortIndex = m_omx_mixer.GetOutputPort();
+    omx_err = m_omx_mixer.SetParameter(OMX_IndexParamAudioPcm, &m_pcm_output);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - error m_omx_mixer SetParameter omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+
+    CLog::Log(LOGDEBUG, "%s::%s - Output bps %d samplerate %d channels %d buffer size %d bytes per second %d",
+        CLASSNAME, __func__, (int)m_pcm_output.nBitPerSample, (int)m_pcm_output.nSamplingRate, (int)m_pcm_output.nChannels, m_BufferLen, m_BytesPerSec);
+    PrintPCM(&m_pcm_output, std::string("output"));
+
+    if( m_omx_splitter.IsInitialized() )
+    {
+      m_pcm_output.nPortIndex = m_omx_splitter.GetInputPort();
+      omx_err = m_omx_splitter.SetParameter(OMX_IndexParamAudioPcm, &m_pcm_output);
+      if(omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s - error m_omx_splitter SetParameter omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+        return false;
+      }
+
+      m_pcm_output.nPortIndex = m_omx_splitter.GetOutputPort();
+      omx_err = m_omx_splitter.SetParameter(OMX_IndexParamAudioPcm, &m_pcm_output);
+      if(omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s - error m_omx_splitter SetParameter omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+        return false;
+      }
+      m_pcm_output.nPortIndex = m_omx_splitter.GetOutputPort() + 1;
+      omx_err = m_omx_splitter.SetParameter(OMX_IndexParamAudioPcm, &m_pcm_output);
+      if(omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s - error m_omx_splitter SetParameter omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+        return false;
+      }
+    }
+
+    if( m_omx_render_analog.IsInitialized() )
+    {
+      m_pcm_output.nPortIndex = m_omx_render_analog.GetInputPort();
+      omx_err = m_omx_render_analog.SetParameter(OMX_IndexParamAudioPcm, &m_pcm_output);
+      if(omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s - error m_omx_render_analog SetParameter omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+        return false;
+      }
+    }
+
+    if( m_omx_render_hdmi.IsInitialized() )
+    {
+      m_pcm_output.nPortIndex = m_omx_render_hdmi.GetInputPort();
+      omx_err = m_omx_render_hdmi.SetParameter(OMX_IndexParamAudioPcm, &m_pcm_output);
+      if(omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s - error m_omx_render_hdmi SetParameter omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+        return false;
+      }
+    }
+  }
+  if( m_omx_render_analog.IsInitialized() )
+  {
+    m_omx_tunnel_clock_analog.Initialize(m_omx_clock, m_omx_clock->GetInputPort(),
+      &m_omx_render_analog, m_omx_render_analog.GetInputPort()+1);
+
+    omx_err = m_omx_tunnel_clock_analog.Establish();
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - m_omx_tunnel_clock_analog.Establish omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+    m_omx_render_analog.ResetEos();
+  }
+  if( m_omx_render_hdmi.IsInitialized() )
+  {
+    m_omx_tunnel_clock_hdmi.Initialize(m_omx_clock, m_omx_clock->GetInputPort() + (m_omx_render_analog.IsInitialized() ? 2 : 0),
+      &m_omx_render_hdmi, m_omx_render_hdmi.GetInputPort()+1);
+
+    omx_err = m_omx_tunnel_clock_hdmi.Establish();
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - m_omx_tunnel_clock_hdmi.Establish omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+    m_omx_render_hdmi.ResetEos();
+  }
+
+  if( m_omx_render_analog.IsInitialized() )
+  {
+    // By default audio_render is the clock master, and if output samples don't fit the timestamps, it will speed up/slow down the clock.
+    // This tends to be better for maintaining audio sync and avoiding audio glitches, but can affect video/display sync
+    if(g_guiSettings.GetBool("videoplayer.usedisplayasclock"))
+    {
+      OMX_CONFIG_BOOLEANTYPE configBool;
+      OMX_INIT_STRUCTURE(configBool);
+      configBool.bEnabled = OMX_FALSE;
+
+      omx_err = m_omx_render_analog.SetConfig(OMX_IndexConfigBrcmClockReferenceSource, &configBool);
+      if (omx_err != OMX_ErrorNone)
+         return false;
+    }
+
+    OMX_CONFIG_BRCMAUDIODESTINATIONTYPE audioDest;
+    OMX_INIT_STRUCTURE(audioDest);
+    strncpy((char *)audioDest.sName, "local", strlen("local"));
+    omx_err = m_omx_render_analog.SetConfig(OMX_IndexConfigBrcmAudioDestination, &audioDest);
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - m_omx_render_analog.SetConfig omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+  }
+
+  if( m_omx_render_hdmi.IsInitialized() )
+  {
+    // By default audio_render is the clock master, and if output samples don't fit the timestamps, it will speed up/slow down the clock.
+    // This tends to be better for maintaining audio sync and avoiding audio glitches, but can affect video/display sync
+    if(g_guiSettings.GetBool("videoplayer.usedisplayasclock"))
+    {
+      OMX_CONFIG_BOOLEANTYPE configBool;
+      OMX_INIT_STRUCTURE(configBool);
+      configBool.bEnabled = OMX_FALSE;
+
+      omx_err = m_omx_render_hdmi.SetConfig(OMX_IndexConfigBrcmClockReferenceSource, &configBool);
+      if (omx_err != OMX_ErrorNone)
+         return false;
+    }
+
+    OMX_CONFIG_BRCMAUDIODESTINATIONTYPE audioDest;
+    OMX_INIT_STRUCTURE(audioDest);
+    strncpy((char *)audioDest.sName, "hdmi", strlen("hdmi"));
+    omx_err = m_omx_render_hdmi.SetConfig(OMX_IndexConfigBrcmAudioDestination, &audioDest);
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - m_omx_render_hdmi.SetConfig omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+  }
+
+  if( m_omx_splitter.IsInitialized() )
+  {
+    m_omx_tunnel_splitter_analog.Initialize(&m_omx_splitter, m_omx_splitter.GetOutputPort(), &m_omx_render_analog, m_omx_render_analog.GetInputPort());
+    omx_err = m_omx_tunnel_splitter_analog.Establish();
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "COMXAudio::Initialize - Error m_omx_tunnel_splitter_analog.Establish 0x%08x", omx_err);
+      return false;
+    }
+
+    m_omx_tunnel_splitter_hdmi.Initialize(&m_omx_splitter, m_omx_splitter.GetOutputPort() + 1, &m_omx_render_hdmi, m_omx_render_hdmi.GetInputPort());
+    omx_err = m_omx_tunnel_splitter_hdmi.Establish();
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "COMXAudio::Initialize - Error m_omx_tunnel_splitter_hdmi.Establish 0x%08x", omx_err);
+      return false;
+    }
+  }
+  if( m_omx_mixer.IsInitialized() )
   {
-    for (unsigned int c = 0; c < 8; ++c)
+    m_omx_tunnel_decoder.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_mixer, m_omx_mixer.GetInputPort());
+    if( m_omx_splitter.IsInitialized() )
     {
-      for (unsigned int i = 0; i < format.m_channelLayout.Count(); ++i)
+      m_omx_tunnel_mixer.Initialize(&m_omx_mixer, m_omx_mixer.GetOutputPort(), &m_omx_splitter, m_omx_splitter.GetInputPort());
+    }
+    else
+    {
+      if( m_omx_render_analog.IsInitialized() )
+      {
+        m_omx_tunnel_mixer.Initialize(&m_omx_mixer, m_omx_mixer.GetOutputPort(), &m_omx_render_analog, m_omx_render_analog.GetInputPort());
+      }
+      if( m_omx_render_hdmi.IsInitialized() )
       {
-        if (format.m_channelLayout[i] == OMXChannelMap[c])
-        {
-          count = c + 1;
-          break;
-        }
+        m_omx_tunnel_mixer.Initialize(&m_omx_mixer, m_omx_mixer.GetOutputPort(), &m_omx_render_hdmi, m_omx_render_hdmi.GetInputPort());
       }
     }
+    CLog::Log(LOGDEBUG, "%s::%s - bits:%d mode:%d channels:%d srate:%d nopassthrough", CLASSNAME, __func__,
+            (int)m_pcm_input.nBitPerSample, m_pcm_input.ePCMMode, (int)m_pcm_input.nChannels, (int)m_pcm_input.nSamplingRate);
+  }
+  else
+  {
+    if( m_omx_render_analog.IsInitialized() )
+    {
+      m_omx_tunnel_decoder.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_render_analog, m_omx_render_analog.GetInputPort());
+    }
+    else if( m_omx_render_hdmi.IsInitialized() )
+    {
+      m_omx_tunnel_decoder.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_render_hdmi, m_omx_render_hdmi.GetInputPort());
+    }
+    CLog::Log(LOGDEBUG, "%s::%s - bits:%d mode:%d channels:%d srate:%d passthrough", CLASSNAME, __func__,
+            0, 0, 0, 0);
+  }
+
+  omx_err = m_omx_tunnel_decoder.Establish();
+  if(omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - m_omx_tunnel_decoder.Establish omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  if( m_omx_mixer.IsInitialized() )
+  {
+    omx_err = m_omx_mixer.SetStateForComponent(OMX_StateExecuting);
+    if(omx_err != OMX_ErrorNone) {
+      CLog::Log(LOGERROR, "%s::%s - m_omx_mixer OMX_StateExecuting omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+  }
+
+  if( m_omx_mixer.IsInitialized() )
+  {
+    omx_err = m_omx_tunnel_mixer.Establish();
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - m_omx_tunnel_decoder.Establish omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+  }
+
+  if( m_omx_splitter.IsInitialized() )
+  {
+    omx_err = m_omx_splitter.SetStateForComponent(OMX_StateExecuting);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - m_omx_splitter OMX_StateExecuting 0x%08x", CLASSNAME, __func__, omx_err);
+     return false;
+    }
+  }
+  if( m_omx_render_analog.IsInitialized() )
+  {
+    omx_err = m_omx_render_analog.SetStateForComponent(OMX_StateExecuting);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - m_omx_render_analog OMX_StateExecuting omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+  }
+  if( m_omx_render_hdmi.IsInitialized() )
+  {
+    omx_err = m_omx_render_hdmi.SetStateForComponent(OMX_StateExecuting);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - m_omx_render_hdmi OMX_StateExecuting omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
   }
 
-  CAEChannelInfo info;
-  for (unsigned int i = 0; i < count; ++i)
-    info += OMXChannelMap[i];
+  m_settings_changed = true;
+  return true;
+}
 
-  return info;
+static unsigned count_bits(int64_t value)
+{
+  unsigned bits = 0;
+  for(;value;++bits)
+    value &= value - 1;
+  return bits;
 }
 
-bool COMXAudio::Initialize(AEAudioFormat format, std::string& device, OMXClock *clock, CDVDStreamInfo &hints, bool bUsePassthrough, bool bUseHWDecode)
+bool COMXAudio::Initialize(AEAudioFormat format, OMXClock *clock, CDVDStreamInfo &hints, uint64_t channelMap, bool bUsePassthrough, bool bUseHWDecode)
 {
+  CSingleLock lock (m_critSection);
+  OMX_ERRORTYPE omx_err;
+
   Deinitialize();
 
   if(!m_dllAvUtil.Load())
@@ -171,9 +427,10 @@
   m_HWDecode    = bUseHWDecode;
   m_Passthrough = bUsePassthrough;
 
+  m_InputChannels = count_bits(channelMap);
   m_format = format;
 
-  if(m_format.m_channelLayout.Count() == 0)
+  if(m_InputChannels == 0)
     return false;
 
   if(hints.samplerate == 0)
@@ -211,155 +468,69 @@
   memset(m_output_channels, 0x0, sizeof(m_output_channels));
   memset(&m_wave_header, 0x0, sizeof(m_wave_header));
 
-  for(int i = 0; i < OMX_AUDIO_MAXCHANNELS; i++)
-    m_pcm_input.eChannelMapping[i] = OMX_AUDIO_ChannelNone;
-
-  m_output_channels[0] = OMX_AUDIO_ChannelLF;
-  m_output_channels[1] = OMX_AUDIO_ChannelRF;
-  m_output_channels[2] = OMX_AUDIO_ChannelMax;
-
-  m_input_channels[0] = OMX_AUDIO_ChannelLF;
-  m_input_channels[1] = OMX_AUDIO_ChannelRF;
-  m_input_channels[2] = OMX_AUDIO_ChannelMax;
-
-  m_OutputChannels                = 2;
-  m_wave_header.Format.nChannels  = m_OutputChannels;
+  m_wave_header.Format.nChannels  = 2;
   m_wave_header.dwChannelMask     = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT;
 
   if (!m_Passthrough)
   {
-    /* setup output channel map */
-    /*
-    int ch = 0, map;
-    int chan = 0;
-    m_OutputChannels = 0;
-
-    for (unsigned int ch = 0; ch < m_format.m_channelLayout.Count(); ++ch)
-    {
-      for(map = 0; map < OMX_MAX_CHANNELS; ++map)
-      {
-        if (m_output_channels[ch] == OMXChannelMap[map])
-        {
-          printf("output %d\n", chan);
-          m_output_channels[chan] = OMXChannels[map]; 
-          chan++;
-          break;
-        }
-      }
-    }
-
-    m_OutputChannels = chan;
-    */
-
-    /* setup input channel map */
-    int map = 0;
-    int chan = 0;
-
-    for (unsigned int ch = 0; ch < m_format.m_channelLayout.Count(); ++ch)
-    {
-      for(map = 0; map < OMX_MAX_CHANNELS; ++map)
-      {
-        if (m_format.m_channelLayout[ch] == OMXChannelMap[map])
-        {
-          m_input_channels[chan] = OMXChannels[map]; 
-          m_wave_header.dwChannelMask |= WAVEChannels[map];
-          chan++;
-          break;
-        }
-      }
-    }
+    enum PCMChannels inLayout[OMX_AUDIO_MAXCHANNELS];
+    enum PCMChannels outLayout[OMX_AUDIO_MAXCHANNELS];
+    enum PCMLayout layout = (enum PCMLayout)std::max(0, g_guiSettings.GetInt("audiooutput.channels")-1);
+
+    // ignore layout setting for analogue
+    if (g_guiSettings.GetBool("audiooutput.dualaudio") || g_guiSettings.GetInt("audiooutput.mode") == AUDIO_ANALOG)
+      layout = PCM_LAYOUT_2_0;
+
+    // force out layout to stereo if input is not multichannel - it gives the receiver a chance to upmix
+    if (channelMap == (AV_CH_FRONT_LEFT | AV_CH_FRONT_RIGHT) || channelMap == AV_CH_FRONT_CENTER)
+      layout = PCM_LAYOUT_2_0;
+    BuildChannelMap(inLayout, channelMap);
+    m_OutputChannels = BuildChannelMapCEA(outLayout, GetChannelLayout(layout));
+    CPCMRemap m_remap;
+    m_remap.Reset();
+    /*outLayout = */m_remap.SetInputFormat (m_InputChannels, inLayout, CAEUtil::DataFormatToBits(m_format.m_dataFormat) / 8, m_format.m_sampleRate, layout);
+    m_remap.SetOutputFormat(m_OutputChannels, outLayout);
+    m_remap.GetDownmixMatrix(m_downmix_matrix);
+    m_wave_header.dwChannelMask = channelMap;
+    BuildChannelMapOMX(m_input_channels, channelMap);
+    BuildChannelMapOMX(m_output_channels, GetChannelLayout(layout));
 
-    m_vizRemap.Initialize(m_format.m_channelLayout, CAEChannelInfo(AE_CH_LAYOUT_2_0), false, true);
+    m_vizRemap.Initialize(GetAEChannelLayout(channelMap), CAEChannelInfo(AE_CH_LAYOUT_2_0), false, true);
   }
 
-  OMX_INIT_STRUCTURE(m_pcm_output);
-  OMX_INIT_STRUCTURE(m_pcm_input);
-
-  memcpy(m_pcm_output.eChannelMapping, m_output_channels, sizeof(m_output_channels));
-  memcpy(m_pcm_input.eChannelMapping, m_input_channels, sizeof(m_input_channels));
-
-  // set the m_pcm_output parameters
-  m_pcm_output.eNumData            = OMX_NumericalDataSigned;
-  m_pcm_output.eEndian             = OMX_EndianLittle;
-  m_pcm_output.bInterleaved        = OMX_TRUE;
-  m_pcm_output.nBitPerSample       = CAEUtil::DataFormatToBits(m_format.m_dataFormat);
-  m_pcm_output.ePCMMode            = OMX_AUDIO_PCMModeLinear;
-  m_pcm_output.nChannels           = m_OutputChannels;
-  m_pcm_output.nSamplingRate       = m_format.m_sampleRate;
-
   m_SampleRate    = m_format.m_sampleRate;
   m_BitsPerSample = CAEUtil::DataFormatToBits(m_format.m_dataFormat);
-  m_BufferLen     = m_BytesPerSec = m_format.m_sampleRate * 
-    (CAEUtil::DataFormatToBits(m_format.m_dataFormat) >> 3) * 
-    m_format.m_channelLayout.Count();
+  m_BufferLen     = m_BytesPerSec = m_format.m_sampleRate * (16 >> 3) * m_InputChannels;
   m_BufferLen     *= AUDIO_BUFFER_SECONDS;
-  m_ChunkLen      = 6144;
+  // the audio_decode output buffer size is 32K, and typically we convert from
+  // 6 channel 32bpp float to 8 channel 16bpp in, so a full 48K input buffer will fit the outbut buffer
+  m_ChunkLen      = AUDIO_DECODE_OUTPUT_BUFFER * 2 * 6 / 8;
 
   m_wave_header.Samples.wSamplesPerBlock    = 0;
-  m_wave_header.Format.nChannels            = m_format.m_channelLayout.Count();
-  m_wave_header.Format.nBlockAlign          = m_format.m_channelLayout.Count() * 
-    (CAEUtil::DataFormatToBits(m_format.m_dataFormat) >> 3);
-  m_wave_header.Format.wFormatTag           = WAVE_FORMAT_PCM;
+  m_wave_header.Format.nChannels            = m_InputChannels;
+  m_wave_header.Format.nBlockAlign          = m_InputChannels * (m_BitsPerSample >> 3);
+  // 0x8000 is custom format interpreted by GPU as WAVE_FORMAT_IEEE_FLOAT_PLANAR
+  m_wave_header.Format.wFormatTag           = m_BitsPerSample == 32 ? 0x8000 : WAVE_FORMAT_PCM;
   m_wave_header.Format.nSamplesPerSec       = m_format.m_sampleRate;
   m_wave_header.Format.nAvgBytesPerSec      = m_BytesPerSec;
-  m_wave_header.Format.wBitsPerSample       = CAEUtil::DataFormatToBits(m_format.m_dataFormat);
-  m_wave_header.Samples.wValidBitsPerSample = CAEUtil::DataFormatToBits(m_format.m_dataFormat);
+  m_wave_header.Format.wBitsPerSample       = m_BitsPerSample;
+  m_wave_header.Samples.wValidBitsPerSample = m_BitsPerSample;
   m_wave_header.Format.cbSize               = 0;
   m_wave_header.SubFormat                   = KSDATAFORMAT_SUBTYPE_PCM;
 
+  OMX_INIT_STRUCTURE(m_pcm_input);
+  memcpy(m_pcm_input.eChannelMapping, m_input_channels, sizeof(m_input_channels));
   m_pcm_input.eNumData              = OMX_NumericalDataSigned;
   m_pcm_input.eEndian               = OMX_EndianLittle;
   m_pcm_input.bInterleaved          = OMX_TRUE;
-  m_pcm_input.nBitPerSample         = CAEUtil::DataFormatToBits(m_format.m_dataFormat);
+  m_pcm_input.nBitPerSample         = m_BitsPerSample;
   m_pcm_input.ePCMMode              = OMX_AUDIO_PCMModeLinear;
-  m_pcm_input.nChannels             = m_format.m_channelLayout.Count();
+  m_pcm_input.nChannels             = m_InputChannels;
   m_pcm_input.nSamplingRate         = m_format.m_sampleRate;
 
-  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-  std::string componentName = "";
-
-  componentName = "OMX.broadcom.audio_render";
-
-  if(!m_omx_render)
-    m_omx_render = new COMXCoreComponent();
-  if(!m_omx_render)
-  {
-    CLog::Log(LOGERROR, "COMXAudio::Initialize error allocate OMX.broadcom.audio_render\n");
-    return false;
-  }
-
-  if(!m_omx_render->Initialize((const std::string)componentName, OMX_IndexParamAudioInit))
-    return false;
-
-  m_omx_render->ResetEos();
-
-  OMX_CONFIG_BRCMAUDIODESTINATIONTYPE audioDest;
-  OMX_INIT_STRUCTURE(audioDest);
-  strncpy((char *)audioDest.sName, device.c_str(), strlen(device.c_str()));
-
-  omx_err = m_omx_render->SetConfig(OMX_IndexConfigBrcmAudioDestination, &audioDest);
-  if (omx_err != OMX_ErrorNone)
-    return false;
-
-  OMX_CONFIG_BOOLEANTYPE configBool;
-  OMX_INIT_STRUCTURE(configBool);
-  configBool.bEnabled = OMX_FALSE;
-
-  omx_err = m_omx_render->SetConfig(OMX_IndexConfigBrcmClockReferenceSource, &configBool);
-  if (omx_err != OMX_ErrorNone)
+  if(!m_omx_decoder.Initialize("OMX.broadcom.audio_decode", OMX_IndexParamAudioInit))
     return false;
 
-  componentName = "OMX.broadcom.audio_decode";
-  if(!m_omx_decoder.Initialize((const std::string)componentName, OMX_IndexParamAudioInit))
-    return false;
-
-  if(!m_Passthrough)
-  {
-    componentName = "OMX.broadcom.audio_mixer";
-    if(!m_omx_mixer.Initialize((const std::string)componentName, OMX_IndexParamAudioInit))
-      return false;
-  }
-
   OMX_CONFIG_BOOLEANTYPE boolType;
   OMX_INIT_STRUCTURE(boolType);
   if(m_Passthrough)
@@ -373,7 +544,7 @@
     return false;
   }
 
-  // set up the number/size of buffers
+  // set up the number/size of buffers for decoder input
   OMX_PARAM_PORTDEFINITIONTYPE port_param;
   OMX_INIT_STRUCTURE(port_param);
   port_param.nPortIndex = m_omx_decoder.GetInputPort();
@@ -381,23 +552,42 @@
   omx_err = m_omx_decoder.GetParameter(OMX_IndexParamPortDefinition, &port_param);
   if(omx_err != OMX_ErrorNone)
   {
-    CLog::Log(LOGERROR, "COMXAudio::Initialize error get OMX_IndexParamPortDefinition omx_err(0x%08x)\n", omx_err);
+    CLog::Log(LOGERROR, "COMXAudio::Initialize error get OMX_IndexParamPortDefinition (input) omx_err(0x%08x)\n", omx_err);
     return false;
   }
 
   port_param.format.audio.eEncoding = m_eEncoding;
 
   port_param.nBufferSize = m_ChunkLen;
-  port_param.nBufferCountActual = m_BufferLen / m_ChunkLen;
+  port_param.nBufferCountActual = std::max((unsigned int)port_param.nBufferCountMin, 16U);
 
   omx_err = m_omx_decoder.SetParameter(OMX_IndexParamPortDefinition, &port_param);
   if(omx_err != OMX_ErrorNone)
   {
-    CLog::Log(LOGERROR, "COMXAudio::Initialize error set OMX_IndexParamPortDefinition omx_err(0x%08x)\n", omx_err);
+    CLog::Log(LOGERROR, "COMXAudio::Initialize error set OMX_IndexParamPortDefinition (intput) omx_err(0x%08x)\n", omx_err);
+    return false;
+  }
+
+  // set up the number/size of buffers for decoder output
+  OMX_INIT_STRUCTURE(port_param);
+  port_param.nPortIndex = m_omx_decoder.GetOutputPort();
+
+  omx_err = m_omx_decoder.GetParameter(OMX_IndexParamPortDefinition, &port_param);
+  if(omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "COMXAudio::Initialize error get OMX_IndexParamPortDefinition (output) omx_err(0x%08x)\n", omx_err);
+    return false;
+  }
+
+  port_param.nBufferCountActual = std::max((unsigned int)port_param.nBufferCountMin, m_BufferLen / port_param.nBufferSize);
+
+  omx_err = m_omx_decoder.SetParameter(OMX_IndexParamPortDefinition, &port_param);
+  if(omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "COMXAudio::Initialize error set OMX_IndexParamPortDefinition (output) omx_err(0x%08x)\n", omx_err);
     return false;
   }
 
-  //if(m_HWDecode)
   {
     OMX_AUDIO_PARAM_PORTFORMATTYPE formatType;
     OMX_INIT_STRUCTURE(formatType);
@@ -413,15 +603,6 @@
     }
   }
 
-  m_omx_tunnel_clock.Initialize(m_omx_clock, m_omx_clock->GetInputPort(), m_omx_render, m_omx_render->GetInputPort()+1);
-
-  omx_err = m_omx_tunnel_clock.Establish(false);
-  if(omx_err != OMX_ErrorNone)
-  {
-    CLog::Log(LOGERROR, "COMXAudio::Initialize m_omx_tunnel_clock.Establish\n");
-    return false;
-  }
-
   omx_err = m_omx_decoder.AllocInputBuffers();
   if(omx_err != OMX_ErrorNone) 
   {
@@ -429,61 +610,12 @@
     return false;
   }
 
-  if(!m_Passthrough)
-  {
-    m_omx_tunnel_decoder.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_mixer, m_omx_mixer.GetInputPort());
-    omx_err = m_omx_tunnel_decoder.Establish(false);
-    if(omx_err != OMX_ErrorNone)
-    {
-      CLog::Log(LOGERROR, "COMXAudio::Initialize - Error m_omx_tunnel_decoder.Establish 0x%08x", omx_err);
-      return false;
-    }
-  
-    omx_err = m_omx_decoder.SetStateForComponent(OMX_StateExecuting);
-    if(omx_err != OMX_ErrorNone) {
-      CLog::Log(LOGERROR, "COMXAudio::Initialize - Error setting OMX_StateExecuting 0x%08x", omx_err);
-      return false;
-    }
-
-    m_omx_tunnel_mixer.Initialize(&m_omx_mixer, m_omx_mixer.GetOutputPort(), m_omx_render, m_omx_render->GetInputPort());
-    omx_err = m_omx_tunnel_mixer.Establish(false);
-    if(omx_err != OMX_ErrorNone)
-    {
-      CLog::Log(LOGERROR, "COMXAudio::Initialize - Error m_omx_tunnel_decoder.Establish 0x%08x", omx_err);
-      return false;
-    }
-  
-    omx_err = m_omx_mixer.SetStateForComponent(OMX_StateExecuting);
-    if(omx_err != OMX_ErrorNone) {
-      CLog::Log(LOGERROR, "COMXAudio::Initialize - Error setting OMX_StateExecuting 0x%08x", omx_err);
-      return false;
-    }
-  }
-  else
-  {
-    m_omx_tunnel_decoder.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), m_omx_render, m_omx_render->GetInputPort());
-    omx_err = m_omx_tunnel_decoder.Establish(false);
-    if(omx_err != OMX_ErrorNone)
-    {
-      CLog::Log(LOGERROR, "COMXAudio::Initialize - Error m_omx_tunnel_decoder.Establish 0x%08x", omx_err);
-      return false;
-    }
-  
-    omx_err = m_omx_decoder.SetStateForComponent(OMX_StateExecuting);
-    if(omx_err != OMX_ErrorNone) {
-      CLog::Log(LOGERROR, "COMXAudio::Initialize - Error setting OMX_StateExecuting 0x%08x", omx_err);
-      return false;
-    }
-  }
-
-  omx_err = m_omx_render->SetStateForComponent(OMX_StateExecuting);
-  if(omx_err != OMX_ErrorNone) 
-  {
+  omx_err = m_omx_decoder.SetStateForComponent(OMX_StateExecuting);
+  if(omx_err != OMX_ErrorNone) {
     CLog::Log(LOGERROR, "COMXAudio::Initialize - Error setting OMX_StateExecuting 0x%08x", omx_err);
     return false;
   }
 
-  m_omx_decoder.EnablePort(m_omx_decoder.GetInputPort(), true);
 
   if(m_eEncoding == OMX_AUDIO_CodingPCM)
   {
@@ -551,15 +683,19 @@
     return false;
 
   m_Initialized   = true;
-  m_first_frame   = true;
+  m_settings_changed = false;
+  m_setStartTime = true;
+  m_submitted_eos = false;
+  m_failed_eos = false;
   m_last_pts      = DVD_NOPTS_VALUE;
+  m_submitted     = 0.0f;
+  m_maxLevel      = 0.0f;
 
-  CLog::Log(LOGDEBUG, "COMXAudio::Initialize Ouput bps %d samplerate %d channels %d buffer size %d bytes per second %d", 
-      (int)m_pcm_output.nBitPerSample, (int)m_pcm_output.nSamplingRate, (int)m_pcm_output.nChannels, m_BufferLen, m_BytesPerSec);
-  CLog::Log(LOGDEBUG, "COMXAudio::Initialize Input bps %d samplerate %d channels %d buffer size %d bytes per second %d", 
+  CLog::Log(LOGDEBUG, "COMXAudio::Initialize Input bps %d samplerate %d channels %d buffer size %d bytes per second %d",
       (int)m_pcm_input.nBitPerSample, (int)m_pcm_input.nSamplingRate, (int)m_pcm_input.nChannels, m_BufferLen, m_BytesPerSec);
-  CLog::Log(LOGDEBUG, "COMXAudio::Initialize device %s passthrough %d hwdecode %d", 
-      device.c_str(), m_Passthrough, m_HWDecode);
+  PrintPCM(&m_pcm_input, std::string("input"));
+  CLog::Log(LOGDEBUG, "COMXAudio::Initialize device passthrough %d hwdecode %d",
+     m_Passthrough, m_HWDecode);
 
   return true;
 }
@@ -569,31 +705,41 @@
 {
   CSingleLock lock (m_critSection);
 
-  m_omx_tunnel_decoder.Flush();
-  if(!m_Passthrough)
-    m_omx_tunnel_mixer.Flush();
-  m_omx_tunnel_clock.Flush();
-
-  m_omx_tunnel_clock.Deestablish();
-  if(!m_Passthrough)
+  if ( m_omx_tunnel_clock_analog.IsInitialized() )
+    m_omx_tunnel_clock_analog.Deestablish();
+  if ( m_omx_tunnel_clock_hdmi.IsInitialized() )
+    m_omx_tunnel_clock_hdmi.Deestablish();
+
+  // ignore expected errors on teardown
+  if ( m_omx_mixer.IsInitialized() )
+    m_omx_mixer.IgnoreNextError(OMX_ErrorPortUnpopulated);
+  else
   {
-    // workaround for the strange BCM mixer component
-    if(m_omx_mixer.GetState() == OMX_StateExecuting)
-      m_omx_mixer.SetStateForComponent(OMX_StatePause);
-    if(m_omx_mixer.GetState() != OMX_StateIdle)
-      m_omx_mixer.SetStateForComponent(OMX_StateIdle);
-    m_omx_mixer.DisableAllPorts();
-    m_omx_tunnel_mixer.Deestablish(true);
+    if ( m_omx_render_hdmi.IsInitialized() )
+      m_omx_render_hdmi.IgnoreNextError(OMX_ErrorPortUnpopulated);
+    if ( m_omx_render_analog.IsInitialized() )
+      m_omx_render_analog.IgnoreNextError(OMX_ErrorPortUnpopulated);
   }
+
   m_omx_tunnel_decoder.Deestablish();
+  if ( m_omx_tunnel_mixer.IsInitialized() )
+    m_omx_tunnel_mixer.Deestablish();
+  if ( m_omx_tunnel_splitter_hdmi.IsInitialized() )
+    m_omx_tunnel_splitter_hdmi.Deestablish();
+  if ( m_omx_tunnel_splitter_analog.IsInitialized() )
+    m_omx_tunnel_splitter_analog.Deestablish();
 
   m_omx_decoder.FlushInput();
 
-  if(m_omx_render)
-    m_omx_render->Deinitialize(true);
-  if(!m_Passthrough)
-    m_omx_mixer.Deinitialize(true);
-  m_omx_decoder.Deinitialize(true);
+  m_omx_decoder.Deinitialize();
+  if ( m_omx_mixer.IsInitialized() )
+    m_omx_mixer.Deinitialize();
+  if ( m_omx_splitter.IsInitialized() )
+    m_omx_splitter.Deinitialize();
+  if ( m_omx_render_hdmi.IsInitialized() )
+    m_omx_render_hdmi.Deinitialize();
+  if ( m_omx_render_analog.IsInitialized() )
+    m_omx_render_analog.Deinitialize();
 
   m_BytesPerSec = 0;
   m_BufferLen   = 0;
@@ -610,168 +756,178 @@
   m_extradata = NULL;
   m_extrasize = 0;
 
+  while(!m_vizqueue.empty())
+    m_vizqueue.pop();
+
   m_dllAvUtil.Unload();
 
-  m_first_frame   = true;
-  m_last_pts      = DVD_NOPTS_VALUE;
+  while(!m_ampqueue.empty())
+    m_ampqueue.pop_front();
 
-  delete m_omx_render;
-  m_omx_render = NULL;
+  m_last_pts      = DVD_NOPTS_VALUE;
+  m_submitted     = 0.0f;
+  m_maxLevel      = 0.0f;
 
   return true;
 }
 
 void COMXAudio::Flush()
 {
+  CSingleLock lock (m_critSection);
   if(!m_Initialized)
     return;
 
-  m_omx_decoder.FlushInput();
-  m_omx_tunnel_decoder.Flush();
-  if(!m_Passthrough)
-    m_omx_tunnel_mixer.Flush();
-  
-  m_last_pts      = DVD_NOPTS_VALUE;
-  m_LostSync      = true;
-  //m_first_frame   = true;
-}
-
-//***********************************************************************************************
-bool COMXAudio::Pause()
-{
-  if (!m_Initialized)
-     return -1;
-
-  if(m_Pause) return true;
-  m_Pause = true;
-
-  m_omx_decoder.SetStateForComponent(OMX_StatePause);
-
-  return true;
-}
+  m_omx_decoder.FlushAll();
 
-//***********************************************************************************************
-bool COMXAudio::Resume()
-{
-  if (!m_Initialized)
-     return -1;
+  if ( m_omx_mixer.IsInitialized() )
+    m_omx_mixer.FlushAll();
 
-  if(!m_Pause) return true;
-  m_Pause = false;
+  if ( m_omx_splitter.IsInitialized() )
+    m_omx_splitter.FlushAll();
 
-  m_omx_decoder.SetStateForComponent(OMX_StateExecuting);
+  if ( m_omx_render_analog.IsInitialized() )
+    m_omx_render_analog.FlushAll();
+  if ( m_omx_render_hdmi.IsInitialized() )
+    m_omx_render_hdmi.FlushAll();
 
-  return true;
+  m_last_pts      = DVD_NOPTS_VALUE;
+  m_submitted     = 0.0f;
+  m_maxLevel      = 0.0f;
+  m_LostSync      = true;
+  m_setStartTime  = true;
 }
 
 //***********************************************************************************************
-bool COMXAudio::Stop()
+void COMXAudio::SetDynamicRangeCompression(long drc)
 {
-  if (!m_Initialized)
-     return -1;
-
-  Flush();
-
-  m_Pause = false;
-
-  return true;
+  CSingleLock lock (m_critSection);
+  m_amplification = powf(10.0f, (float)drc / 2000.0f);
+  if (m_settings_changed)
+    UpdateAttenuation();
 }
 
 //***********************************************************************************************
-long COMXAudio::GetCurrentVolume() const
+void COMXAudio::SetMute(bool bMute)
 {
-  return m_CurrentVolume;
+  CSingleLock lock (m_critSection);
+  m_Mute = bMute;
+  if (m_settings_changed)
+    UpdateAttenuation();
 }
 
 //***********************************************************************************************
-void COMXAudio::Mute(bool bMute)
+void COMXAudio::SetVolume(float fVolume)
 {
-  if(!m_Initialized)
-    return;
-
-  if (bMute)
-    SetCurrentVolume(VOLUME_MINIMUM);
-  else
-    SetCurrentVolume(m_CurrentVolume);
+  CSingleLock lock (m_critSection);
+  m_CurrentVolume = fVolume;
+  if (m_settings_changed)
+    UpdateAttenuation();
 }
 
 //***********************************************************************************************
-bool COMXAudio::SetCurrentVolume(float fVolume)
+bool COMXAudio::ApplyVolume(void)
 {
   CSingleLock lock (m_critSection);
 
-  if(!m_Initialized || m_Passthrough)
+  if (!m_Initialized || m_Passthrough)
     return false;
-  double gain = pow(10, (g_advancedSettings.m_ac3Gain - 12.0f) / 20.0);
-  m_CurrentVolume = fVolume;
-
-  if (m_format.m_channelLayout.Count() > 2)
-  {
-    double r = fVolume;
-    const float* coeff = downmixing_coefficients_8;
-    int input_channels = 0;
-
-    // normally we normalalise the levels, can be skipped (boosted) at risk of distortion
-    if(!g_guiSettings.GetBool("audiooutput.normalizelevels"))
-    {
-      double sum_L = 0;
-      double sum_R = 0;
-
-      for(size_t i = 0; i < OMX_AUDIO_MAXCHANNELS; ++i)
-      {
-        if (m_input_channels[i] == OMX_AUDIO_ChannelMax)
-          break;
-        if(i & 1)
-          sum_R += coeff[i];
-        else
-          sum_L += coeff[i];
-      }
 
-      r /= max(sum_L, sum_R);
-    }
+  float fVolume = m_Mute ? VOLUME_MINIMUM : m_CurrentVolume;
 
-    // the analogue volume is too quiet for some. Allow use of an advancedsetting to boost this (at risk of distortion)
-    r *= gain;
+  // the analogue volume is too quiet for some. Allow use of an advancedsetting to boost this (at risk of distortion) (deprecated)
+  double gain = pow(10, (g_advancedSettings.m_ac3Gain - 12.0f) / 20.0);
 
-    OMX_CONFIG_BRCMAUDIODOWNMIXCOEFFICIENTS mix;
-    OMX_INIT_STRUCTURE(mix);
-    mix.nPortIndex = m_omx_mixer.GetInputPort();
+  const float* coeff = m_downmix_matrix;
 
-    assert(sizeof(mix.coeff)/sizeof(mix.coeff[0]) == 16);
+  OMX_CONFIG_BRCMAUDIODOWNMIXCOEFFICIENTS8x8 mix;
+  OMX_INIT_STRUCTURE(mix);
+  OMX_ERRORTYPE omx_err;
 
-    for(size_t i = 0; i < 16; ++i)
-      mix.coeff[i] = static_cast<unsigned int>(0x10000 * (coeff[i] * r));
+  assert(sizeof(mix.coeff)/sizeof(mix.coeff[0]) == 64);
 
-    OMX_ERRORTYPE omx_err =
-      m_omx_mixer.SetConfig(OMX_IndexConfigBrcmAudioDownmixCoefficients, &mix);
+  if (m_amplification != 1.0)
+  {
+    // reduce scaling so overflow can be seen
+    for(size_t i = 0; i < 8*8; ++i)
+      mix.coeff[i] = static_cast<unsigned int>(0x10000 * (coeff[i] * gain * 0.01f));
 
+    mix.nPortIndex = m_omx_decoder.GetInputPort();
+    omx_err = m_omx_decoder.SetConfig(OMX_IndexConfigBrcmAudioDownmixCoefficients8x8, &mix);
     if(omx_err != OMX_ErrorNone)
     {
-      CLog::Log(LOGERROR, "%s::%s - error setting OMX_IndexConfigBrcmAudioDownmixCoefficients, error 0x%08x\n",
+      CLog::Log(LOGERROR, "%s::%s - error setting decoder OMX_IndexConfigBrcmAudioDownmixCoefficients, error 0x%08x\n",
                 CLASSNAME, __func__, omx_err);
       return false;
     }
   }
-  else
+  for(size_t i = 0; i < 8*8; ++i)
+    mix.coeff[i] = static_cast<unsigned int>(0x10000 * (coeff[i] * gain * fVolume * m_amplification * m_attenuation));
+
+  mix.nPortIndex = m_omx_mixer.GetInputPort();
+  omx_err = m_omx_mixer.SetConfig(OMX_IndexConfigBrcmAudioDownmixCoefficients8x8, &mix);
+  if(omx_err != OMX_ErrorNone)
   {
-    OMX_AUDIO_CONFIG_VOLUMETYPE volume;
-    OMX_INIT_STRUCTURE(volume);
-    volume.nPortIndex = m_omx_render->GetInputPort();
-
-    volume.bLinear    = OMX_TRUE;
-    float hardwareVolume = fVolume * gain * 100.0f;
-    volume.sVolume.nValue = (int)(hardwareVolume + 0.5f);
+    CLog::Log(LOGERROR, "%s::%s - error setting mixer OMX_IndexConfigBrcmAudioDownmixCoefficients, error 0x%08x\n",
+              CLASSNAME, __func__, omx_err);
+    return false;
+  }
+  CLog::Log(LOGINFO, "%s::%s - Volume=%.2f (* %.2f * %.2f)\n", CLASSNAME, __func__, fVolume, m_amplification, m_attenuation);
+  return true;
+}
 
-    OMX_ERRORTYPE omx_err =
-      m_omx_render->SetConfig(OMX_IndexConfigAudioVolume, &volume);
-    if(omx_err != OMX_ErrorNone)
+void COMXAudio::VizPacket(const void* data, unsigned int len, double pts)
+{
+    /* input samples */
+    unsigned int vizBufferSamples = len / (CAEUtil::DataFormatToBits(m_format.m_dataFormat) >> 3);
+
+    /* input frames */
+    unsigned int frames = vizBufferSamples / m_InputChannels;
+    float *floatBuffer = (float *)data;
+
+    if (m_format.m_dataFormat != AE_FMT_FLOAT)
     {
-      CLog::Log(LOGERROR, "%s::%s - error setting OMX_IndexConfigAudioVolume, error 0x%08x\n",
-                CLASSNAME, __func__, omx_err);
-      return false;
+      CAEConvert::AEConvertToFn m_convertFn = CAEConvert::ToFloat(m_format.m_dataFormat);
+
+      /* check convert buffer */
+      CheckOutputBufferSize((void **)&m_vizBuffer, &m_vizBufferSize, vizBufferSamples * (CAEUtil::DataFormatToBits(AE_FMT_FLOAT) >> 3));
+
+      /* convert to float */
+      m_convertFn((uint8_t *)data, vizBufferSamples, (float *)m_vizBuffer);
+      floatBuffer = (float *)m_vizBuffer;
     }
-  }  
-  return true;
+
+    // Viz channel count is 2
+    CheckOutputBufferSize((void **)&m_vizRemapBuffer, &m_vizRemapBufferSize, frames * 2 * sizeof(float));
+
+    /* remap */
+    m_vizRemap.Remap(floatBuffer, (float*)m_vizRemapBuffer, frames);
+
+    /* output samples */
+    vizBufferSamples = vizBufferSamples / m_InputChannels * 2;
+
+    /* viz size is limited */
+    if(vizBufferSamples > VIS_PACKET_SIZE)
+      vizBufferSamples = VIS_PACKET_SIZE;
+
+    vizblock_t v;
+    v.pts = pts;
+    v.num_samples = vizBufferSamples;
+    memcpy(v.samples, m_vizRemapBuffer, vizBufferSamples * sizeof(float));
+    m_vizqueue.push(v);
+
+    double stamp = m_av_clock->OMXMediaTime();
+    while(!m_vizqueue.empty())
+    {
+      vizblock_t &v = m_vizqueue.front();
+      /* if packet has almost reached media time (allow time for rendering delay) then display it */
+      /* we'll also consume if queue gets unexpectedly long to avoid filling memory */
+      if (v.pts == DVD_NOPTS_VALUE || v.pts - stamp < DVD_SEC_TO_TIME(1.0/30.0) || v.pts - stamp > DVD_SEC_TO_TIME(15.0))
+      {
+         m_pCallback->OnAudioData(v.samples, v.num_samples);
+         m_vizqueue.pop();
+      }
+      else break;
+   }
 }
 
 
@@ -786,44 +942,14 @@
 {
   CSingleLock lock (m_critSection);
 
-  if(!m_Initialized) 
+  if(!m_Initialized)
   {
     CLog::Log(LOGERROR,"COMXAudio::AddPackets - sanity failed. no valid play handle!");
     return len;
   }
 
-  m_vizBufferSamples = 0;
-
-  if (m_pCallback && len)
-  {
-    /* input samples */
-    m_vizBufferSamples = len / (CAEUtil::DataFormatToBits(AE_FMT_S16LE) >> 3);
-    CAEConvert::AEConvertToFn m_convertFn = CAEConvert::ToFloat(AE_FMT_S16LE);
-    /* input frames */
-    unsigned int frames = m_vizBufferSamples / m_format.m_channelLayout.Count();
-
-    /* check convert buffer */
-    CheckOutputBufferSize((void **)&m_vizBuffer, &m_vizBufferSize, m_vizBufferSamples * (CAEUtil::DataFormatToBits(AE_FMT_FLOAT) >> 3));
-
-    /* convert to float */
-    m_convertFn((uint8_t *)data, m_vizBufferSamples, (float *)m_vizBuffer);
-
-    /* check remap buffer */
-    CheckOutputBufferSize((void **)&m_vizRemapBuffer, &m_vizRemapBufferSize, frames * 2 * (CAEUtil::DataFormatToBits(AE_FMT_FLOAT) >> 3));
-
-    /* remap */
-    m_vizRemap.Remap((float *)m_vizBuffer, (float*)m_vizRemapBuffer, frames);
-
-    /* output samples */
-    m_vizBufferSamples = m_vizBufferSamples / m_format.m_channelLayout.Count() * 2;
-
-    /* viz size is limited */
-    if(m_vizBufferSamples > VIS_PACKET_SIZE)
-      m_vizBufferSamples = VIS_PACKET_SIZE;
-
-    if(m_pCallback)
-      m_pCallback->OnAudioData((float *)m_vizRemapBuffer, m_vizBufferSamples);
-  }
+  if (m_pCallback && len && !(m_Passthrough || m_HWDecode))
+    VizPacket(data, len, pts);
 
   if(m_eEncoding == OMX_AUDIO_CodingDTS && m_LostSync && (m_Passthrough || m_HWDecode))
   {
@@ -839,14 +965,16 @@
       return len;
   }
 
-  unsigned int demuxer_bytes = (unsigned int)len;
+  unsigned pitch = (m_Passthrough || m_HWDecode) ? 1:(m_BitsPerSample >> 3) * m_InputChannels;
+  unsigned int demuxer_samples = len / pitch;
+  unsigned int demuxer_samples_sent = 0;
   uint8_t *demuxer_content = (uint8_t *)data;
 
   OMX_ERRORTYPE omx_err;
 
   OMX_BUFFERHEADERTYPE *omx_buffer = NULL;
 
-  while(demuxer_bytes)
+  while(demuxer_samples_sent < demuxer_samples)
   {
     // 200ms timeout
     omx_buffer = m_omx_decoder.GetInputBuffer(200);
@@ -860,12 +988,40 @@
     omx_buffer->nOffset = 0;
     omx_buffer->nFlags  = 0;
 
-    omx_buffer->nFilledLen = (demuxer_bytes > omx_buffer->nAllocLen) ? omx_buffer->nAllocLen : demuxer_bytes;
-    memcpy(omx_buffer->pBuffer, demuxer_content, omx_buffer->nFilledLen);
+    // we want audio_decode output buffer size to be no more than AUDIO_DECODE_OUTPUT_BUFFER.
+    // it will be 16-bit and rounded up to next power of 2 in channels
+    static const char rounded_up_channels_shift[] = {0,0,1,2,2,3,3,3,3};
+    unsigned int max_buffer = AUDIO_DECODE_OUTPUT_BUFFER * (m_InputChannels * m_BitsPerSample) >> (rounded_up_channels_shift[m_InputChannels] + 4);
+
+    unsigned int remaining = demuxer_samples-demuxer_samples_sent;
+    unsigned int samples_space = std::min(max_buffer, omx_buffer->nAllocLen)/pitch;
+    unsigned int samples = std::min(remaining, samples_space);
+
+    omx_buffer->nFilledLen = samples * pitch;
+
+    if (samples < demuxer_samples && m_BitsPerSample==32 && !(m_Passthrough || m_HWDecode))
+    {
+       uint8_t *dst = omx_buffer->pBuffer;
+       uint8_t *src = demuxer_content + demuxer_samples_sent * (m_BitsPerSample >> 3);
+       // we need to extract samples from planar audio, so the copying needs to be done per plane
+       for (int i=0; i<(int)m_InputChannels; i++)
+       {
+         memcpy(dst, src, omx_buffer->nFilledLen / m_InputChannels);
+         dst += omx_buffer->nFilledLen / m_InputChannels;
+         src += demuxer_samples * (m_BitsPerSample >> 3);
+       }
+       assert(dst <= omx_buffer->pBuffer + m_ChunkLen);
+    }
+    else
+    {
+       uint8_t *dst = omx_buffer->pBuffer;
+       uint8_t *src = demuxer_content + demuxer_samples_sent * pitch;
+       memcpy(dst, src, omx_buffer->nFilledLen);
+    }
 
     uint64_t val  = (uint64_t)(pts == DVD_NOPTS_VALUE) ? 0 : pts;
 
-    if(m_av_clock->AudioStart())
+    if(m_setStartTime)
     {
       omx_buffer->nFlags = OMX_BUFFERFLAG_STARTTIME;
       if(pts == DVD_NOPTS_VALUE)
@@ -874,7 +1030,7 @@
       m_last_pts = pts;
 
       CLog::Log(LOGDEBUG, "COMXAudio::Decode ADec : setStartTime %f\n", (float)val / DVD_TIME_BASE);
-      m_av_clock->AudioStart(false);
+      m_setStartTime = false;
     }
     else
     {
@@ -898,10 +1054,9 @@
 
     omx_buffer->nTimeStamp = ToOMXTime(val);
 
-    demuxer_bytes -= omx_buffer->nFilledLen;
-    demuxer_content += omx_buffer->nFilledLen;
+    demuxer_samples_sent += samples;
 
-    if(demuxer_bytes == 0)
+    if(demuxer_samples_sent == demuxer_samples)
       omx_buffer->nFlags |= OMX_BUFFERFLAG_ENDOFFRAME;
 
     int nRetry = 0;
@@ -925,159 +1080,90 @@
       }
     }
 
-    if(m_first_frame)
+    omx_err = m_omx_decoder.WaitForEvent(OMX_EventPortSettingsChanged, 0);
+    if (omx_err == OMX_ErrorNone)
     {
-      m_first_frame = false;
-      //m_omx_render.WaitForEvent(OMX_EventPortSettingsChanged);
-
-      m_omx_render->DisablePort(m_omx_render->GetInputPort(), false);
-      if(!m_Passthrough)
+      if(!PortSettingsChanged())
       {
-        m_omx_mixer.DisablePort(m_omx_mixer.GetOutputPort(), false);
-        m_omx_mixer.DisablePort(m_omx_mixer.GetInputPort(), false);
+        CLog::Log(LOGERROR, "%s::%s - error PortSettingsChanged omx_err(0x%08x)\n", CLASSNAME, __func__, omx_err);
       }
-      m_omx_decoder.DisablePort(m_omx_decoder.GetOutputPort(), false);
+    }
+  }
+  m_submitted += (float)demuxer_samples / m_SampleRate;
+  UpdateAttenuation();
+  return len;
+}
 
-      if(!m_Passthrough)
-      {
-        if(m_HWDecode)
-        {
-          OMX_INIT_STRUCTURE(m_pcm_input);
-          m_pcm_input.nPortIndex      = m_omx_decoder.GetOutputPort();
-          omx_err = m_omx_decoder.GetParameter(OMX_IndexParamAudioPcm, &m_pcm_input);
-          if(omx_err != OMX_ErrorNone)
-          {
-            CLog::Log(LOGERROR, "COMXAudio::AddPackets error GetParameter 1 omx_err(0x%08x)\n", omx_err);
-          }
-        }
-
-        memcpy(m_pcm_input.eChannelMapping, m_input_channels, sizeof(m_input_channels));
-        m_pcm_input.nSamplingRate = m_format.m_sampleRate;
-
-        /* setup mixer input */
-        m_pcm_input.nPortIndex      = m_omx_mixer.GetInputPort();
-        omx_err = m_omx_mixer.SetParameter(OMX_IndexParamAudioPcm, &m_pcm_input);
-        if(omx_err != OMX_ErrorNone)
-        {
-          CLog::Log(LOGERROR, "COMXAudio::AddPackets error SetParameter 1 input omx_err(0x%08x)\n", omx_err);
-        }
-        omx_err = m_omx_mixer.GetParameter(OMX_IndexParamAudioPcm, &m_pcm_input);
-        if(omx_err != OMX_ErrorNone)
-        {
-          CLog::Log(LOGERROR, "COMXAudio::AddPackets error GetParameter 2 input omx_err(0x%08x)\n", omx_err);
-        }
-
-        m_pcm_output.nSamplingRate = m_format.m_sampleRate;
-
-        /* setup mixer output */
-        m_pcm_output.nPortIndex      = m_omx_mixer.GetOutputPort();
-        omx_err = m_omx_mixer.SetParameter(OMX_IndexParamAudioPcm, &m_pcm_output);
-        if(omx_err != OMX_ErrorNone)
-        {
-          CLog::Log(LOGERROR, "COMXAudio::AddPackets error SetParameter 1 output omx_err(0x%08x)\n", omx_err);
-        }
-        omx_err = m_omx_mixer.GetParameter(OMX_IndexParamAudioPcm, &m_pcm_output);
-        if(omx_err != OMX_ErrorNone)
-        {
-          CLog::Log(LOGERROR, "COMXAudio::AddPackets error GetParameter 2 output omx_err(0x%08x)\n", omx_err);
-        }
-
-        m_pcm_output.nSamplingRate = m_format.m_sampleRate;
-
-        m_pcm_output.nPortIndex      = m_omx_render->GetInputPort();
-        omx_err = m_omx_render->SetParameter(OMX_IndexParamAudioPcm, &m_pcm_output);
-        if(omx_err != OMX_ErrorNone)
-        {
-          CLog::Log(LOGERROR, "COMXAudio::AddPackets error SetParameter 1 render omx_err(0x%08x)\n", omx_err);
-        }
-        omx_err = m_omx_render->GetParameter(OMX_IndexParamAudioPcm, &m_pcm_output);
-        if(omx_err != OMX_ErrorNone)
-        {
-          CLog::Log(LOGERROR, "COMXAudio::AddPackets error GetParameter 2 render omx_err(0x%08x)\n", omx_err);
-        }
+void COMXAudio::UpdateAttenuation()
+{
+  // always called with m_critSection lock held
+  if (!m_Initialized || m_Passthrough)
+    return;
 
-        PrintPCM(&m_pcm_input, std::string("input"));
-        PrintPCM(&m_pcm_output, std::string("output"));
-      }
-      else
-      {
-        OMX_AUDIO_PARAM_PORTFORMATTYPE formatType;
-        OMX_INIT_STRUCTURE(formatType);
-        formatType.nPortIndex = m_omx_render->GetInputPort();
-
-        omx_err = m_omx_render->GetParameter(OMX_IndexParamAudioPortFormat, &formatType);
-        if(omx_err != OMX_ErrorNone)
-        {
-          CLog::Log(LOGERROR, "COMXAudio::AddPackets error OMX_IndexParamAudioPortFormat omx_err(0x%08x)\n", omx_err);
-          assert(0);
-        }
-
-        formatType.eEncoding = m_eEncoding;
-
-        omx_err = m_omx_render->SetParameter(OMX_IndexParamAudioPortFormat, &formatType);
-        if(omx_err != OMX_ErrorNone)
-        {
-          CLog::Log(LOGERROR, "COMXAudio::AddPackets error OMX_IndexParamAudioPortFormat omx_err(0x%08x)\n", omx_err);
-          assert(0);
-        }
-
-        if(m_eEncoding == OMX_AUDIO_CodingDDP)
-        {
-          OMX_AUDIO_PARAM_DDPTYPE m_ddParam;
-          OMX_INIT_STRUCTURE(m_ddParam);
-
-          m_ddParam.nPortIndex      = m_omx_render->GetInputPort();
-
-          m_ddParam.nChannels       = m_format.m_channelLayout.Count(); //(m_InputChannels == 6) ? 8 : m_InputChannels;
-          m_ddParam.nSampleRate     = m_SampleRate;
-          m_ddParam.eBitStreamId    = OMX_AUDIO_DDPBitStreamIdAC3;
-          m_ddParam.nBitRate        = 0;
-
-          for(unsigned int i = 0; i < OMX_MAX_CHANNELS; i++)
-          {
-            if(i >= m_ddParam.nChannels)
-              break;
+  if (m_amplification == 1.0)
+  {
+    ApplyVolume();
+    return;
+  }
 
-            m_ddParam.eChannelMapping[i] = OMXChannels[i];
-          }
-  
-          m_omx_render->SetParameter(OMX_IndexParamAudioDdp, &m_ddParam);
-          m_omx_render->GetParameter(OMX_IndexParamAudioDdp, &m_ddParam);
-          PrintDDP(&m_ddParam);
-        }
-        else if(m_eEncoding == OMX_AUDIO_CodingDTS)
-        {
-          m_dtsParam.nPortIndex      = m_omx_render->GetInputPort();
-
-          m_dtsParam.nChannels       = m_format.m_channelLayout.Count(); //(m_InputChannels == 6) ? 8 : m_InputChannels;
-          m_dtsParam.nBitRate        = 0;
-
-          for(unsigned int i = 0; i < OMX_MAX_CHANNELS; i++)
-          {
-            if(i >= m_dtsParam.nChannels)
-              break;
+  double level_pts = 0.0;
+  float level = GetMaxLevel(level_pts);
+  if (level_pts != 0.0)
+  {
+    amplitudes_t v;
+    v.level = level;
+    v.pts = level_pts;
+    m_ampqueue.push_back(v);
+  }
+  double stamp = m_av_clock->OMXMediaTime();
+  // discard too old data
+  while(!m_ampqueue.empty())
+  {
+    amplitudes_t &v = m_ampqueue.front();
+    /* we'll also consume if queue gets unexpectedly long to avoid filling memory */
+    if (v.pts == DVD_NOPTS_VALUE || v.pts < stamp || v.pts - stamp > DVD_SEC_TO_TIME(15.0))
+      m_ampqueue.pop_front();
+    else break;
+  }
+  float maxlevel = 0.0f, imminent_maxlevel = 0.0f;
+  for (int i=0; i < (int)m_ampqueue.size(); i++)
+  {
+    amplitudes_t &v = m_ampqueue[i];
+    maxlevel = std::max(maxlevel, v.level);
+    // check for maximum volume in next 200ms
+    if (v.pts != DVD_NOPTS_VALUE && v.pts < stamp + DVD_SEC_TO_TIME(0.2))
+      imminent_maxlevel = std::max(imminent_maxlevel, v.level);
+  }
+
+  if (maxlevel != 0.0)
+  {
+    float alpha_h = -1.0f/(0.025f*log10f(0.999f));
+    float alpha_r = -1.0f/(0.100f*log10f(0.900f));
+    float decay  = powf(10.0f, -1.0f / (alpha_h * g_advancedSettings.m_limiterHold));
+    float attack = powf(10.0f, -1.0f / (alpha_r * g_advancedSettings.m_limiterRelease));
+    // if we are going to clip imminently then deal with it now
+    if (imminent_maxlevel > m_maxLevel)
+      m_maxLevel = imminent_maxlevel;
+    // clip but not imminently can ramp up more slowly
+    else if (maxlevel > m_maxLevel)
+      m_maxLevel = attack * m_maxLevel + (1.0f-attack) * maxlevel;
+    // not clipping, decay more slowly
+    else
+      m_maxLevel = decay  * m_maxLevel + (1.0f-decay ) * maxlevel;
 
-            m_dtsParam.eChannelMapping[i] = OMXChannels[i];
-          }
-  
-          m_omx_render->SetParameter(OMX_IndexParamAudioDts, &m_dtsParam);
-          m_omx_render->GetParameter(OMX_IndexParamAudioDts, &m_dtsParam);
-          PrintDTS(&m_dtsParam);
-        }
-      }
+    // want m_maxLevel * amp -> 1.0
+    float amp = m_amplification * m_attenuation;
 
-      m_omx_render->EnablePort(m_omx_render->GetInputPort(), false);
-      if(!m_Passthrough)
-      {
-        m_omx_mixer.EnablePort(m_omx_mixer.GetOutputPort(), false);
-        m_omx_mixer.EnablePort(m_omx_mixer.GetInputPort(), false);
-      }
-      m_omx_decoder.EnablePort(m_omx_decoder.GetOutputPort(), false);
-    }
- 
+    // We fade in the attenuation over first couple of seconds
+    float start = std::min(std::max((m_submitted-1.0f), 0.0f), 1.0f);
+    float attenuation = std::min(1.0f, std::max(m_attenuation / (amp * m_maxLevel), 1.0f/m_amplification));
+    m_attenuation = (1.0f - start) * 1.0f/m_amplification + start * attenuation;
   }
-
-  return len;
+  else
+  {
+    m_attenuation = 1.0f/m_amplification;
+  }
+  ApplyVolume();
 }
 
 //***********************************************************************************************
@@ -1090,7 +1176,7 @@
 float COMXAudio::GetDelay()
 {
   unsigned int free = m_omx_decoder.GetInputBufferSize() - m_omx_decoder.GetInputBufferSpace();
-  return (float)free / (float)m_BytesPerSec;
+  return m_BytesPerSec ? (float)free / (float)m_BytesPerSec : 0.0f;
 }
 
 float COMXAudio::GetCacheTime()
@@ -1098,13 +1184,13 @@
   float fBufferLenFull = (float)m_BufferLen - (float)GetSpace();
   if(fBufferLenFull < 0)
     fBufferLenFull = 0;
-  float ret = fBufferLenFull / (float)m_BytesPerSec;
+  float ret = m_BytesPerSec ? fBufferLenFull / (float)m_BytesPerSec : 0.0f;
   return ret;
 }
 
 float COMXAudio::GetCacheTotal()
 {
-  return (float)m_BufferLen / (float)m_BytesPerSec;
+  return m_BytesPerSec ? (float)m_BufferLen / (float)m_BytesPerSec : 0.0f;
 }
 
 //***********************************************************************************************
@@ -1120,7 +1206,7 @@
 
 void COMXAudio::RegisterAudioCallback(IAudioCallback *pCallback)
 {
-  m_vizBufferSamples = 0;
+  CSingleLock lock (m_critSection);
   if(!m_Passthrough && !m_HWDecode)
   {
     m_pCallback = pCallback;
@@ -1133,8 +1219,8 @@
 
 void COMXAudio::UnRegisterAudioCallback()
 {
+  CSingleLock lock (m_critSection);
   m_pCallback = NULL;
-  m_vizBufferSamples = 0;
 }
 
 unsigned int COMXAudio::GetAudioRenderingLatency()
@@ -1146,34 +1232,81 @@
 
   OMX_PARAM_U32TYPE param;
   OMX_INIT_STRUCTURE(param);
-  param.nPortIndex = m_omx_render->GetInputPort();
 
-  OMX_ERRORTYPE omx_err =
-    m_omx_render->GetConfig(OMX_IndexConfigAudioRenderingLatency, &param);
+  if(m_omx_render_analog.IsInitialized())
+  {
+    param.nPortIndex = m_omx_render_analog.GetInputPort();
 
-  if(omx_err != OMX_ErrorNone)
+    OMX_ERRORTYPE omx_err = m_omx_render_analog.GetConfig(OMX_IndexConfigAudioRenderingLatency, &param);
+
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - error getting OMX_IndexConfigAudioRenderingLatency error 0x%08x\n",
+        CLASSNAME, __func__, omx_err);
+      return 0;
+    }
+  }
+  else if(m_omx_render_hdmi.IsInitialized())
   {
-    CLog::Log(LOGERROR, "%s::%s - error getting OMX_IndexConfigAudioRenderingLatency error 0x%08x\n",
-      CLASSNAME, __func__, omx_err);
-    return 0;
+    param.nPortIndex = m_omx_render_hdmi.GetInputPort();
+
+    OMX_ERRORTYPE omx_err = m_omx_render_hdmi.GetConfig(OMX_IndexConfigAudioRenderingLatency, &param);
+
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - error getting OMX_IndexConfigAudioRenderingLatency error 0x%08x\n",
+        CLASSNAME, __func__, omx_err);
+      return 0;
+    }
   }
 
   return param.nU32;
 }
 
+float COMXAudio::GetMaxLevel(double &pts)
+{
+  CSingleLock lock (m_critSection);
+
+  if(!m_Initialized)
+    return 0;
+
+  OMX_CONFIG_BRCMAUDIOMAXSAMPLE param;
+  OMX_INIT_STRUCTURE(param);
+
+  if(m_omx_decoder.IsInitialized())
+  {
+    param.nPortIndex = m_omx_decoder.GetInputPort();
+
+    OMX_ERRORTYPE omx_err = m_omx_decoder.GetConfig(OMX_IndexConfigBrcmAudioMaxSample, &param);
+
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - error getting OMX_IndexConfigBrcmAudioMaxSample error 0x%08x\n",
+        CLASSNAME, __func__, omx_err);
+      return 0;
+    }
+  }
+  pts = FromOMXTime(param.nTimeStamp);
+  return (float)param.nMaxSample * (100.0f / (1<<15));
+}
+
 void COMXAudio::SubmitEOS()
 {
   CSingleLock lock (m_critSection);
 
-  if(!m_Initialized || m_Pause)
+  if(!m_Initialized)
     return;
 
+  m_submitted_eos = true;
+  m_failed_eos = false;
+
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-  OMX_BUFFERHEADERTYPE *omx_buffer = m_omx_decoder.GetInputBuffer();
+  OMX_BUFFERHEADERTYPE *omx_buffer = m_omx_decoder.GetInputBuffer(1000);
 
   if(omx_buffer == NULL)
   {
     CLog::Log(LOGERROR, "%s::%s - buffer error 0x%08x", CLASSNAME, __func__, omx_err);
+    m_failed_eos = true;
     return;
   }
 
@@ -1189,15 +1322,25 @@
     CLog::Log(LOGERROR, "%s::%s - OMX_EmptyThisBuffer() failed with result(0x%x)\n", CLASSNAME, __func__, omx_err);
     return;
   }
+  CLog::Log(LOGINFO, "%s::%s", CLASSNAME, __func__);
 }
 
 bool COMXAudio::IsEOS()
 {
-  if(!m_Initialized || m_Pause)
+  if(!m_Initialized)
     return true;
   unsigned int latency = GetAudioRenderingLatency();
   CSingleLock lock (m_critSection);
-  return m_omx_decoder.IsEOS() && latency <= 0;
+
+  if (!m_failed_eos && !(m_omx_decoder.IsEOS() && latency == 0))
+    return false;
+
+  if (m_submitted_eos)
+  {
+    CLog::Log(LOGINFO, "%s::%s", CLASSNAME, __func__);
+    m_submitted_eos = false;
+  }
+  return true;
 }
 
 void COMXAudio::SwitchChannels(int iAudioStream, bool bAudioOnAllSpeakers)
@@ -1225,17 +1368,17 @@
   } 
 }
 
-bool COMXAudio::CanHWDecode(CodecID codec)
+bool COMXAudio::CanHWDecode(AVCodecID codec)
 {
   bool ret = false;
   switch(codec)
   { 
-    case CODEC_ID_DTS:
+    case AV_CODEC_ID_DTS:
       CLog::Log(LOGDEBUG, "COMXAudio::CanHWDecode OMX_AUDIO_CodingDTS\n");
       ret = true;
       break;
-    case CODEC_ID_AC3:
-    case CODEC_ID_EAC3:
+    case AV_CODEC_ID_AC3:
+    case AV_CODEC_ID_EAC3:
       CLog::Log(LOGDEBUG, "COMXAudio::CanHWDecode OMX_AUDIO_CodingDDP\n");
       ret = true;
       break;
@@ -1435,7 +1578,6 @@
 unsigned int COMXAudio::SyncAC3(BYTE* pData, unsigned int iSize)
 {
   unsigned int skip = 0;
-  //unsigned int fSize = 0;
 
   for(skip = 0; iSize - skip > 6; ++skip, ++pData)
   {
@@ -1464,7 +1606,6 @@
       case 2: framesize = bitrate * 4; break;
     }
 
-    //fSize = framesize * 2;
     m_SampleRate = AC3FSCod[fscod];
 
     /* dont do extensive testing if we have not lost sync */
@@ -1503,3 +1644,121 @@
   memset(*buffer, 0x0, *oldSize);
 }
 
+void COMXAudio::BuildChannelMap(enum PCMChannels *channelMap, uint64_t layout)
+{
+  int index = 0;
+  if (layout & AV_CH_FRONT_LEFT           ) channelMap[index++] = PCM_FRONT_LEFT           ;
+  if (layout & AV_CH_FRONT_RIGHT          ) channelMap[index++] = PCM_FRONT_RIGHT          ;
+  if (layout & AV_CH_FRONT_CENTER         ) channelMap[index++] = PCM_FRONT_CENTER         ;
+  if (layout & AV_CH_LOW_FREQUENCY        ) channelMap[index++] = PCM_LOW_FREQUENCY        ;
+  if (layout & AV_CH_BACK_LEFT            ) channelMap[index++] = PCM_BACK_LEFT            ;
+  if (layout & AV_CH_BACK_RIGHT           ) channelMap[index++] = PCM_BACK_RIGHT           ;
+  if (layout & AV_CH_FRONT_LEFT_OF_CENTER ) channelMap[index++] = PCM_FRONT_LEFT_OF_CENTER ;
+  if (layout & AV_CH_FRONT_RIGHT_OF_CENTER) channelMap[index++] = PCM_FRONT_RIGHT_OF_CENTER;
+  if (layout & AV_CH_BACK_CENTER          ) channelMap[index++] = PCM_BACK_CENTER          ;
+  if (layout & AV_CH_SIDE_LEFT            ) channelMap[index++] = PCM_SIDE_LEFT            ;
+  if (layout & AV_CH_SIDE_RIGHT           ) channelMap[index++] = PCM_SIDE_RIGHT           ;
+  if (layout & AV_CH_TOP_CENTER           ) channelMap[index++] = PCM_TOP_CENTER           ;
+  if (layout & AV_CH_TOP_FRONT_LEFT       ) channelMap[index++] = PCM_TOP_FRONT_LEFT       ;
+  if (layout & AV_CH_TOP_FRONT_CENTER     ) channelMap[index++] = PCM_TOP_FRONT_CENTER     ;
+  if (layout & AV_CH_TOP_FRONT_RIGHT      ) channelMap[index++] = PCM_TOP_FRONT_RIGHT      ;
+  if (layout & AV_CH_TOP_BACK_LEFT        ) channelMap[index++] = PCM_TOP_BACK_LEFT        ;
+  if (layout & AV_CH_TOP_BACK_CENTER      ) channelMap[index++] = PCM_TOP_BACK_CENTER      ;
+  if (layout & AV_CH_TOP_BACK_RIGHT       ) channelMap[index++] = PCM_TOP_BACK_RIGHT       ;
+  while (index<OMX_AUDIO_MAXCHANNELS)
+    channelMap[index++] = PCM_INVALID;
+}
+
+// See CEA spec: Table 20, Audio InfoFrame data byte 4 for the ordering here
+int COMXAudio::BuildChannelMapCEA(enum PCMChannels *channelMap, uint64_t layout)
+{
+  int index = 0;
+  if (layout & AV_CH_FRONT_LEFT           ) channelMap[index++] = PCM_FRONT_LEFT;
+  if (layout & AV_CH_FRONT_RIGHT          ) channelMap[index++] = PCM_FRONT_RIGHT;
+  if (layout & AV_CH_LOW_FREQUENCY        ) channelMap[index++] = PCM_LOW_FREQUENCY;
+  if (layout & AV_CH_FRONT_CENTER         ) channelMap[index++] = PCM_FRONT_CENTER;
+  if (layout & AV_CH_BACK_LEFT            ) channelMap[index++] = PCM_BACK_LEFT;
+  if (layout & AV_CH_BACK_RIGHT           ) channelMap[index++] = PCM_BACK_RIGHT;
+  if (layout & AV_CH_SIDE_LEFT            ) channelMap[index++] = PCM_SIDE_LEFT;
+  if (layout & AV_CH_SIDE_RIGHT           ) channelMap[index++] = PCM_SIDE_RIGHT;
+
+  while (index<OMX_AUDIO_MAXCHANNELS)
+    channelMap[index++] = PCM_INVALID;
+
+  int num_channels = 0;
+  for (index=0; index<OMX_AUDIO_MAXCHANNELS; index++)
+    if (channelMap[index] != PCM_INVALID)
+       num_channels = index+1;
+  return num_channels;
+}
+
+void COMXAudio::BuildChannelMapOMX(enum OMX_AUDIO_CHANNELTYPE *	channelMap, uint64_t layout)
+{
+  int index = 0;
+
+  if (layout & AV_CH_FRONT_LEFT           ) channelMap[index++] = OMX_AUDIO_ChannelLF;
+  if (layout & AV_CH_FRONT_RIGHT          ) channelMap[index++] = OMX_AUDIO_ChannelRF;
+  if (layout & AV_CH_FRONT_CENTER         ) channelMap[index++] = OMX_AUDIO_ChannelCF;
+  if (layout & AV_CH_LOW_FREQUENCY        ) channelMap[index++] = OMX_AUDIO_ChannelLFE;
+  if (layout & AV_CH_BACK_LEFT            ) channelMap[index++] = OMX_AUDIO_ChannelLR;
+  if (layout & AV_CH_BACK_RIGHT           ) channelMap[index++] = OMX_AUDIO_ChannelRR;
+  if (layout & AV_CH_SIDE_LEFT            ) channelMap[index++] = OMX_AUDIO_ChannelLS;
+  if (layout & AV_CH_SIDE_RIGHT           ) channelMap[index++] = OMX_AUDIO_ChannelRS;
+  if (layout & AV_CH_BACK_CENTER          ) channelMap[index++] = OMX_AUDIO_ChannelCS;
+  // following are not in openmax spec, but gpu does accept them
+  if (layout & AV_CH_FRONT_LEFT_OF_CENTER ) channelMap[index++] = (enum OMX_AUDIO_CHANNELTYPE)10;
+  if (layout & AV_CH_FRONT_RIGHT_OF_CENTER) channelMap[index++] = (enum OMX_AUDIO_CHANNELTYPE)11;
+  if (layout & AV_CH_TOP_CENTER           ) channelMap[index++] = (enum OMX_AUDIO_CHANNELTYPE)12;
+  if (layout & AV_CH_TOP_FRONT_LEFT       ) channelMap[index++] = (enum OMX_AUDIO_CHANNELTYPE)13;
+  if (layout & AV_CH_TOP_FRONT_CENTER     ) channelMap[index++] = (enum OMX_AUDIO_CHANNELTYPE)14;
+  if (layout & AV_CH_TOP_FRONT_RIGHT      ) channelMap[index++] = (enum OMX_AUDIO_CHANNELTYPE)15;
+  if (layout & AV_CH_TOP_BACK_LEFT        ) channelMap[index++] = (enum OMX_AUDIO_CHANNELTYPE)16;
+  if (layout & AV_CH_TOP_BACK_CENTER      ) channelMap[index++] = (enum OMX_AUDIO_CHANNELTYPE)17;
+  if (layout & AV_CH_TOP_BACK_RIGHT       ) channelMap[index++] = (enum OMX_AUDIO_CHANNELTYPE)18;
+
+  while (index<OMX_AUDIO_MAXCHANNELS)
+    channelMap[index++] = OMX_AUDIO_ChannelNone;
+}
+
+uint64_t COMXAudio::GetChannelLayout(enum PCMLayout layout)
+{
+  uint64_t layouts[] = {
+    /* 2.0 */ 1<<PCM_FRONT_LEFT | 1<<PCM_FRONT_RIGHT,
+    /* 2.1 */ 1<<PCM_FRONT_LEFT | 1<<PCM_FRONT_RIGHT | 1<<PCM_LOW_FREQUENCY,
+    /* 3.0 */ 1<<PCM_FRONT_LEFT | 1<<PCM_FRONT_RIGHT | 1<<PCM_FRONT_CENTER,
+    /* 3.1 */ 1<<PCM_FRONT_LEFT | 1<<PCM_FRONT_RIGHT | 1<<PCM_FRONT_CENTER | 1<<PCM_LOW_FREQUENCY,
+    /* 4.0 */ 1<<PCM_FRONT_LEFT | 1<<PCM_FRONT_RIGHT | 1<<PCM_BACK_LEFT | 1<<PCM_BACK_RIGHT,
+    /* 4.1 */ 1<<PCM_FRONT_LEFT | 1<<PCM_FRONT_RIGHT | 1<<PCM_BACK_LEFT | 1<<PCM_BACK_RIGHT | 1<<PCM_LOW_FREQUENCY,
+    /* 5.0 */ 1<<PCM_FRONT_LEFT | 1<<PCM_FRONT_RIGHT | 1<<PCM_FRONT_CENTER | 1<<PCM_BACK_LEFT | 1<<PCM_BACK_RIGHT,
+    /* 5.1 */ 1<<PCM_FRONT_LEFT | 1<<PCM_FRONT_RIGHT | 1<<PCM_FRONT_CENTER | 1<<PCM_BACK_LEFT | 1<<PCM_BACK_RIGHT | 1<<PCM_LOW_FREQUENCY,
+    /* 7.0 */ 1<<PCM_FRONT_LEFT | 1<<PCM_FRONT_RIGHT | 1<<PCM_FRONT_CENTER | 1<<PCM_SIDE_LEFT | 1<<PCM_SIDE_RIGHT | 1<<PCM_BACK_LEFT | 1<<PCM_BACK_RIGHT,
+    /* 7.1 */ 1<<PCM_FRONT_LEFT | 1<<PCM_FRONT_RIGHT | 1<<PCM_FRONT_CENTER | 1<<PCM_SIDE_LEFT | 1<<PCM_SIDE_RIGHT | 1<<PCM_BACK_LEFT | 1<<PCM_BACK_RIGHT | 1<<PCM_LOW_FREQUENCY
+  };
+  return (int)layout < 10 ? layouts[(int)layout] : 0;
+}
+
+CAEChannelInfo COMXAudio::GetAEChannelLayout(uint64_t layout)
+{
+  CAEChannelInfo m_channelLayout;
+  m_channelLayout.Reset();
+
+  if (layout & AV_CH_FRONT_LEFT           ) m_channelLayout += AE_CH_FL  ;
+  if (layout & AV_CH_FRONT_RIGHT          ) m_channelLayout += AE_CH_FR  ;
+  if (layout & AV_CH_FRONT_CENTER         ) m_channelLayout += AE_CH_FC  ;
+  if (layout & AV_CH_LOW_FREQUENCY        ) m_channelLayout += AE_CH_LFE ;
+  if (layout & AV_CH_BACK_LEFT            ) m_channelLayout += AE_CH_BL  ;
+  if (layout & AV_CH_BACK_RIGHT           ) m_channelLayout += AE_CH_BR  ;
+  if (layout & AV_CH_FRONT_LEFT_OF_CENTER ) m_channelLayout += AE_CH_FLOC;
+  if (layout & AV_CH_FRONT_RIGHT_OF_CENTER) m_channelLayout += AE_CH_FROC;
+  if (layout & AV_CH_BACK_CENTER          ) m_channelLayout += AE_CH_BC  ;
+  if (layout & AV_CH_SIDE_LEFT            ) m_channelLayout += AE_CH_SL  ;
+  if (layout & AV_CH_SIDE_RIGHT           ) m_channelLayout += AE_CH_SR  ;
+  if (layout & AV_CH_TOP_CENTER           ) m_channelLayout += AE_CH_TC  ;
+  if (layout & AV_CH_TOP_FRONT_LEFT       ) m_channelLayout += AE_CH_TFL ;
+  if (layout & AV_CH_TOP_FRONT_CENTER     ) m_channelLayout += AE_CH_TFC ;
+  if (layout & AV_CH_TOP_FRONT_RIGHT      ) m_channelLayout += AE_CH_TFR ;
+  if (layout & AV_CH_TOP_BACK_LEFT        ) m_channelLayout += AE_CH_BL  ;
+  if (layout & AV_CH_TOP_BACK_CENTER      ) m_channelLayout += AE_CH_BC  ;
+  if (layout & AV_CH_TOP_BACK_RIGHT       ) m_channelLayout += AE_CH_BR  ;
+  return m_channelLayout;
+}
diff -ur a/xbmc/cores/omxplayer/OMXAudio.h b/xbmc/cores/omxplayer/OMXAudio.h
--- a/xbmc/cores/omxplayer/OMXAudio.h	2015-03-12 20:52:41.090096999 +0100
+++ b/xbmc/cores/omxplayer/OMXAudio.h	2015-03-12 20:48:25.162096999 +0100
@@ -38,10 +38,11 @@
 #include "OMXCore.h"
 #include "DllAvCodec.h"
 #include "DllAvUtil.h"
+#include "PCMRemap.h"
 
 #include "threads/CriticalSection.h"
 
-#define AUDIO_BUFFER_SECONDS 2
+#define AUDIO_BUFFER_SECONDS 3
 #define VIS_PACKET_SIZE 512
 
 #define OMX_IS_RAW(x)       \
@@ -60,21 +61,20 @@
   float GetCacheTime();
   float GetCacheTotal();
   COMXAudio();
-  bool Initialize(AEAudioFormat format, std::string& device, OMXClock *clock, CDVDStreamInfo &hints, bool bUsePassthrough, bool bUseHWDecode);
+  bool Initialize(AEAudioFormat format, OMXClock *clock, CDVDStreamInfo &hints, uint64_t channelMap, bool bUsePassthrough, bool bUseHWDecode);
+  bool PortSettingsChanged();
   ~COMXAudio();
 
   unsigned int AddPackets(const void* data, unsigned int len);
   unsigned int AddPackets(const void* data, unsigned int len, double dts, double pts);
   unsigned int GetSpace();
   bool Deinitialize();
-  bool Pause();
-  bool Stop();
-  bool Resume();
-
-  long GetCurrentVolume() const;
-  void Mute(bool bMute);
-  bool SetCurrentVolume(float fVolume);
-  void SetDynamicRangeCompression(long drc) { m_drc = drc; }
+
+  void SetVolume(float nVolume);
+  void SetMute(bool bOnOff);
+  void SetDynamicRangeCompression(long drc);
+  float GetDynamicRangeAmplification() { return 20.0f * log10f(m_amplification * m_attenuation); }
+  bool ApplyVolume();
   int SetPlaySpeed(int iSpeed);
   void SubmitEOS();
   bool IsEOS();
@@ -85,7 +85,7 @@
   void Process();
 
   void SetCodingType(AEDataFormat dataFormat);
-  static bool CanHWDecode(CodecID codec);
+  static bool CanHWDecode(AVCodecID codec);
 
   void PrintChannels(OMX_AUDIO_CHANNELTYPE eChannelMapping[]);
   void PrintPCM(OMX_AUDIO_PARAM_PCMMODETYPE *pcm, std::string direction);
@@ -93,62 +93,91 @@
   void PrintDTS(OMX_AUDIO_PARAM_DTSTYPE *dtsparam);
   unsigned int SyncDTS(BYTE* pData, unsigned int iSize);
   unsigned int SyncAC3(BYTE* pData, unsigned int iSize);
+  void UpdateAttenuation();
 
   bool BadState() { return !m_Initialized; };
   unsigned int GetAudioRenderingLatency();
+  float GetMaxLevel(double &pts);
+  void VizPacket(const void* data, unsigned int len, double pts);
+
+  void BuildChannelMap(enum PCMChannels *channelMap, uint64_t layout);
+  int BuildChannelMapCEA(enum PCMChannels *channelMap, uint64_t layout);
+  void BuildChannelMapOMX(enum OMX_AUDIO_CHANNELTYPE *channelMap, uint64_t layout);
+  uint64_t GetChannelLayout(enum PCMLayout layout);
+  CAEChannelInfo GetAEChannelLayout(uint64_t layout);
 
 private:
   IAudioCallback* m_pCallback;
   bool          m_Initialized;
-  bool          m_Pause;
-  bool          m_CanPause;
   float         m_CurrentVolume;
+  bool          m_Mute;
   long          m_drc;
   bool          m_Passthrough;
   bool          m_HWDecode;
   unsigned int  m_BytesPerSec;
   unsigned int  m_BufferLen;
   unsigned int  m_ChunkLen;
+  unsigned int  m_InputChannels;
   unsigned int  m_OutputChannels;
   unsigned int  m_BitsPerSample;
+  float         m_maxLevel;
+  float         m_amplification;
+  float         m_attenuation;
+  float         m_submitted;
   COMXCoreComponent *m_omx_clock;
   OMXClock       *m_av_clock;
-  bool          m_first_frame;
+  bool          m_settings_changed;
+  bool          m_setStartTime;
   bool          m_LostSync;
   int           m_SampleRate;
   OMX_AUDIO_CODINGTYPE m_eEncoding;
   uint8_t       *m_extradata;
   int           m_extrasize;
   // stuff for visualisation
-  unsigned int  m_vizBufferSamples;
   double        m_last_pts;
   int           m_vizBufferSize;
   uint8_t       *m_vizBuffer;
   int           m_vizRemapBufferSize;
   uint8_t       *m_vizRemapBuffer;
   CAERemap      m_vizRemap;
+  bool          m_submitted_eos;
+  bool          m_failed_eos;
+  typedef struct {
+    int num_samples;
+    float samples[VIS_PACKET_SIZE];
+    double pts;
+  } vizblock_t;
+  std::queue<vizblock_t> m_vizqueue;
+
+  typedef struct {
+    double pts;
+    float level;
+  } amplitudes_t;
+  std::deque<amplitudes_t> m_ampqueue;
+
+  float m_downmix_matrix[OMX_AUDIO_MAXCHANNELS*OMX_AUDIO_MAXCHANNELS];
 
+  OMX_AUDIO_CHANNELTYPE m_input_channels[OMX_AUDIO_MAXCHANNELS];
+  OMX_AUDIO_CHANNELTYPE m_output_channels[OMX_AUDIO_MAXCHANNELS];
   OMX_AUDIO_PARAM_PCMMODETYPE m_pcm_output;
   OMX_AUDIO_PARAM_PCMMODETYPE m_pcm_input;
   OMX_AUDIO_PARAM_DTSTYPE     m_dtsParam;
   WAVEFORMATEXTENSIBLE        m_wave_header;
   AEAudioFormat m_format;
 protected:
-  COMXCoreComponent *m_omx_render;
+  COMXCoreComponent m_omx_render_analog;
+  COMXCoreComponent m_omx_render_hdmi;
+  COMXCoreComponent m_omx_splitter;
   COMXCoreComponent m_omx_mixer;
   COMXCoreComponent m_omx_decoder;
-  COMXCoreTunel     m_omx_tunnel_clock;
+  COMXCoreTunel     m_omx_tunnel_clock_analog;
+  COMXCoreTunel     m_omx_tunnel_clock_hdmi;
   COMXCoreTunel     m_omx_tunnel_mixer;
   COMXCoreTunel     m_omx_tunnel_decoder;
+  COMXCoreTunel     m_omx_tunnel_splitter_analog;
+  COMXCoreTunel     m_omx_tunnel_splitter_hdmi;
   DllAvUtil         m_dllAvUtil;
 
-  OMX_AUDIO_CHANNELTYPE m_input_channels[OMX_AUDIO_MAXCHANNELS];
-  OMX_AUDIO_CHANNELTYPE m_output_channels[OMX_AUDIO_MAXCHANNELS];
-
-  CAEChannelInfo    m_channelLayout;
-
-  CAEChannelInfo    GetChannelLayout(AEAudioFormat format);
-
   void CheckOutputBufferSize(void **buffer, int *oldSize, int newSize);
   CCriticalSection m_critSection;
 };
diff -ur a/xbmc/cores/omxplayer/OMXImage.cpp b/xbmc/cores/omxplayer/OMXImage.cpp
--- a/xbmc/cores/omxplayer/OMXImage.cpp	2015-03-12 20:52:41.090096999 +0100
+++ b/xbmc/cores/omxplayer/OMXImage.cpp	2015-03-12 20:48:25.162096999 +0100
@@ -29,96 +29,468 @@
 #include "utils/log.h"
 #include "linux/XMemUtils.h"
 
-#include "utils/BitstreamConverter.h"
-
 #include <sys/time.h>
 #include <inttypes.h>
+#include "guilib/GraphicContext.h"
+#include "settings/AdvancedSettings.h"
 #include "settings/GUISettings.h"
 #include "settings/Settings.h"
-#include "settings/AdvancedSettings.h"
+#include "linux/RBP.h"
+#include "utils/URIUtils.h"
+#include "windowing/WindowingFactory.h"
+#include "Application.h"
+
+#ifdef _DEBUG
+#define CheckError() m_result = eglGetError(); if (m_result != EGL_SUCCESS) CLog::Log(LOGERROR, "EGL error in %s: %x",__FUNCTION__, m_result);
+#else
+#define CheckError()
+#endif
+
+#define EXIF_TAG_ORIENTATION    0x0112
+
+
+// A helper for restricting threads calling GPU functions to limit memory use
+// Experimentally, 3 outstanding operations is optimal
+static XbmcThreads::ConditionVariable g_count_cond;
+static CCriticalSection               g_count_lock;
+static int g_count_val;
+
+static void limit_calls_enter()
+{
+  CSingleLock lock(g_count_lock);
+  while (g_count_val >= 3)
+    g_count_cond.wait(lock);
+  g_count_val++;
+}
+
+static void limit_calls_leave()
+{
+  CSingleLock lock(g_count_lock);
+  g_count_val--;
+  g_count_cond.notifyAll();
+}
+
 
 #ifdef CLASSNAME
 #undef CLASSNAME
 #endif
 #define CLASSNAME "COMXImage"
 
-#define CONTENTURI_MAXLEN 256
+using namespace std;
+using namespace XFILE;
 
-#define EXIF_TAG_ORIENTATION    0x0112
+COMXImage::COMXImage()
+: CThread("CRBPWorker")
+{
+  m_egl_context = EGL_NO_CONTEXT;
+}
 
-static CCriticalSection g_OMXSection;
+COMXImage::~COMXImage()
+{
+  Deinitialize();
+}
 
-COMXImage::COMXImage()
+void COMXImage::Initialize()
 {
-  m_is_open       = false;
-  m_image_size    = 0;
-  m_image_buffer  = NULL;
-  m_progressive   = false;
-  m_alpha         = false;
-  m_orientation   = 0;
-  m_width         = 0;
-  m_height        = 0;
+  Create();
+}
 
-  m_is_open       = false;
-  m_decoded_buffer = NULL;
-  m_encoded_buffer = NULL;
+void COMXImage::Deinitialize()
+{
+  // wake up thread so it can quit
+  {
+    CSingleLock lock(m_texqueue_lock);
+    m_bStop = true;
+    m_texqueue_cond.notifyAll();
+  }
+  if (IsRunning())
+    StopThread();
+}
 
-  m_decoder_open  = false;
-  m_encoder_open  = false;
+bool COMXImage::CreateThumbnailFromSurface(unsigned char* buffer, unsigned int width, unsigned int height,
+      unsigned int format, unsigned int pitch, const CStdString& destFile)
+{
+  COMXImageEnc omxImageEnc;
+  bool ret = omxImageEnc.CreateThumbnailFromSurface(buffer, width, height, format, pitch, destFile);
+  if (!ret)
+    CLog::Log(LOGNOTICE, "%s: unable to create thumbnail %s %dx%d", __func__, destFile.c_str(), width, height);
+  return ret;
+}
 
-  OMX_INIT_STRUCTURE(m_decoded_format);
-  OMX_INIT_STRUCTURE(m_encoded_format);
-  memset(&m_omx_image, 0x0, sizeof(OMX_IMAGE_PORTDEFINITIONTYPE));
+COMXImageFile *COMXImage::LoadJpeg(const CStdString& texturePath)
+{
+  COMXImageFile *file = new COMXImageFile();
+  if (!file->ReadFile(texturePath))
+  {
+    CLog::Log(LOGNOTICE, "%s: unable to load %s", __func__, texturePath.c_str());
+    delete file;
+    file = NULL;
+  }
+  return file;
 }
 
-COMXImage::~COMXImage()
+void COMXImage::CloseJpeg(COMXImageFile *file)
 {
-  Close();
+  delete file;
 }
 
-void COMXImage::Close()
+bool COMXImage::DecodeJpeg(COMXImageFile *file, unsigned int width, unsigned int height, unsigned int stride, void *pixels)
 {
-  CSingleLock lock(g_OMXSection);
+  bool ret = false;
+  COMXImageDec omx_image;
+  if (omx_image.Decode(file->GetImageBuffer(), file->GetImageSize(), width, height, stride, pixels))
+  {
+    assert(width  == omx_image.GetDecodedWidth());
+    assert(height == omx_image.GetDecodedHeight());
+    assert(stride == omx_image.GetDecodedStride());
+    ret = true;
+  }
+  else
+    CLog::Log(LOGNOTICE, "%s: unable to decode %s %dx%d", __func__, file->GetFilename(), width, height);
+  omx_image.Close();
+  return ret;
+}
 
-  OMX_INIT_STRUCTURE(m_decoded_format);
-  OMX_INIT_STRUCTURE(m_encoded_format);
-  memset(&m_omx_image, 0x0, sizeof(OMX_IMAGE_PORTDEFINITIONTYPE));
+bool COMXImage::ClampLimits(unsigned int &width, unsigned int &height, unsigned int m_width, unsigned int m_height, bool transposed)
+{
+  RESOLUTION_INFO& res_info =  g_settings.m_ResInfo[g_graphicsContext.GetVideoResolution()];
+  unsigned int max_width = width;
+  unsigned int max_height = height;
+  const unsigned int gui_width = transposed ? res_info.iHeight:res_info.iWidth;
+  const unsigned int gui_height = transposed ? res_info.iWidth:res_info.iHeight;
+  const float aspect = (float)m_width / m_height;
+  bool clamped = false;
 
-  if(m_image_buffer)
-    free(m_image_buffer);
+  if (max_width == 0 || max_height == 0)
+  {
+    max_height = g_advancedSettings.m_imageRes;
 
-  m_image_buffer  = NULL;
-  m_image_size    = 0;
-  m_width         = 0;
-  m_height        = 0;
-  m_is_open       = false;
-  m_progressive   = false;
-  m_orientation   = 0;
-  m_decoded_buffer = NULL;
-  m_encoded_buffer = NULL;
+    if (g_advancedSettings.m_fanartRes > g_advancedSettings.m_imageRes)
+    { // 16x9 images larger than the fanart res use that rather than the image res
+      if (fabsf(aspect / (16.0f/9.0f) - 1.0f) <= 0.01f && m_height >= g_advancedSettings.m_fanartRes)
+      {
+        max_height = g_advancedSettings.m_fanartRes;
+      }
+    }
+    max_width = max_height * 16/9;
+  }
+
+  if (gui_width)
+    max_width = min(max_width, gui_width);
+  if (gui_height)
+    max_height = min(max_height, gui_height);
+
+  max_width  = min(max_width, 2048U);
+  max_height = min(max_height, 2048U);
 
-  if(m_decoder_open)
+  width = m_width;
+  height = m_height;
+  if (width > max_width || height > max_height)
   {
-    m_omx_decoder.FlushInput();
-    m_omx_decoder.FreeInputBuffers();
-    m_omx_resize.FlushOutput();
-    m_omx_resize.FreeOutputBuffers();
+    if ((unsigned int)(max_width / aspect + 0.5f) > max_height)
+      max_width = (unsigned int)(max_height * aspect + 0.5f);
+    else
+      max_height = (unsigned int)(max_width / aspect + 0.5f);
+    width = max_width;
+    height = max_height;
+    clamped = true;
+  }
 
-    m_omx_tunnel_decode.Flush();
-    m_omx_tunnel_decode.Flush();
-    m_omx_tunnel_decode.Deestablish();
-    m_omx_decoder.Deinitialize();
-    m_omx_resize.Deinitialize();
-    m_decoder_open = false;
+  return clamped;
+}
+
+bool COMXImage::CreateThumb(const CStdString& srcFile, unsigned int maxHeight, unsigned int maxWidth, std::string &additional_info, const CStdString& destFile)
+{
+  bool okay = false;
+  COMXImageFile file;
+  COMXImageReEnc reenc;
+  void *pDestBuffer;
+  unsigned int nDestSize;
+  if ((URIUtils::GetExtension(srcFile).Equals(".jpg") || URIUtils::GetExtension(srcFile).Equals(".tbn")) &&
+      file.ReadFile(srcFile) && reenc.ReEncode(file, maxWidth, maxHeight, pDestBuffer, nDestSize))
+  {
+    XFILE::CFile outfile;
+    if (outfile.OpenForWrite(destFile, true))
+    {
+      outfile.Write(pDestBuffer, nDestSize);
+      outfile.Close();
+      okay = true;
+    }
+    else
+      CLog::Log(LOGERROR, "%s: can't open output file: %s\n", __func__, destFile.c_str());
   }
+  return okay;
+}
 
-  if(m_encoder_open)
+bool COMXImage::SendMessage(bool (*callback)(EGLDisplay egl_display, EGLContext egl_context, void *cookie), void *cookie)
+{
+  // we can only call gl functions from the application thread or texture thread
+  if ( g_application.IsCurrentThread() )
   {
-    m_omx_encoder.Deinitialize();
-    m_encoder_open = false;
+    return callback(g_Windowing.GetEGLDisplay(), GetEGLContext(), cookie);
   }
+  struct callbackinfo mess;
+  mess.callback = callback;
+  mess.cookie = cookie;
+  mess.result = false;
+  mess.sync.Reset();
+  {
+    CSingleLock lock(m_texqueue_lock);
+    m_texqueue.push(&mess);
+    m_texqueue_cond.notifyAll();
+  }
+  // wait for function to have finished (in texture thread)
+  mess.sync.Wait();
+  // need to ensure texture thread has returned from mess.sync.Set() before we exit and free tex
+  CSingleLock lock(m_texqueue_lock);
+  return mess.result;
+}
 
-  m_pFile.Close();
+
+static bool AllocTextureCallback(EGLDisplay egl_display, EGLContext egl_context, void *cookie)
+{
+  struct COMXImage::textureinfo *tex = static_cast<struct COMXImage::textureinfo *>(cookie);
+  COMXImage *img = static_cast<COMXImage*>(tex->parent);
+  return img->AllocTextureInternal(egl_display, egl_context, tex);
+}
+
+bool COMXImage::AllocTextureInternal(EGLDisplay egl_display, EGLContext egl_context, struct textureinfo *tex)
+{
+  glGenTextures(1, (GLuint*) &tex->texture);
+  glBindTexture(GL_TEXTURE_2D, tex->texture);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+  GLenum type = g_guiSettings.GetBool("videoscreen.textures32") ? GL_UNSIGNED_BYTE:GL_UNSIGNED_SHORT_5_6_5;
+  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, tex->width, tex->height, 0, GL_RGB, type, 0);
+  tex->egl_image = eglCreateImageKHR(egl_display, egl_context, EGL_GL_TEXTURE_2D_KHR, (EGLClientBuffer)tex->texture, NULL);
+  if (!tex->egl_image)
+    CLog::Log(LOGDEBUG, "%s: eglCreateImageKHR failed to allocate", __func__);
+  GLint m_result;
+  CheckError();
+  return true;
+}
+
+void COMXImage::GetTexture(void *userdata, GLuint *texture)
+{
+  struct textureinfo *tex = static_cast<struct textureinfo *>(userdata);
+  *texture = tex->texture;
+}
+
+static bool DestroyTextureCallback(EGLDisplay egl_display, EGLContext egl_context, void *cookie)
+{
+  struct COMXImage::textureinfo *tex = static_cast<struct COMXImage::textureinfo *>(cookie);
+  COMXImage *img = static_cast<COMXImage*>(tex->parent);
+  return img->DestroyTextureInternal(egl_display, egl_context, tex);
+}
+
+void COMXImage::DestroyTexture(void *userdata)
+{
+  SendMessage(DestroyTextureCallback, userdata);
+}
+
+bool COMXImage::DestroyTextureInternal(EGLDisplay egl_display, EGLContext egl_context, struct textureinfo *tex)
+{
+  bool s = true;
+  if (tex->egl_image)
+  {
+    s = eglDestroyImageKHR(egl_display, tex->egl_image);
+    if (!s)
+      CLog::Log(LOGNOTICE, "%s: failed to destroy texture", __func__);
+  }
+  if (tex->texture)
+    glDeleteTextures(1, (GLuint*) &tex->texture);
+  return s;
+}
+
+bool COMXImage::DecodeJpegToTexture(COMXImageFile *file, unsigned int width, unsigned int height, void **userdata)
+{
+  bool ret = false;
+  COMXTexture omx_image;
+
+  struct textureinfo *tex = new struct textureinfo;
+  if (!tex)
+    return NULL;
+
+  tex->parent = (void *)this;
+  tex->width = width;
+  tex->height = height;
+  tex->texture = 0;
+  tex->egl_image = NULL;
+  tex->filename = file->GetFilename();
+
+  SendMessage(AllocTextureCallback, tex);
+
+  if (tex->egl_image && tex->texture && omx_image.Decode(file->GetImageBuffer(), file->GetImageSize(), width, height, tex->egl_image))
+  {
+    ret = true;
+    *userdata = tex;
+    CLog::Log(LOGDEBUG, "%s: decoded %s %dx%d", __func__, file->GetFilename(), width, height);
+  }
+  else
+  {
+    CLog::Log(LOGNOTICE, "%s: unable to decode to texture %s %dx%d", __func__, file->GetFilename(), width, height);
+    DestroyTexture(tex);
+  }
+  return ret;
+}
+
+EGLContext COMXImage::GetEGLContext()
+{
+  CSingleLock lock(m_texqueue_lock);
+  if (g_application.IsCurrentThread())
+    return g_Windowing.GetEGLContext();
+  if (m_egl_context == EGL_NO_CONTEXT)
+    CreateContext();
+  return m_egl_context;
+}
+
+static bool ChooseConfig(EGLDisplay display, const EGLint *configAttrs, EGLConfig *config)
+{
+  EGLBoolean eglStatus = true;
+  EGLint     configCount = 0;
+  EGLConfig* configList = NULL;
+  GLint m_result;
+  // Find out how many configurations suit our needs
+  eglStatus = eglChooseConfig(display, configAttrs, NULL, 0, &configCount);
+  CheckError();
+
+  if (!eglStatus || !configCount)
+  {
+    CLog::Log(LOGERROR, "EGL failed to return any matching configurations: %i", configCount);
+    return false;
+  }
+
+  // Allocate room for the list of matching configurations
+  configList = (EGLConfig*)malloc(configCount * sizeof(EGLConfig));
+  if (!configList)
+  {
+    CLog::Log(LOGERROR, "EGL failure obtaining configuration list");
+    return false;
+  }
+
+  // Obtain the configuration list from EGL
+  eglStatus = eglChooseConfig(display, configAttrs, configList, configCount, &configCount);
+  CheckError();
+  if (!eglStatus || !configCount)
+  {
+    CLog::Log(LOGERROR, "EGL failed to populate configuration list: %d", eglStatus);
+    return false;
+  }
+
+  // Select an EGL configuration that matches the native window
+  *config = configList[0];
+
+  free(configList);
+  return true;
+}
+
+void COMXImage::CreateContext()
+{
+  EGLConfig egl_config;
+  GLint m_result;
+  EGLDisplay egl_display = g_Windowing.GetEGLDisplay();
+
+  eglInitialize(egl_display, NULL, NULL);
+  CheckError();
+  eglBindAPI(EGL_OPENGL_ES_API);
+  CheckError();
+  static const EGLint contextAttrs [] = { EGL_CONTEXT_CLIENT_VERSION, 2, EGL_NONE };
+  static const EGLint configAttrs [] = {
+        EGL_RED_SIZE,        8,
+        EGL_GREEN_SIZE,      8,
+        EGL_BLUE_SIZE,       8,
+        EGL_ALPHA_SIZE,      8,
+        EGL_DEPTH_SIZE,     16,
+        EGL_STENCIL_SIZE,    0,
+        EGL_SAMPLE_BUFFERS,  0,
+        EGL_SAMPLES,         0,
+        EGL_SURFACE_TYPE,    EGL_WINDOW_BIT,
+        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
+        EGL_NONE
+  };
+  bool s = ChooseConfig(egl_display, configAttrs, &egl_config);
+  CheckError();
+  if (!s)
+  {
+    CLog::Log(LOGERROR, "%s: Could not find a compatible configuration",__FUNCTION__);
+    return;
+  }
+  m_egl_context = eglCreateContext(egl_display, egl_config, g_Windowing.GetEGLContext(), contextAttrs);
+  CheckError();
+  if (m_egl_context == EGL_NO_CONTEXT)
+  {
+    CLog::Log(LOGERROR, "%s: Could not create a context",__FUNCTION__);
+    return;
+  }
+  EGLSurface egl_surface = eglCreatePbufferSurface(egl_display, egl_config, NULL);
+  CheckError();
+  if (egl_surface == EGL_NO_SURFACE)
+  {
+    CLog::Log(LOGERROR, "%s: Could not create a surface",__FUNCTION__);
+    return;
+  }
+  s = eglMakeCurrent(egl_display, egl_surface, egl_surface, m_egl_context);
+  CheckError();
+  if (!s)
+  {
+    CLog::Log(LOGERROR, "%s: Could not make current",__FUNCTION__);
+    return;
+  }
+}
+
+void COMXImage::Process()
+{
+  while(!m_bStop)
+  {
+    CSingleLock lock(m_texqueue_lock);
+    if (m_texqueue.empty())
+    {
+      m_texqueue_cond.wait(lock);
+    }
+    else
+    {
+      struct callbackinfo *mess = m_texqueue.front();
+      m_texqueue.pop();
+      lock.Leave();
+
+      mess->result = mess->callback(g_Windowing.GetEGLDisplay(), GetEGLContext(), mess->cookie);
+      {
+        CSingleLock lock(m_texqueue_lock);
+        mess->sync.Set();
+      }
+    }
+  }
+}
+
+void COMXImage::OnStartup()
+{
+}
+
+void COMXImage::OnExit()
+{
+}
+
+#ifdef CLASSNAME
+#undef CLASSNAME
+#endif
+#define CLASSNAME "COMXImageFile"
+
+COMXImageFile::COMXImageFile()
+{
+  m_image_size    = 0;
+  m_image_buffer  = NULL;
+  m_orientation   = 0;
+  m_width         = 0;
+  m_height        = 0;
+  m_filename      = "";
+}
+
+COMXImageFile::~COMXImageFile()
+{
+  if(m_image_buffer)
+    free(m_image_buffer);
 }
 
 typedef enum {      /* JPEG marker codes */
@@ -195,45 +567,59 @@
   M_TEM   = 0x01,
 } JPEG_MARKER;
 
-OMX_IMAGE_CODINGTYPE COMXImage::GetCodingType()
+static uint8_t inline READ8(uint8_t * &p)
 {
-  memset(&m_omx_image, 0x0, sizeof(OMX_IMAGE_PORTDEFINITIONTYPE));
-  m_width         = 0;
-  m_height        = 0;
-  m_progressive   = false;
-  m_orientation   = 0;
+  uint8_t r = p[0];
+  p += 1;
+  return r;
+}
+
+static uint16_t inline READ16(uint8_t * &p)
+{
+  uint16_t r = (p[0] << 8) | p[1];
+  p += 2;
+  return r;
+}
+
+static uint32_t inline READ32(uint8_t * &p)
+{
+  uint32_t r = (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];
+  p += 4;
+  return r;
+}
+
+static void inline SKIPN(uint8_t * &p, unsigned int n)
+{
+  p += n;
+}
 
-  m_omx_image.eCompressionFormat = OMX_IMAGE_CodingMax;
+OMX_IMAGE_CODINGTYPE COMXImageFile::GetCodingType(unsigned int &width, unsigned int &height, int orientation)
+{
+  OMX_IMAGE_CODINGTYPE eCompressionFormat = OMX_IMAGE_CodingMax;
+  bool progressive = false;
+  int components = 0;
+  m_orientation   = 0;
 
   if(!m_image_size)
     return OMX_IMAGE_CodingMax;
 
-  bits_reader_t br;
-  CBitstreamConverter::bits_reader_set( &br, m_image_buffer, m_image_size );
+  uint8_t *p = m_image_buffer;
+  uint8_t *q = m_image_buffer + m_image_size;
 
   /* JPEG Header */
-  if(CBitstreamConverter::read_bits(&br, 16) == 0xFFD8)
+  if(READ16(p) == 0xFFD8)
   {
-    m_omx_image.eCompressionFormat = OMX_IMAGE_CodingJPEG;
+    eCompressionFormat = OMX_IMAGE_CodingJPEG;
 
-    CBitstreamConverter::read_bits(&br, 8);
-    unsigned char marker = CBitstreamConverter::read_bits(&br, 8);
+    READ8(p);
+    unsigned char marker = READ8(p);
     unsigned short block_size = 0;
     bool nMarker = false;
 
-    while(!br.oflow) {
-
+    while(p < q)
+    {
       switch(marker)
       {
-        case M_TEM:
-        case M_DRI:
-          CBitstreamConverter::skip_bits(&br, 16);
-          continue;
-        case M_SOI:
-        case M_EOI:
-          continue;
-        
-        case M_SOS:
         case M_DQT:
         case M_DNL:
         case M_DHP:
@@ -292,10 +678,11 @@
         case M_JPG13:
         case M_JPG14:
         case M_COM:
-          block_size = CBitstreamConverter::read_bits(&br, 16);
+          block_size = READ16(p);
           nMarker = true;
           break;
 
+        case M_SOS:
         default:
           nMarker = false;
           break;
@@ -310,27 +697,33 @@
       {
         if(marker == M_SOF2 || marker == M_SOF6 || marker == M_SOF10 || marker == M_SOF14)
         {
-          m_progressive = true;
+          progressive = true;
         }
-        CBitstreamConverter::skip_bits(&br, 8);
-        m_omx_image.nFrameHeight = CBitstreamConverter::read_bits(&br, 16);
-        m_omx_image.nFrameWidth = CBitstreamConverter::read_bits(&br, 16);
-        CBitstreamConverter::skip_bits(&br, 8 * (block_size - 9));
+        int readBits = 2;
+        SKIPN(p, 1);
+        readBits ++;
+        height = READ16(p);
+        readBits += 2;
+        width = READ16(p);
+        readBits += 2;
+        components = READ8(p);
+        readBits += 1;
+        SKIPN(p, 1 * (block_size - readBits));
       }
       else if(marker == M_APP1)
       {
         int readBits = 2;
-        bool bMotorolla = false;
-        bool bError = false;
 
         // Exif header
-        if(CBitstreamConverter::read_bits(&br, 32) == 0x45786966)
+        if(READ32(p) == 0x45786966)
         {
-          CBitstreamConverter::skip_bits(&br, 8 * 2);
+          bool bMotorolla = false;
+          bool bError = false;
+          SKIPN(p, 1 * 2);
           readBits += 2;
         
-          char o1 = CBitstreamConverter::read_bits(&br, 8);
-          char o2 = CBitstreamConverter::read_bits(&br, 8);
+          char o1 = READ8(p);
+          char o2 = READ8(p);
           readBits += 2;
 
           /* Discover byte order */
@@ -341,7 +734,7 @@
           else
             bError = true;
         
-          CBitstreamConverter::skip_bits(&br, 8 * 2);
+          SKIPN(p, 1 * 2);
           readBits += 2;
 
           if(!bError)
@@ -351,61 +744,61 @@
             // Get first IFD offset (offset to IFD0)
             if(bMotorolla)
             {
-              CBitstreamConverter::skip_bits(&br, 8 * 2);
+              SKIPN(p, 1 * 2);
               readBits += 2;
 
-              a = CBitstreamConverter::read_bits(&br, 8);
-              b = CBitstreamConverter::read_bits(&br, 8);
+              a = READ8(p);
+              b = READ8(p);
               readBits += 2;
               offset = (a << 8) + b;
             }
             else
             {
-              a = CBitstreamConverter::read_bits(&br, 8);
-              b = CBitstreamConverter::read_bits(&br, 8);
+              a = READ8(p);
+              b = READ8(p);
               readBits += 2;
               offset = (b << 8) + a;
 
-              CBitstreamConverter::skip_bits(&br, 8 * 2);
+              SKIPN(p, 1 * 2);
               readBits += 2;
             }
 
             offset -= 8;
             if(offset > 0)
             {
-              CBitstreamConverter::skip_bits(&br, 8 * offset);
+              SKIPN(p, 1 * offset);
               readBits += offset;
             } 
 
             // Get the number of directory entries contained in this IFD
             if(bMotorolla)
             {
-              a = CBitstreamConverter::read_bits(&br, 8);
-              b = CBitstreamConverter::read_bits(&br, 8);
+              a = READ8(p);
+              b = READ8(p);
               numberOfTags = (a << 8) + b;
             }
             else
             {
-              a = CBitstreamConverter::read_bits(&br, 8);
-              b = CBitstreamConverter::read_bits(&br, 8);
+              a = READ8(p);
+              b = READ8(p);
               numberOfTags = (b << 8) + a;
             }
             readBits += 2;
 
-            while(numberOfTags && !br.oflow)
+            while(numberOfTags && p < q)
             {
               // Get Tag number
               if(bMotorolla)
               {
-                a = CBitstreamConverter::read_bits(&br, 8);
-                b = CBitstreamConverter::read_bits(&br, 8);
+                a = READ8(p);
+                b = READ8(p);
                 tagNumber = (a << 8) + b;
                 readBits += 2;
               }
               else
               {
-                a = CBitstreamConverter::read_bits(&br, 8);
-                b = CBitstreamConverter::read_bits(&br, 8);
+                a = READ8(p);
+                b = READ8(p);
                 tagNumber = (b << 8) + a;
                 readBits += 2;
               }
@@ -415,27 +808,27 @@
               {
                 if(bMotorolla)
                 {
-                  CBitstreamConverter::skip_bits(&br, 8 * 7);
+                  SKIPN(p, 1 * 7);
                   readBits += 7;
-                  m_orientation = CBitstreamConverter::read_bits(&br, 8);
+                  m_orientation = READ8(p)-1;
                   readBits += 1;
-                  CBitstreamConverter::skip_bits(&br, 8 * 2);
+                  SKIPN(p, 1 * 2);
                   readBits += 2;
                 }
                 else
                 {
-                  CBitstreamConverter::skip_bits(&br, 8 * 6);
+                  SKIPN(p, 1 * 6);
                   readBits += 6;
-                  m_orientation = CBitstreamConverter::read_bits(&br, 8);
+                  m_orientation = READ8(p)-1;
                   readBits += 1;
-                  CBitstreamConverter::skip_bits(&br, 8 * 3);
+                  SKIPN(p, 1 * 3);
                   readBits += 3;
                 }
                 break;
               }
               else
               {
-                CBitstreamConverter::skip_bits(&br, 8 * 10);
+                SKIPN(p, 1 * 10);
                 readBits += 10;
               }
               numberOfTags--;
@@ -443,100 +836,53 @@
           }
         }
         readBits += 4;
-        CBitstreamConverter::skip_bits(&br, 8 * (block_size - readBits));
+        SKIPN(p, 1 * (block_size - readBits));
       }
       else
       {
-        CBitstreamConverter::skip_bits(&br, 8 * (block_size - 2));
+        SKIPN(p, 1 * (block_size - 2));
       }
 
-      CBitstreamConverter::read_bits(&br, 8);
-      marker = CBitstreamConverter::read_bits(&br, 8);
+      READ8(p);
+      marker = READ8(p);
 
     }
-
   }
 
-  CBitstreamConverter::bits_reader_set( &br, m_image_buffer, m_image_size );
+  // apply input orientation
+  m_orientation = m_orientation ^ orientation;
+  if(m_orientation < 0 || m_orientation >= 8)
+    m_orientation = 0;
 
-  /* PNG Header */
-  if(CBitstreamConverter::read_bits(&br, 32) == 0x89504E47)
+  if(eCompressionFormat == OMX_IMAGE_CodingMax)
   {
-    m_omx_image.eCompressionFormat = OMX_IMAGE_CodingPNG;
-    CBitstreamConverter::skip_bits(&br, 32 * 2);
-    if(CBitstreamConverter::read_bits(&br, 32) == 0x49484452)
-    {
-      m_omx_image.nFrameWidth = CBitstreamConverter::read_bits(&br, 32);
-      m_omx_image.nFrameHeight = CBitstreamConverter::read_bits(&br, 32);
-      (void)CBitstreamConverter::read_bits(&br, 8); // bit depth
-      unsigned int coding_type = CBitstreamConverter::read_bits(&br, 8);
-      m_alpha = coding_type==4 || coding_type==6;
-    }
+    CLog::Log(LOGERROR, "%s::%s error unsupported image format\n", CLASSNAME, __func__);
   }
 
-  if(m_orientation > 8)
-    m_orientation = 0;
+  if(progressive)
+  {
+    CLog::Log(LOGWARNING, "%s::%s progressive images not supported by decoder\n", CLASSNAME, __func__);
+    eCompressionFormat = OMX_IMAGE_CodingMax;
+  }
 
-  m_width  = m_omx_image.nFrameWidth;
-  m_height = m_omx_image.nFrameHeight;
+  if(components > 3)
+  {
+    CLog::Log(LOGWARNING, "%s::%s Only YUV images are supported by decoder\n", CLASSNAME, __func__);
+    eCompressionFormat = OMX_IMAGE_CodingMax;
+  }
 
-  return m_omx_image.eCompressionFormat;
+  return eCompressionFormat;
 }
 
-bool COMXImage::ClampLimits(unsigned int &width, unsigned int &height)
-{
-  RESOLUTION_INFO& res_info =  g_settings.m_ResInfo[g_graphicsContext.GetVideoResolution()];
-  const bool transposed = m_orientation & 4;
-  unsigned int max_width = width;
-  unsigned int max_height = height;
-  const unsigned int gui_width  = transposed ? res_info.iHeight:res_info.iWidth;
-  const unsigned int gui_height = transposed ? res_info.iWidth:res_info.iHeight;
-  const float aspect = (float)m_width / m_height;
 
-  if (max_width == 0 || max_height == 0)
+bool COMXImageFile::ReadFile(const CStdString& inputFile, int orientation)
+{
+  XFILE::CFile      m_pFile;
+  m_filename = inputFile.c_str();
+  if(!m_pFile.Open(inputFile, 0))
   {
-    max_height = g_advancedSettings.m_imageRes;
-
-    if (g_advancedSettings.m_fanartRes > g_advancedSettings.m_imageRes)
-    { // 16x9 images larger than the fanart res use that rather than the image res
-      if (fabsf(aspect / (16.0f/9.0f) - 1.0f) <= 0.01f && m_height >= g_advancedSettings.m_fanartRes)
-      {
-        max_height = g_advancedSettings.m_fanartRes;
-      }
-    }
-    max_width = max_height * 16/9;
-  }
-
-  if (gui_width)
-    max_width = min(max_width, gui_width);
-  if (gui_height)
-    max_height = min(max_height, gui_height);
-
-  max_width  = min(max_width, 2048U);
-  max_height = min(max_height, 2048U);
-
-
-  width = m_width;
-  height = m_height;
-  if (width > max_width || height > max_height)
-  {
-    if ((unsigned int)(max_width / aspect + 0.5f) > max_height)
-      max_width = (unsigned int)(max_height * aspect + 0.5f);
-    else
-      max_height = (unsigned int)(max_width / aspect + 0.5f);
-    width = max_width;
-    height = max_height;
-    return true;
-  }
-  return false;
-}
-
-bool COMXImage::ReadFile(const CStdString& inputFile)
-{
-  if(!m_pFile.Open(inputFile, 0))
-  {
-    CLog::Log(LOGERROR, "%s::%s %s not found\n", CLASSNAME, __func__, inputFile.c_str());
-    return false;
+    CLog::Log(LOGERROR, "%s::%s %s not found\n", CLASSNAME, __func__, inputFile.c_str());
+    return false;
   }
 
   if(m_image_buffer)
@@ -545,34 +891,87 @@
 
   m_image_size = m_pFile.GetLength();
 
-  if(!m_image_size) {
+  if(!m_image_size)
+  {
     CLog::Log(LOGERROR, "%s::%s %s m_image_size zero\n", CLASSNAME, __func__, inputFile.c_str());
     return false;
   }
   m_image_buffer = (uint8_t *)malloc(m_image_size);
-  if(!m_image_buffer) {
+  if(!m_image_buffer)
+  {
     CLog::Log(LOGERROR, "%s::%s %s m_image_buffer null (%lu)\n", CLASSNAME, __func__, inputFile.c_str(), m_image_size);
     return false;
   }
   
   m_pFile.Read(m_image_buffer, m_image_size);
+  m_pFile.Close();
 
-  if(GetCodingType() != OMX_IMAGE_CodingJPEG) {
-    CLog::Log(LOGERROR, "%s::%s %s GetCodingType=0x%x\n", CLASSNAME, __func__, inputFile.c_str(), GetCodingType());
+  OMX_IMAGE_CODINGTYPE eCompressionFormat = GetCodingType(m_width, m_height, orientation);
+  if(eCompressionFormat != OMX_IMAGE_CodingJPEG)
+  {
+    CLog::Log(LOGERROR, "%s::%s %s GetCodingType=0x%x\n", CLASSNAME, __func__, inputFile.c_str(), eCompressionFormat);
     return false;
   }
 
-  if(m_width < 1 || m_height < 1) {
+  if(m_width < 1 || m_height < 1)
+  {
     CLog::Log(LOGERROR, "%s::%s %s m_width=%d m_height=%d\n", CLASSNAME, __func__, inputFile.c_str(), m_width, m_height);
     return false;
   }
 
-  m_is_open = true;
-
   return true;
 }
 
-bool COMXImage::HandlePortSettingChange(unsigned int resize_width, unsigned int resize_height)
+#ifdef CLASSNAME
+#undef CLASSNAME
+#endif
+#define CLASSNAME "COMXImageDec"
+
+COMXImageDec::COMXImageDec()
+{
+  limit_calls_enter();
+  m_decoded_buffer = NULL;
+  OMX_INIT_STRUCTURE(m_decoded_format);
+  m_success = false;
+}
+
+COMXImageDec::~COMXImageDec()
+{
+  Close();
+
+  OMX_INIT_STRUCTURE(m_decoded_format);
+  m_decoded_buffer = NULL;
+  limit_calls_leave();
+}
+
+void COMXImageDec::Close()
+{
+  CSingleLock lock(m_OMXSection);
+
+  if (!m_success)
+  {
+    if(m_omx_decoder.IsInitialized())
+    {
+      m_omx_decoder.SetStateForComponent(OMX_StateIdle);
+      m_omx_decoder.FlushInput();
+      m_omx_decoder.FreeInputBuffers();
+    }
+    if(m_omx_resize.IsInitialized())
+    {
+      m_omx_resize.SetStateForComponent(OMX_StateIdle);
+      m_omx_resize.FlushOutput();
+      m_omx_resize.FreeOutputBuffers();
+    }
+  }
+  if(m_omx_tunnel_decode.IsInitialized())
+    m_omx_tunnel_decode.Deestablish();
+  if(m_omx_decoder.IsInitialized())
+    m_omx_decoder.Deinitialize();
+  if(m_omx_resize.IsInitialized())
+    m_omx_resize.Deinitialize();
+}
+
+bool COMXImageDec::HandlePortSettingChange(unsigned int resize_width, unsigned int resize_height, unsigned int resize_stride)
 {
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
   // on the first port settings changed event, we create the tunnel and alloc the buffer
@@ -583,12 +982,15 @@
 
     port_def.nPortIndex = m_omx_decoder.GetOutputPort();
     m_omx_decoder.GetParameter(OMX_IndexParamPortDefinition, &port_def);
+    port_def.format.image.nSliceHeight = 16;
+    m_omx_decoder.SetParameter(OMX_IndexParamPortDefinition, &port_def);
+
     port_def.nPortIndex = m_omx_resize.GetInputPort();
     m_omx_resize.SetParameter(OMX_IndexParamPortDefinition, &port_def);
 
     m_omx_tunnel_decode.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_resize, m_omx_resize.GetInputPort());
 
-    omx_err = m_omx_tunnel_decode.Establish(false);
+    omx_err = m_omx_tunnel_decode.Establish();
     if(omx_err != OMX_ErrorNone)
     {
       CLog::Log(LOGERROR, "%s::%s m_omx_tunnel_decode.Establish\n", CLASSNAME, __func__);
@@ -609,7 +1011,7 @@
     port_def.format.image.eColorFormat = OMX_COLOR_Format32bitARGB8888;
     port_def.format.image.nFrameWidth = resize_width;
     port_def.format.image.nFrameHeight = resize_height;
-    port_def.format.image.nStride = resize_width*4;
+    port_def.format.image.nStride = resize_stride;
     port_def.format.image.nSliceHeight = 0;
     port_def.format.image.bFlagErrorConcealment = OMX_FALSE;
 
@@ -630,7 +1032,7 @@
     }
     assert(m_decoded_format.nBufferCountActual == 1);
 
-    omx_err = m_omx_resize.AllocOutputBuffers();//false, true);
+    omx_err = m_omx_resize.AllocOutputBuffers();
     if(omx_err != OMX_ErrorNone)
     {
       CLog::Log(LOGERROR, "%s::%s m_omx_resize.AllocOutputBuffers result(0x%x)\n", CLASSNAME, __func__, omx_err);
@@ -686,66 +1088,50 @@
   return true;
 }
 
-bool COMXImage::Decode(unsigned width, unsigned height)
+bool COMXImageDec::Decode(const uint8_t *demuxer_content, unsigned demuxer_bytes, unsigned width, unsigned height, unsigned stride, void *pixels)
 {
-  CSingleLock lock(g_OMXSection);
-  std::string componentName = "";
-  unsigned int demuxer_bytes = 0;
-  const uint8_t *demuxer_content = NULL;
+  CSingleLock lock(m_OMXSection);
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
   OMX_BUFFERHEADERTYPE *omx_buffer = NULL;
 
-  if(!m_image_buffer)
+  if(!demuxer_content || !demuxer_bytes)
   {
     CLog::Log(LOGERROR, "%s::%s no input buffer\n", CLASSNAME, __func__);
     return false;
   }
 
-  if(GetCompressionFormat() == OMX_IMAGE_CodingMax)
-  {
-    CLog::Log(LOGERROR, "%s::%s error unsupported image format\n", CLASSNAME, __func__);
-    return false;
-  }
-
-  if(IsProgressive())
+  if(!m_omx_decoder.Initialize("OMX.broadcom.image_decode", OMX_IndexParamImageInit))
   {
-    CLog::Log(LOGWARNING, "%s::%s progressive images not supported by decoder\n", CLASSNAME, __func__);
+    CLog::Log(LOGERROR, "%s::%s error m_omx_decoder.Initialize\n", CLASSNAME, __func__);
     return false;
   }
 
-  if(!m_is_open)
+  if(!m_omx_resize.Initialize("OMX.broadcom.resize", OMX_IndexParamImageInit))
   {
-    CLog::Log(LOGERROR, "%s::%s error not opened\n", CLASSNAME, __func__);
+    CLog::Log(LOGERROR, "%s::%s error m_omx_resize.Initialize\n", CLASSNAME, __func__);
     return false;
   }
 
-  componentName = "OMX.broadcom.image_decode";
-  if(!m_omx_decoder.Initialize((const std::string)componentName, OMX_IndexParamImageInit))
-  {
-    CLog::Log(LOGERROR, "%s::%s error m_omx_decoder.Initialize\n", CLASSNAME, __func__);
-    return false;
-  }
+  // set input format
+  OMX_PARAM_PORTDEFINITIONTYPE portParam;
+  OMX_INIT_STRUCTURE(portParam);
+  portParam.nPortIndex = m_omx_decoder.GetInputPort();
 
-  componentName = "OMX.broadcom.resize";
-  if(!m_omx_resize.Initialize((const std::string)componentName, OMX_IndexParamImageInit))
+  omx_err = m_omx_decoder.GetParameter(OMX_IndexParamPortDefinition, &portParam);
+  if(omx_err != OMX_ErrorNone)
   {
-    CLog::Log(LOGERROR, "%s::%s error m_omx_resize.Initialize\n", CLASSNAME, __func__);
+    CLog::Log(LOGERROR, "%s::%s error GetParameter:OMX_IndexParamPortDefinition omx_err(0x%08x)\n", CLASSNAME, __func__, omx_err);
     return false;
   }
 
-  m_decoder_open = true;
-  ClampLimits(width, height);
+  portParam.nBufferCountActual = portParam.nBufferCountMin;
+  portParam.nBufferSize = std::max(portParam.nBufferSize, ALIGN_UP(demuxer_bytes, portParam.nBufferAlignment));
+  portParam.format.image.eCompressionFormat = OMX_IMAGE_CodingJPEG;
 
-  // set input format
-  OMX_IMAGE_PARAM_PORTFORMATTYPE imagePortFormat;
-  OMX_INIT_STRUCTURE(imagePortFormat);
-  imagePortFormat.nPortIndex = m_omx_decoder.GetInputPort();
-  imagePortFormat.eCompressionFormat = OMX_IMAGE_CodingJPEG;
-
-  omx_err = m_omx_decoder.SetParameter(OMX_IndexParamImagePortFormat, &imagePortFormat);
+  omx_err = m_omx_decoder.SetParameter(OMX_IndexParamPortDefinition, &portParam);
   if(omx_err != OMX_ErrorNone)
   {
-    CLog::Log(LOGERROR, "%s::%s m_omx_decoder.SetParameter OMX_IndexParamImagePortFormat result(0x%x)\n", CLASSNAME, __func__, omx_err);
+    CLog::Log(LOGERROR, "%s::%s error SetParameter:OMX_IndexParamPortDefinition omx_err(0x%08x)\n", CLASSNAME, __func__, omx_err);
     return false;
   }
 
@@ -763,11 +1149,6 @@
     return false;
   }
 
-  demuxer_bytes   = GetImageSize();
-  demuxer_content = GetImageBuffer();
-  if(!demuxer_bytes || !demuxer_content)
-    return false;
-
   while(demuxer_bytes > 0 || !m_decoded_buffer)
   {
     long timeout = 0;
@@ -795,7 +1176,7 @@
          return false;
        }
     }
-    else
+    if (!demuxer_bytes)
     {
        // we've submitted all buffers so can wait now
        timeout = 1000;
@@ -803,41 +1184,70 @@
     omx_err = m_omx_decoder.WaitForEvent(OMX_EventPortSettingsChanged, timeout);
     if(omx_err == OMX_ErrorNone)
     {
-      if (!HandlePortSettingChange(width, height))
+      if (!HandlePortSettingChange(width, height, stride))
       {
         CLog::Log(LOGERROR, "%s::%s HandlePortSettingChange() failed\n", CLASSNAME, __func__);
         return false;
       }
     }
-    // we treat it as an error if a real timeout occurred
-    else  if (timeout)
+    else if(omx_err == OMX_ErrorStreamCorrupt)
+    {
+      CLog::Log(LOGERROR, "%s::%s - image not supported", CLASSNAME, __func__);
+      return false;
+    }
+    else if(timeout || omx_err != OMX_ErrorTimeout)
     {
-      CLog::Log(LOGERROR, "%s::%s HandlePortSettingChange() failed\n", CLASSNAME, __func__);
+      CLog::Log(LOGERROR, "%s::%s WaitForEvent:OMX_EventPortSettingsChanged failed (%x)\n", CLASSNAME, __func__, omx_err);
       return false;
     }
   }
 
-  omx_err = m_omx_decoder.WaitForEvent(OMX_EventBufferFlag, 1000);
+  omx_err = m_omx_resize.WaitForOutputDone(1000);
   if(omx_err != OMX_ErrorNone)
   {
-    CLog::Log(LOGERROR, "%s::%s m_omx_decoder.WaitForEvent result(0x%x)\n", CLASSNAME, __func__, omx_err);
+    CLog::Log(LOGERROR, "%s::%s m_omx_resize.WaitForOutputDone result(0x%x)\n", CLASSNAME, __func__, omx_err);
     return false;
   }
 
-  m_omx_tunnel_decode.Deestablish();
-
   if(m_omx_decoder.BadState())
     return false;
 
+  memcpy( (char*)pixels, m_decoded_buffer->pBuffer, stride * height);
+
+  m_success = true;
+  Close();
   return true;
 }
 
+#ifdef CLASSNAME
+#undef CLASSNAME
+#endif
+#define CLASSNAME "COMXImageEnc"
+
+COMXImageEnc::COMXImageEnc()
+{
+  limit_calls_enter();
+  CSingleLock lock(m_OMXSection);
+  OMX_INIT_STRUCTURE(m_encoded_format);
+  m_encoded_buffer = NULL;
+  m_success = false;
+}
 
-bool COMXImage::Encode(unsigned char *buffer, int size, unsigned width, unsigned height, unsigned int pitch)
+COMXImageEnc::~COMXImageEnc()
 {
-  CSingleLock lock(g_OMXSection);
+  CSingleLock lock(m_OMXSection);
+
+  OMX_INIT_STRUCTURE(m_encoded_format);
+  m_encoded_buffer = NULL;
+  if(m_omx_encoder.IsInitialized())
+    m_omx_encoder.Deinitialize();
+  limit_calls_leave();
+}
+
+bool COMXImageEnc::Encode(unsigned char *buffer, int size, unsigned width, unsigned height, unsigned int pitch)
+{
+  CSingleLock lock(m_OMXSection);
 
-  std::string componentName = "";
   unsigned int demuxer_bytes = 0;
   const uint8_t *demuxer_content = NULL;
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
@@ -853,15 +1263,12 @@
     return false;
   }
 
-  componentName = "OMX.broadcom.image_encode";
-  if(!m_omx_encoder.Initialize((const std::string)componentName, OMX_IndexParamImageInit))
+  if(!m_omx_encoder.Initialize("OMX.broadcom.image_encode", OMX_IndexParamImageInit))
   {
     CLog::Log(LOGERROR, "%s::%s error m_omx_encoder.Initialize\n", CLASSNAME, __func__);
     return false;
   }
 
-  m_encoder_open = true;
-
   OMX_PARAM_PORTDEFINITIONTYPE port_def;
   OMX_INIT_STRUCTURE(port_def);
   port_def.nPortIndex = m_omx_encoder.GetInputPort();
@@ -991,10 +1398,10 @@
   if(omx_err != OMX_ErrorNone)
     return false;
 
-  omx_err = m_omx_encoder.WaitForEvent(OMX_EventBufferFlag, 1000);
+  omx_err = m_omx_encoder.WaitForOutputDone(1000);
   if(omx_err != OMX_ErrorNone)
   {
-    CLog::Log(LOGERROR, "%s::%s m_omx_encoder WaitForEvent result(0x%x)\n", CLASSNAME, __func__, omx_err);
+    CLog::Log(LOGERROR, "%s::%s m_omx_resize.WaitForOutputDone result(0x%x)\n", CLASSNAME, __func__, omx_err);
     return false;
   }
 
@@ -1012,110 +1419,849 @@
   return true;
 }
 
-unsigned char *COMXImage::GetDecodedData()
+bool COMXImageEnc::CreateThumbnailFromSurface(unsigned char* buffer, unsigned int width, unsigned int height,
+    unsigned int format, unsigned int pitch, const CStdString& destFile)
 {
-  if(!m_decoded_buffer)
-    return NULL;
+  if(format != XB_FMT_A8R8G8B8 || !buffer)
+  {
+    CLog::Log(LOGDEBUG, "%s::%s : %s failed format=0x%x\n", CLASSNAME, __func__, destFile.c_str(), format);
+    return false;
+  }
 
-  return (unsigned char *)m_decoded_buffer->pBuffer;
-}
+  if(!Encode(buffer, height * pitch, width, height, pitch))
+  {
+    CLog::Log(LOGDEBUG, "%s::%s : %s encode failed\n", CLASSNAME, __func__, destFile.c_str());
+    return false;
+  }
 
-unsigned int COMXImage::GetDecodedSize()
-{
-  if(!m_decoded_buffer)
-    return 0;
-  return (unsigned int)m_decoded_buffer->nFilledLen;
+  XFILE::CFile file;
+  if (file.OpenForWrite(destFile, true))
+  {
+    CLog::Log(LOGDEBUG, "%s::%s : %s width %d height %d\n", CLASSNAME, __func__, destFile.c_str(), width, height);
+
+    file.Write(m_encoded_buffer->pBuffer, m_encoded_buffer->nFilledLen);
+    file.Close();
+    return true;
+  }
+
+  return false;
 }
 
-unsigned char *COMXImage::GetEncodedData()
-{
-  if(!m_encoded_buffer)
-    return NULL;
+#ifdef CLASSNAME
+#undef CLASSNAME
+#endif
+#define CLASSNAME "COMXReEnc"
 
-  return (unsigned char *)m_encoded_buffer->pBuffer;
+COMXImageReEnc::COMXImageReEnc()
+{
+  limit_calls_enter();
+  m_encoded_buffer = NULL;
+  m_pDestBuffer = NULL;
+  m_nDestAllocSize = 0;
+  m_success = false;
 }
 
-unsigned int COMXImage::GetEncodedSize()
+COMXImageReEnc::~COMXImageReEnc()
 {
-  if(!m_encoded_buffer)
-    return 0;
-  return (unsigned int)m_encoded_buffer->nFilledLen;
+  Close();
+  if (m_pDestBuffer)
+    free (m_pDestBuffer);
+  m_pDestBuffer = NULL;
+  m_nDestAllocSize = 0;
+  limit_calls_leave();
 }
 
-bool COMXImage::SwapBlueRed(unsigned char *pixels, unsigned int height, unsigned int pitch, 
-  unsigned int elements, unsigned int offset)
+void COMXImageReEnc::Close()
 {
-  if (!pixels) return false;
-  unsigned char *dst = pixels;
-  for (unsigned int y = 0; y < height; y++)
+  CSingleLock lock(m_OMXSection);
+
+  if (!m_success)
   {
-    dst = pixels + (y * pitch);
-    for (unsigned int x = 0; x < pitch; x+=elements)
-      std::swap(dst[x+offset], dst[x+2+offset]);
+    if(m_omx_decoder.IsInitialized())
+    {
+      m_omx_decoder.SetStateForComponent(OMX_StateIdle);
+      m_omx_decoder.FlushInput();
+      m_omx_decoder.FreeInputBuffers();
+    }
+    if(m_omx_resize.IsInitialized())
+    {
+      m_omx_resize.SetStateForComponent(OMX_StateIdle);
+    }
+    if(m_omx_encoder.IsInitialized())
+    {
+      m_omx_encoder.SetStateForComponent(OMX_StateIdle);
+      m_omx_encoder.FlushOutput();
+      m_omx_encoder.FreeOutputBuffers();
+    }
   }
-  return true;
+  if(m_omx_tunnel_decode.IsInitialized())
+    m_omx_tunnel_decode.Deestablish();
+  if(m_omx_tunnel_resize.IsInitialized())
+    m_omx_tunnel_resize.Deestablish();
+  if(m_omx_decoder.IsInitialized())
+    m_omx_decoder.Deinitialize();
+  if(m_omx_resize.IsInitialized())
+    m_omx_resize.Deinitialize();
+  if(m_omx_encoder.IsInitialized())
+    m_omx_encoder.Deinitialize();
 }
 
-bool COMXImage::CreateThumbnail(const CStdString& sourceFile, const CStdString& destFile, 
-    int minx, int miny, bool rotateExif)
-{
-  if (!ReadFile(sourceFile))
-    return false;
 
-  return CreateThumbnailFromMemory(m_image_buffer, m_image_size, destFile, minx, miny);
-}
 
-bool COMXImage::CreateThumbnailFromMemory(unsigned char* buffer, unsigned int bufSize, const CStdString& destFile, 
-    unsigned int minx, unsigned int miny)
+bool COMXImageReEnc::HandlePortSettingChange(unsigned int resize_width, unsigned int resize_height, int orientation, bool port_settings_changed)
 {
-  if(!bufSize || !buffer)
-    return false;
-
-  if(!m_is_open)
+  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
+  // on the first port settings changed event, we create the tunnel and alloc the buffer
+  if (!port_settings_changed)
   {
-    m_image_size = bufSize;
-    m_image_buffer = (uint8_t *)malloc(m_image_size);
-    if(!m_image_buffer)
+    OMX_PARAM_PORTDEFINITIONTYPE port_def;
+    OMX_INIT_STRUCTURE(port_def);
+
+    port_def.nPortIndex = m_omx_decoder.GetOutputPort();
+    m_omx_decoder.GetParameter(OMX_IndexParamPortDefinition, &port_def);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_decoder.GetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
       return false;
+    }
+
+    if (resize_width != port_def.format.image.nFrameWidth || resize_height != port_def.format.image.nFrameHeight || (orientation & 4))
+    {
+      if(!m_omx_resize.Initialize("OMX.broadcom.resize", OMX_IndexParamImageInit))
+      {
+        CLog::Log(LOGERROR, "%s::%s error m_omx_resize.Initialize\n", CLASSNAME, __func__);
+        return false;
+      }
+    }
+
+    // TODO: jpeg decoder can decimate by factors of 2
+    port_def.format.image.eColorFormat = OMX_COLOR_FormatYUV420PackedPlanar;
+    if (m_omx_resize.IsInitialized())
+      port_def.format.image.nSliceHeight = 16;
+    else
+      port_def.format.image.nSliceHeight = (resize_height+15) & ~15;
 
-    memcpy(m_image_buffer, buffer, m_image_size);
+    port_def.format.image.nStride = 0;
 
-    if(GetCodingType() != OMX_IMAGE_CodingJPEG) {
-      CLog::Log(LOGERROR, "%s::%s : %s GetCodingType()=0x%x\n", CLASSNAME, __func__, destFile.c_str(), GetCodingType());
+    m_omx_decoder.SetParameter(OMX_IndexParamPortDefinition, &port_def);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_decoder.SetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
       return false;
     }
-    m_is_open = true;
-  }
 
-  if(!Decode(minx, miny))
-    return false;
+    if (m_omx_resize.IsInitialized())
+    {
+      port_def.nPortIndex = m_omx_resize.GetInputPort();
 
-  return CreateThumbnailFromSurface(GetDecodedData(), GetDecodedWidth(), GetDecodedHeight(), 
-    XB_FMT_A8R8G8B8, GetDecodedStride(), destFile);
-}
+      m_omx_resize.SetParameter(OMX_IndexParamPortDefinition, &port_def);
+      if(omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s m_omx_resize.SetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
+        return false;
+      }
 
-bool COMXImage::CreateThumbnailFromSurface(unsigned char* buffer, unsigned int width, unsigned int height, 
-    unsigned int format, unsigned int pitch, const CStdString& destFile)
-{
-  if(format != XB_FMT_A8R8G8B8 || !buffer) {
-    CLog::Log(LOGDEBUG, "%s::%s : %s failed format=0x%x\n", CLASSNAME, __func__, destFile.c_str(), format);
-    return false;
-  }
+      port_def.nPortIndex = m_omx_resize.GetOutputPort();
+      m_omx_resize.GetParameter(OMX_IndexParamPortDefinition, &port_def);
+      if(omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s m_omx_resize.GetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
+        return false;
+      }
+      port_def.format.image.eColorFormat = OMX_COLOR_FormatYUV420PackedPlanar;
+      port_def.format.image.nFrameWidth = resize_width;
+      port_def.format.image.nFrameHeight = resize_height;
+      port_def.format.image.nSliceHeight = (resize_height+15) & ~15;
+      port_def.format.image.nStride = 0;
+      m_omx_resize.SetParameter(OMX_IndexParamPortDefinition, &port_def);
+      if(omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s m_omx_resize.SetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
+        return false;
+      }
+    }
 
-  if(!Encode(buffer, height * pitch, width, height, pitch)) {
-    CLog::Log(LOGDEBUG, "%s::%s : %s encode failed\n", CLASSNAME, __func__, destFile.c_str());
-    return false;
-  }
+    if(!m_omx_encoder.Initialize("OMX.broadcom.image_encode", OMX_IndexParamImageInit))
+    {
+      CLog::Log(LOGERROR, "%s::%s error m_omx_encoder.Initialize\n", CLASSNAME, __func__);
+      return false;
+    }
 
-  XFILE::CFile file;
-  if (file.OpenForWrite(destFile, true))
-  {
-    CLog::Log(LOGDEBUG, "%s::%s : %s width %d height %d\n", CLASSNAME, __func__, destFile.c_str(), width, height);
+    port_def.nPortIndex = m_omx_encoder.GetInputPort();
+    m_omx_encoder.GetParameter(OMX_IndexParamPortDefinition, &port_def);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_encoder.GetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+    port_def.format.image.eColorFormat = OMX_COLOR_FormatYUV420PackedPlanar;
+    port_def.format.image.nFrameWidth = resize_width;
+    port_def.format.image.nFrameHeight = resize_height;
+    port_def.format.image.nSliceHeight = (resize_height+15) & ~15;
+    port_def.format.image.nStride = 0;
+    m_omx_encoder.SetParameter(OMX_IndexParamPortDefinition, &port_def);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_encoder.SetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
+      return false;
+    }
 
-    file.Write(GetEncodedData(), GetEncodedSize());
-    file.Close();
-    return true;
-  }
+    port_def.nPortIndex = m_omx_encoder.GetOutputPort();
+    omx_err = m_omx_encoder.GetParameter(OMX_IndexParamPortDefinition, &port_def);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_encoder.GetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
+      return false;
+    }
 
-  return false;
-}
+    port_def.format.image.eCompressionFormat = OMX_IMAGE_CodingJPEG;
+    port_def.format.image.eColorFormat = OMX_COLOR_FormatUnused;
+    port_def.format.image.nFrameWidth = resize_width;
+    port_def.format.image.nFrameHeight = resize_height;
+    port_def.format.image.nStride = 0;
+    port_def.format.image.nSliceHeight = 0;
+    port_def.format.image.bFlagErrorConcealment = OMX_FALSE;
+
+    omx_err = m_omx_encoder.SetParameter(OMX_IndexParamPortDefinition, &port_def);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_encoder.SetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+
+    OMX_IMAGE_PARAM_QFACTORTYPE qfactor;
+    OMX_INIT_STRUCTURE(qfactor);
+    qfactor.nPortIndex = m_omx_encoder.GetOutputPort();
+    qfactor.nQFactor = 16;
+
+    omx_err = m_omx_encoder.SetParameter(OMX_IndexParamQFactor, &qfactor);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_encoder.SetParameter OMX_IndexParamQFactor result(0x%x)\n", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+
+    if (orientation)
+    {
+      struct {
+        // metadata, these two fields need to be together
+        OMX_CONFIG_METADATAITEMTYPE metadata;
+        char metadata_space[64];
+      } item;
+      OMX_INIT_STRUCTURE(item.metadata);
+
+      item.metadata.nSize = sizeof(item);
+      item.metadata.eScopeMode = OMX_MetadataScopePortLevel;
+      item.metadata.nScopeSpecifier = m_omx_encoder.GetOutputPort();
+      item.metadata.nMetadataItemIndex = 0;
+      item.metadata.eSearchMode = OMX_MetadataSearchValueSizeByIndex;
+      item.metadata.eKeyCharset = OMX_MetadataCharsetASCII;
+      strcpy((char *)item.metadata.nKey, "IFD0.Orientation");
+      item.metadata.nKeySizeUsed = strlen((char *)item.metadata.nKey);
+
+      item.metadata.eValueCharset = OMX_MetadataCharsetASCII;
+      item.metadata.sLanguageCountry = 0;
+      item.metadata.nValueMaxSize = sizeof(item.metadata_space);
+      sprintf((char *)item.metadata.nValue, "%d", orientation + 1);
+      item.metadata.nValueSizeUsed = strlen((char *)item.metadata.nValue);
+
+      omx_err = m_omx_encoder.SetParameter(OMX_IndexConfigMetadataItem, &item);
+      if (omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s m_omx_encoder.SetParameter:OMX_IndexConfigMetadataItem omx_err(0x%08x)\n", CLASSNAME, __func__, omx_err);
+        return false;
+      }
+    }
+    omx_err = m_omx_encoder.AllocOutputBuffers();
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_encoder.AllocOutputBuffers result(0x%x)\n", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+
+    if (m_omx_resize.IsInitialized())
+    {
+      m_omx_tunnel_decode.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_resize, m_omx_resize.GetInputPort());
+
+      omx_err = m_omx_tunnel_decode.Establish();
+      if(omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s m_omx_tunnel_decode.Establish\n", CLASSNAME, __func__);
+        return false;
+      }
+
+      m_omx_tunnel_resize.Initialize(&m_omx_resize, m_omx_resize.GetOutputPort(), &m_omx_encoder, m_omx_encoder.GetInputPort());
+
+      omx_err = m_omx_tunnel_resize.Establish();
+      if(omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s m_omx_tunnel_resize.Establish\n", CLASSNAME, __func__);
+        return false;
+      }
+
+      omx_err = m_omx_resize.SetStateForComponent(OMX_StateExecuting);
+      if(omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s m_omx_resize.SetStateForComponent result(0x%x)\n", CLASSNAME, __func__, omx_err);
+        return false;
+      }
+    }
+    else
+    {
+      m_omx_tunnel_decode.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_encoder, m_omx_encoder.GetInputPort());
+
+      omx_err = m_omx_tunnel_decode.Establish();
+      if(omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s m_omx_tunnel_decode.Establish\n", CLASSNAME, __func__);
+        return false;
+      }
+    }
+    omx_err = m_omx_encoder.SetStateForComponent(OMX_StateExecuting);
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_encoder.SetStateForComponent result(0x%x)\n", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+
+    if(m_omx_encoder.BadState())
+      return false;
+  }
+  // on subsequent port settings changed event, we just copy the port settings
+  else
+  {
+    // a little surprising, make a note
+    CLog::Log(LOGDEBUG, "%s::%s m_omx_resize second port changed event\n", CLASSNAME, __func__);
+    m_omx_decoder.DisablePort(m_omx_decoder.GetOutputPort(), true);
+    if (m_omx_resize.IsInitialized())
+    {
+      m_omx_resize.DisablePort(m_omx_resize.GetInputPort(), true);
+
+      OMX_PARAM_PORTDEFINITIONTYPE port_def;
+      OMX_INIT_STRUCTURE(port_def);
+
+      port_def.nPortIndex = m_omx_decoder.GetOutputPort();
+      m_omx_decoder.GetParameter(OMX_IndexParamPortDefinition, &port_def);
+      port_def.nPortIndex = m_omx_resize.GetInputPort();
+      m_omx_resize.SetParameter(OMX_IndexParamPortDefinition, &port_def);
+
+      omx_err = m_omx_resize.WaitForEvent(OMX_EventPortSettingsChanged);
+      if(omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s m_omx_resize.WaitForEvent=%x\n", CLASSNAME, __func__, omx_err);
+        return false;
+      }
+      m_omx_resize.EnablePort(m_omx_resize.GetInputPort(), true);
+    }
+    m_omx_decoder.EnablePort(m_omx_decoder.GetOutputPort(), true);
+  }
+  return true;
+}
+
+bool COMXImageReEnc::ReEncode(COMXImageFile &srcFile, unsigned int maxWidth, unsigned int maxHeight, void * &pDestBuffer, unsigned int &nDestSize)
+{
+  CSingleLock lock(m_OMXSection);
+  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
+
+  COMXImage::ClampLimits(maxWidth, maxHeight, srcFile.GetWidth(), srcFile.GetHeight(), srcFile.GetOrientation() & 4);
+  unsigned int demuxer_bytes = srcFile.GetImageSize();
+  unsigned char *demuxer_content = (unsigned char *)srcFile.GetImageBuffer();
+  // initial dest buffer size
+  nDestSize = 0;
+
+  if(!demuxer_content || !demuxer_bytes)
+  {
+    CLog::Log(LOGERROR, "%s::%s %s no input buffer\n", CLASSNAME, __func__, srcFile.GetFilename());
+    return false;
+  }
+
+  if(!m_omx_decoder.Initialize("OMX.broadcom.image_decode", OMX_IndexParamImageInit))
+  {
+    CLog::Log(LOGERROR, "%s::%s %s error m_omx_decoder.Initialize\n", CLASSNAME, __func__, srcFile.GetFilename());
+    return false;
+  }
+
+  // set input format
+  OMX_PARAM_PORTDEFINITIONTYPE portParam;
+  OMX_INIT_STRUCTURE(portParam);
+  portParam.nPortIndex = m_omx_decoder.GetInputPort();
+
+  omx_err = m_omx_decoder.GetParameter(OMX_IndexParamPortDefinition, &portParam);
+  if(omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s %s error GetParameter:OMX_IndexParamPortDefinition omx_err(0x%08x)\n", CLASSNAME, __func__, srcFile.GetFilename(), omx_err);
+    return false;
+  }
+
+  portParam.nBufferCountActual = portParam.nBufferCountMin;
+  portParam.nBufferSize = std::max(portParam.nBufferSize, ALIGN_UP(demuxer_bytes, portParam.nBufferAlignment));
+  portParam.format.image.eCompressionFormat = OMX_IMAGE_CodingJPEG;
+
+  omx_err = m_omx_decoder.SetParameter(OMX_IndexParamPortDefinition, &portParam);
+  if(omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s %s error SetParameter:OMX_IndexParamPortDefinition omx_err(0x%08x)\n", CLASSNAME, __func__, srcFile.GetFilename(), omx_err);
+    return false;
+  }
+
+  omx_err = m_omx_decoder.AllocInputBuffers();
+  if(omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s %s m_omx_decoder.AllocInputBuffers result(0x%x)", CLASSNAME, __func__, srcFile.GetFilename(), omx_err);
+    return false;
+  }
+
+  omx_err = m_omx_decoder.SetStateForComponent(OMX_StateExecuting);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s %s m_omx_decoder.SetStateForComponent result(0x%x)\n", CLASSNAME, __func__, srcFile.GetFilename(), omx_err);
+    return false;
+  }
+
+  bool port_settings_changed = false, eos = false;
+  while(demuxer_bytes > 0 || !port_settings_changed || !eos)
+  {
+    long timeout = 0;
+    if (demuxer_bytes)
+    {
+       OMX_BUFFERHEADERTYPE *omx_buffer = m_omx_decoder.GetInputBuffer(1000);
+       if(omx_buffer)
+       {
+         omx_buffer->nOffset = omx_buffer->nFlags  = 0;
+
+         omx_buffer->nFilledLen = (demuxer_bytes > omx_buffer->nAllocLen) ? omx_buffer->nAllocLen : demuxer_bytes;
+         memcpy(omx_buffer->pBuffer, demuxer_content, omx_buffer->nFilledLen);
+
+         demuxer_content += omx_buffer->nFilledLen;
+         demuxer_bytes -= omx_buffer->nFilledLen;
+         if(demuxer_bytes == 0)
+           omx_buffer->nFlags |= OMX_BUFFERFLAG_EOS;
+
+         omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
+         if (omx_err != OMX_ErrorNone)
+         {
+           CLog::Log(LOGERROR, "%s::%s %s OMX_EmptyThisBuffer() failed with result(0x%x)\n", CLASSNAME, __func__, srcFile.GetFilename(), omx_err);
+           return false;
+         }
+      }
+    }
+    if (!demuxer_bytes)
+    {
+       // we've submitted all buffers so can wait now
+       timeout = 1000;
+    }
+
+    omx_err = m_omx_decoder.WaitForEvent(OMX_EventPortSettingsChanged, timeout);
+    if(omx_err == OMX_ErrorNone)
+    {
+      if (!HandlePortSettingChange(maxWidth, maxHeight, srcFile.GetOrientation(), port_settings_changed))
+      {
+        CLog::Log(LOGERROR, "%s::%s %s HandlePortSettingChange() failed\n", srcFile.GetFilename(), CLASSNAME, __func__);
+        return false;
+      }
+      port_settings_changed = true;
+    }
+    else if(omx_err == OMX_ErrorStreamCorrupt)
+    {
+      CLog::Log(LOGERROR, "%s::%s %s - image not supported", CLASSNAME, __func__, srcFile.GetFilename());
+      return false;
+    }
+    else if(timeout || omx_err != OMX_ErrorTimeout)
+    {
+      CLog::Log(LOGERROR, "%s::%s %s WaitForEvent:OMX_EventPortSettingsChanged failed (%x)\n", CLASSNAME, __func__, srcFile.GetFilename(), omx_err);
+      return false;
+    }
+
+    if (!m_encoded_buffer && port_settings_changed && demuxer_bytes == 0)
+    {
+      m_encoded_buffer = m_omx_encoder.GetOutputBuffer();
+      omx_err = m_omx_encoder.FillThisBuffer(m_encoded_buffer);
+      if(omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s %s FillThisBuffer() failed (%x)\n", CLASSNAME, __func__, srcFile.GetFilename(), omx_err);
+        return false;
+      }
+    }
+    if (m_encoded_buffer)
+    {
+      omx_err = m_omx_encoder.WaitForOutputDone(1000);
+      if (omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s %s m_omx_encoder.WaitForOutputDone result(0x%x)\n", CLASSNAME, __func__, srcFile.GetFilename(), omx_err);
+        return false;
+      }
+      if (!m_encoded_buffer->nFilledLen)
+      {
+        CLog::Log(LOGERROR, "%s::%s %s m_omx_encoder.WaitForOutputDone no data\n", CLASSNAME, __func__, srcFile.GetFilename());
+        return false;
+      }
+      if (m_encoded_buffer->nFlags & OMX_BUFFERFLAG_EOS)
+         eos = true;
+
+      if (nDestSize + m_encoded_buffer->nFilledLen > m_nDestAllocSize)
+      {
+         while (nDestSize + m_encoded_buffer->nFilledLen > m_nDestAllocSize)
+           m_nDestAllocSize = std::max(1024U*1024U, m_nDestAllocSize*2);
+         m_pDestBuffer = realloc(m_pDestBuffer, m_nDestAllocSize);
+      }
+      memcpy((char *)m_pDestBuffer + nDestSize, m_encoded_buffer->pBuffer, m_encoded_buffer->nFilledLen);
+      nDestSize += m_encoded_buffer->nFilledLen;
+      m_encoded_buffer = NULL;
+    }
+  }
+
+  if(m_omx_decoder.BadState())
+    return false;
+
+  pDestBuffer = m_pDestBuffer;
+  CLog::Log(LOGDEBUG, "%s::%s : %s %dx%d -> %dx%d\n", CLASSNAME, __func__, srcFile.GetFilename(), srcFile.GetWidth(), srcFile.GetHeight(), maxWidth, maxHeight);
+
+  m_success = true;
+  Close();
+
+  return true;
+}
+
+
+#ifdef CLASSNAME
+#undef CLASSNAME
+#endif
+#define CLASSNAME "COMXTexture"
+
+COMXTexture::COMXTexture()
+{
+  limit_calls_enter();
+  m_success = false;
+}
+
+COMXTexture::~COMXTexture()
+{
+  Close();
+  limit_calls_leave();
+}
+
+void COMXTexture::Close()
+{
+  CSingleLock lock(m_OMXSection);
+
+  if (!m_success)
+  {
+    if(m_omx_decoder.IsInitialized())
+    {
+      m_omx_decoder.SetStateForComponent(OMX_StateIdle);
+      m_omx_decoder.FlushInput();
+      m_omx_decoder.FreeInputBuffers();
+    }
+    if(m_omx_egl_render.IsInitialized())
+    {
+      m_omx_egl_render.SetStateForComponent(OMX_StateIdle);
+      m_omx_egl_render.FlushOutput();
+      m_omx_egl_render.FreeOutputBuffers();
+    }
+  }
+  if (m_omx_tunnel_decode.IsInitialized())
+    m_omx_tunnel_decode.Deestablish();
+  if (m_omx_tunnel_egl.IsInitialized())
+    m_omx_tunnel_egl.Deestablish();
+  // delete components
+  if (m_omx_decoder.IsInitialized())
+    m_omx_decoder.Deinitialize();
+  if (m_omx_resize.IsInitialized())
+    m_omx_resize.Deinitialize();
+  if (m_omx_egl_render.IsInitialized())
+    m_omx_egl_render.Deinitialize();
+}
+
+bool COMXTexture::HandlePortSettingChange(unsigned int resize_width, unsigned int resize_height, void *egl_image, bool port_settings_changed)
+{
+  EGLDisplay egl_display = g_Windowing.GetEGLDisplay();
+  OMX_ERRORTYPE omx_err;
+
+  if (port_settings_changed)
+    CLog::Log(LOGERROR, "%s::%s Unexpected second port_settings_changed call\n", CLASSNAME, __func__);
+
+  OMX_PARAM_PORTDEFINITIONTYPE port_def;
+  OMX_INIT_STRUCTURE(port_def);
+
+  port_def.nPortIndex = m_omx_decoder.GetOutputPort();
+  omx_err = m_omx_decoder.GetParameter(OMX_IndexParamPortDefinition, &port_def);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s m_omx_decoder.GetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  // TODO: jpeg decoder can decimate by factors of 2
+  port_def.format.image.eColorFormat = OMX_COLOR_FormatYUV420PackedPlanar;
+  port_def.format.image.nSliceHeight = 16;
+  port_def.format.image.nStride = 0;
+
+  omx_err = m_omx_decoder.SetParameter(OMX_IndexParamPortDefinition, &port_def);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s m_omx_decoder.SetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+  if (resize_width != port_def.format.image.nFrameWidth || resize_height != port_def.format.image.nFrameHeight)
+  {
+    if (!m_omx_resize.Initialize("OMX.broadcom.resize", OMX_IndexParamImageInit))
+    {
+      CLog::Log(LOGERROR, "%s::%s error m_omx_resize.Initialize", CLASSNAME, __func__);
+      return false;
+    }
+  }
+  if (m_omx_resize.IsInitialized())
+  {
+    port_def.nPortIndex = m_omx_resize.GetInputPort();
+
+    omx_err = m_omx_resize.SetParameter(OMX_IndexParamPortDefinition, &port_def);
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_resize.SetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+
+    port_def.nPortIndex = m_omx_resize.GetOutputPort();
+    omx_err = m_omx_resize.GetParameter(OMX_IndexParamPortDefinition, &port_def);
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_resize.GetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+
+    port_def.format.image.eColorFormat = OMX_COLOR_FormatYUV420PackedPlanar;
+    port_def.format.image.nFrameWidth = resize_width;
+    port_def.format.image.nFrameHeight = resize_height;
+    port_def.format.image.nSliceHeight = 16;
+    port_def.format.image.nStride = 0;
+    omx_err = m_omx_resize.SetParameter(OMX_IndexParamPortDefinition, &port_def);
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_resize.SetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+  }
+  if (!m_omx_egl_render.Initialize("OMX.broadcom.egl_render", OMX_IndexParamVideoInit))
+  {
+    CLog::Log(LOGERROR, "%s::%s error m_omx_egl_render.Initialize", CLASSNAME, __func__);
+    return false;
+  }
+
+  port_def.nPortIndex = m_omx_egl_render.GetOutputPort();
+  omx_err = m_omx_egl_render.GetParameter(OMX_IndexParamPortDefinition, &port_def);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s m_omx_egl_render.SetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+  port_def.nBufferCountActual = 1;
+  port_def.format.video.pNativeWindow = egl_display;
+
+  omx_err = m_omx_egl_render.SetParameter(OMX_IndexParamPortDefinition, &port_def);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s m_omx_egl_render.SetParameter result(0x%x)\n", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  omx_err = m_omx_egl_render.UseEGLImage(&m_egl_buffer, m_omx_egl_render.GetOutputPort(), NULL, egl_image);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s error m_omx_egl_render.UseEGLImage (%x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+  if (m_omx_resize.IsInitialized())
+  {
+    m_omx_tunnel_decode.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_resize, m_omx_resize.GetInputPort());
+
+    omx_err = m_omx_tunnel_decode.Establish();
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_tunnel_decode.Establish (%x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+
+    m_omx_tunnel_egl.Initialize(&m_omx_resize, m_omx_resize.GetOutputPort(), &m_omx_egl_render, m_omx_egl_render.GetInputPort());
+
+    omx_err = m_omx_tunnel_egl.Establish();
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_tunnel_egl.Establish (%x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+
+    omx_err = m_omx_resize.SetStateForComponent(OMX_StateExecuting);
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s error m_omx_egl_render.GetParameter (%x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+  }
+  else
+  {
+    m_omx_tunnel_decode.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_egl_render, m_omx_egl_render.GetInputPort());
+
+    omx_err = m_omx_tunnel_decode.Establish();
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_tunnel_decode.Establish (%x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+  }
+
+  omx_err = m_omx_egl_render.SetStateForComponent(OMX_StateExecuting);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s error m_omx_egl_render.SetStateForComponent (%x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  return true;
+}
+
+bool COMXTexture::Decode(const uint8_t *demuxer_content, unsigned demuxer_bytes, unsigned int width, unsigned int height, void *egl_image)
+{
+  CSingleLock lock(m_OMXSection);
+  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
+
+  if (!demuxer_content || !demuxer_bytes)
+  {
+    CLog::Log(LOGERROR, "%s::%s no input buffer\n", CLASSNAME, __func__);
+    return false;
+  }
+
+  if (!m_omx_decoder.Initialize("OMX.broadcom.image_decode", OMX_IndexParamImageInit))
+  {
+    CLog::Log(LOGERROR, "%s::%s error m_omx_decoder.Initialize", CLASSNAME, __func__);
+    return false;
+  }
+
+  // set input format
+  OMX_PARAM_PORTDEFINITIONTYPE portParam;
+  OMX_INIT_STRUCTURE(portParam);
+  portParam.nPortIndex = m_omx_decoder.GetInputPort();
+
+  omx_err = m_omx_decoder.GetParameter(OMX_IndexParamPortDefinition, &portParam);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s error GetParameter:OMX_IndexParamPortDefinition omx_err(0x%08x)\n", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  portParam.nBufferCountActual = portParam.nBufferCountMin;
+  portParam.nBufferSize = std::max(portParam.nBufferSize, ALIGN_UP(demuxer_bytes, portParam.nBufferAlignment));
+  portParam.format.image.eCompressionFormat = OMX_IMAGE_CodingJPEG;
+
+  omx_err = m_omx_decoder.SetParameter(OMX_IndexParamPortDefinition, &portParam);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s error SetParameter:OMX_IndexParamPortDefinition omx_err(0x%08x)\n", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  omx_err = m_omx_decoder.AllocInputBuffers();
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - Error alloc buffers  (%x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  omx_err = m_omx_decoder.SetStateForComponent(OMX_StateExecuting);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s error m_omx_sched.SetStateForComponent (%x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  bool port_settings_changed = false;
+  bool eos = false;
+  while(demuxer_bytes > 0 || !port_settings_changed || !eos)
+  {
+    long timeout = 0;
+    if (demuxer_bytes)
+    {
+      OMX_BUFFERHEADERTYPE *omx_buffer = m_omx_decoder.GetInputBuffer(1000);
+      if (omx_buffer)
+      {
+        omx_buffer->nOffset = omx_buffer->nFlags  = 0;
+
+        omx_buffer->nFilledLen = (demuxer_bytes > omx_buffer->nAllocLen) ? omx_buffer->nAllocLen : demuxer_bytes;
+        memcpy(omx_buffer->pBuffer, demuxer_content, omx_buffer->nFilledLen);
+
+        demuxer_content += omx_buffer->nFilledLen;
+        demuxer_bytes -= omx_buffer->nFilledLen;
+
+        if (demuxer_bytes == 0)
+          omx_buffer->nFlags |= OMX_BUFFERFLAG_EOS;
+
+        omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
+        if (omx_err != OMX_ErrorNone)
+        {
+          CLog::Log(LOGERROR, "%s::%s - m_omx_decoder.OMX_EmptyThisBuffer (%x)", CLASSNAME, __func__, omx_err);
+          return false;
+         }
+      }
+    }
+    if (!demuxer_bytes)
+    {
+       // we've submitted all buffers so can wait now
+       timeout = 1000;
+    }
+
+    omx_err = m_omx_decoder.WaitForEvent(OMX_EventPortSettingsChanged, timeout);
+    if (omx_err == OMX_ErrorNone)
+    {
+      if (!HandlePortSettingChange(width, height, egl_image, port_settings_changed))
+      {
+        CLog::Log(LOGERROR, "%s::%s - HandlePortSettingChange failed (%x)", CLASSNAME, __func__, omx_err);
+        return false;
+      }
+      port_settings_changed = true;
+    }
+    else if (omx_err == OMX_ErrorStreamCorrupt)
+    {
+      CLog::Log(LOGERROR, "%s::%s - image not supported", CLASSNAME, __func__);
+      return false;
+    }
+    else if (timeout || omx_err != OMX_ErrorTimeout)
+    {
+      CLog::Log(LOGERROR, "%s::%s WaitForEvent:OMX_EventPortSettingsChanged failed (%x)\n", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+
+    if (port_settings_changed && m_egl_buffer && demuxer_bytes == 0 && !eos)
+    {
+      OMX_BUFFERHEADERTYPE *omx_buffer = m_omx_egl_render.GetOutputBuffer();
+      if (!omx_buffer)
+      {
+        CLog::Log(LOGERROR, "%s::%s GetOutputBuffer failed\n", CLASSNAME, __func__);
+        return false;
+      }
+      if (omx_buffer != m_egl_buffer)
+      {
+        CLog::Log(LOGERROR, "%s::%s error m_omx_egl_render.GetOutputBuffer (%p,%p)", CLASSNAME, __func__, omx_buffer, m_egl_buffer);
+        return false;
+      }
+
+      omx_err = m_omx_egl_render.FillThisBuffer(m_egl_buffer);
+      if (omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s error m_omx_egl_render.FillThisBuffer (%x)", CLASSNAME, __func__, omx_err);
+        return false;
+      }
+
+      omx_err = m_omx_egl_render.WaitForOutputDone(1000);
+      if (omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s m_omx_egl_render.WaitForOutputDone result(0x%x)\n", CLASSNAME, __func__, omx_err);
+        return false;
+      }
+      eos = true;
+    }
+  }
+  m_success = true;
+  Close();
+  return true;
+}
+
+COMXImage g_OMXImage;
diff -ur a/xbmc/cores/omxplayer/OMXImage.h b/xbmc/cores/omxplayer/OMXImage.h
--- a/xbmc/cores/omxplayer/OMXImage.h	2015-03-12 20:52:41.090096999 +0100
+++ b/xbmc/cores/omxplayer/OMXImage.h	2015-03-12 20:48:25.166096999 +0100
@@ -34,75 +34,174 @@
 #include "guilib/XBTF.h"
 #endif
 
-using namespace XFILE;
-using namespace std;
+#include "system_gl.h"
+#include <EGL/egl.h>
+#include <EGL/eglext.h>
+#include "threads/Thread.h"
 
-class COMXImage
+class COMXImageFile;
+
+class COMXImage : public CThread
 {
+  struct callbackinfo {
+    CEvent sync;
+    bool (*callback)(EGLDisplay egl_display, EGLContext egl_context, void *cookie);
+    void *cookie;
+    bool result;
+  };
+protected:
+  virtual void OnStartup();
+  virtual void OnExit();
+  virtual void Process();
 public:
+  struct textureinfo {
+    int width, height;
+    GLuint texture;
+    EGLImageKHR egl_image;
+    void *parent;
+    const char *filename;
+  };
   COMXImage();
   virtual ~COMXImage();
+  void Initialize();
+  void Deinitialize();
+  static COMXImageFile *LoadJpeg(const CStdString& texturePath);
+  static void CloseJpeg(COMXImageFile *file);
 
-  // Required overrides
-  void Close(void);
-  bool ClampLimits(unsigned int &width, unsigned int &height);
-  bool ReadFile(const CStdString& inputFile);
-  bool IsProgressive() { return m_progressive; };
-  bool IsAlpha() { return m_alpha; };
+  static bool DecodeJpeg(COMXImageFile *file, unsigned int maxWidth, unsigned int maxHeight, unsigned int stride, void *pixels);
+  static bool CreateThumbnailFromSurface(unsigned char* buffer, unsigned int width, unsigned int height,
+      unsigned int format, unsigned int pitch, const CStdString& destFile);
+  static bool ClampLimits(unsigned int &width, unsigned int &height, unsigned int m_width, unsigned int m_height, bool transposed = false);
+  static bool CreateThumb(const CStdString& srcFile, unsigned int width, unsigned int height, std::string &additional_info, const CStdString& destFile);
+  bool SendMessage(bool (*callback)(EGLDisplay egl_display, EGLContext egl_context, void *cookie), void *cookie);
+  bool DecodeJpegToTexture(COMXImageFile *file, unsigned int width, unsigned int height, void **userdata);
+  void DestroyTexture(void *userdata);
+  void GetTexture(void *userdata, GLuint *texture);
+  bool AllocTextureInternal(EGLDisplay egl_display, EGLContext egl_context, struct textureinfo *tex);
+  bool DestroyTextureInternal(EGLDisplay egl_display, EGLContext egl_context, struct textureinfo *tex);
+private:
+  EGLContext m_egl_context;
+
+  void CreateContext();
+  EGLContext GetEGLContext();
+  CCriticalSection               m_texqueue_lock;
+  XbmcThreads::ConditionVariable m_texqueue_cond;
+  std::queue <struct callbackinfo *> m_texqueue;
+};
+
+class COMXImageFile
+{
+public:
+  COMXImageFile();
+  virtual ~COMXImageFile();
+  bool ReadFile(const CStdString& inputFile, int orientation = 0);
   int  GetOrientation() { return m_orientation; };
-  unsigned int GetOriginalWidth()  { return m_omx_image.nFrameWidth; };
-  unsigned int GetOriginalHeight() { return m_omx_image.nFrameHeight; };
   unsigned int GetWidth()  { return m_width; };
   unsigned int GetHeight() { return m_height; };
-  OMX_IMAGE_CODINGTYPE GetCodingType();
-  const uint8_t *GetImageBuffer() { return (const uint8_t *)m_image_buffer; };
   unsigned long GetImageSize() { return m_image_size; };
-  OMX_IMAGE_CODINGTYPE GetCompressionFormat() { return m_omx_image.eCompressionFormat; };
-  bool Decode(unsigned int width, unsigned int height);
-  bool Encode(unsigned char *buffer, int size, unsigned int width, unsigned int height, unsigned int pitch);
-  unsigned int GetDecodedWidth() { return (unsigned int)m_decoded_format.format.image.nFrameWidth; };
-  unsigned int GetDecodedHeight() { return (unsigned int)m_decoded_format.format.image.nFrameHeight; };
-  unsigned int GetDecodedStride() { return (unsigned int)m_decoded_format.format.image.nStride; };
-  unsigned char *GetDecodedData();
-  unsigned int GetDecodedSize();
-  unsigned int GetEncodedWidth() { return (unsigned int)m_encoded_format.format.image.nFrameWidth; };
-  unsigned int GetEncodedHeight() { return (unsigned int)m_encoded_format.format.image.nFrameHeight; };
-  unsigned int GetEncodedStride() { return (unsigned int)m_encoded_format.format.image.nStride; };
-  unsigned char *GetEncodedData();
-  unsigned int GetEncodedSize();
-  bool SwapBlueRed(unsigned char *pixels, unsigned int height, unsigned int pitch, 
-      unsigned int elements = 4, unsigned int offset=0);
-  bool CreateThumbnail(const CStdString& sourceFile, const CStdString& destFile, 
-      int minx, int miny, bool rotateExif);
-  bool CreateThumbnailFromMemory(unsigned char* buffer, unsigned int bufSize, 
-      const CStdString& destFile, unsigned int minx, unsigned int miny);
-  bool CreateThumbnailFromSurface(unsigned char* buffer, unsigned int width, unsigned int height, 
-      unsigned int format, unsigned int pitch, const CStdString& destFile);
+  const uint8_t *GetImageBuffer() { return (const uint8_t *)m_image_buffer; };
+  const char *GetFilename() { return m_filename; };
 protected:
-  bool HandlePortSettingChange(unsigned int resize_width, unsigned int resize_height);
+  OMX_IMAGE_CODINGTYPE GetCodingType(unsigned int &width, unsigned int &height, int orientation);
   uint8_t           *m_image_buffer;
-  bool              m_is_open;
   unsigned long     m_image_size;
   unsigned int      m_width;
   unsigned int      m_height;
-  bool              m_progressive;
-  bool              m_alpha;
   int               m_orientation;
-  XFILE::CFile      m_pFile;
-  OMX_IMAGE_PORTDEFINITIONTYPE  m_omx_image;
+  const char *      m_filename;
+};
+
+class COMXImageDec
+{
+public:
+  COMXImageDec();
+  virtual ~COMXImageDec();
 
+  // Required overrides
+  void Close();
+  bool Decode(const uint8_t *data, unsigned size, unsigned int width, unsigned int height, unsigned stride, void *pixels);
+  unsigned int GetDecodedWidth() { return (unsigned int)m_decoded_format.format.image.nFrameWidth; };
+  unsigned int GetDecodedHeight() { return (unsigned int)m_decoded_format.format.image.nFrameHeight; };
+  unsigned int GetDecodedStride() { return (unsigned int)m_decoded_format.format.image.nStride; };
+protected:
+  bool HandlePortSettingChange(unsigned int resize_width, unsigned int resize_height, unsigned int resize_stride);
   // Components
   COMXCoreComponent             m_omx_decoder;
-  COMXCoreComponent             m_omx_encoder;
   COMXCoreComponent             m_omx_resize;
   COMXCoreTunel                 m_omx_tunnel_decode;
   OMX_BUFFERHEADERTYPE          *m_decoded_buffer;
-  OMX_BUFFERHEADERTYPE          *m_encoded_buffer;
   OMX_PARAM_PORTDEFINITIONTYPE  m_decoded_format;
+  CCriticalSection              m_OMXSection;
+  bool                          m_success;
+};
+
+class COMXImageEnc
+{
+public:
+  COMXImageEnc();
+  virtual ~COMXImageEnc();
+
+  // Required overrides
+  bool CreateThumbnailFromSurface(unsigned char* buffer, unsigned int width, unsigned int height,
+      unsigned int format, unsigned int pitch, const CStdString& destFile);
+protected:
+  bool Encode(unsigned char *buffer, int size, unsigned int width, unsigned int height, unsigned int pitch);
+  // Components
+  COMXCoreComponent             m_omx_encoder;
+  OMX_BUFFERHEADERTYPE          *m_encoded_buffer;
   OMX_PARAM_PORTDEFINITIONTYPE  m_encoded_format;
+  CCriticalSection              m_OMXSection;
+  bool                          m_success;
+};
+
+class COMXImageReEnc
+{
+public:
+  COMXImageReEnc();
+  virtual ~COMXImageReEnc();
+
+  // Required overrides
+  void Close();
+  bool ReEncode(COMXImageFile &srcFile, unsigned int width, unsigned int height, void * &pDestBuffer, unsigned int &nDestSize);
+protected:
+  bool HandlePortSettingChange(unsigned int resize_width, unsigned int resize_height, int orientation, bool port_settings_changed);
+  // Components
+  COMXCoreComponent             m_omx_decoder;
+  COMXCoreComponent             m_omx_resize;
+  COMXCoreComponent             m_omx_encoder;
+  COMXCoreTunel                 m_omx_tunnel_decode;
+  COMXCoreTunel                 m_omx_tunnel_resize;
+  OMX_BUFFERHEADERTYPE          *m_encoded_buffer;
+  CCriticalSection              m_OMXSection;
+  void                          *m_pDestBuffer;
+  unsigned int                  m_nDestAllocSize;
+  bool                          m_success;
+};
 
-  bool                          m_decoder_open;
-  bool                          m_encoder_open;
+class COMXTexture
+{
+public:
+  COMXTexture();
+  virtual ~COMXTexture();
+
+  // Required overrides
+  void Close(void);
+  bool Decode(const uint8_t *data, unsigned size, unsigned int width, unsigned int height, void *egl_image);
+protected:
+  bool HandlePortSettingChange(unsigned int resize_width, unsigned int resize_height, void *egl_image, bool port_settings_changed);
+
+  // Components
+  COMXCoreComponent m_omx_decoder;
+  COMXCoreComponent m_omx_resize;
+  COMXCoreComponent m_omx_egl_render;
+
+  COMXCoreTunel     m_omx_tunnel_decode;
+  COMXCoreTunel     m_omx_tunnel_egl;
+
+  OMX_BUFFERHEADERTYPE *m_egl_buffer;
+  CCriticalSection              m_OMXSection;
+  bool              m_success;
 };
 
+extern COMXImage g_OMXImage;
 #endif
diff -ur a/xbmc/cores/omxplayer/OMXPlayerAudio.cpp b/xbmc/cores/omxplayer/OMXPlayerAudio.cpp
--- a/xbmc/cores/omxplayer/OMXPlayerAudio.cpp	2015-03-12 20:52:41.090096999 +0100
+++ b/xbmc/cores/omxplayer/OMXPlayerAudio.cpp	2015-03-12 20:48:25.166096999 +0100
@@ -42,6 +42,7 @@
 #include "utils/TimeUtils.h"
 
 #include "OMXPlayer.h"
+#include "linux/RBP.h"
 
 #include <iostream>
 #include <sstream>
@@ -72,18 +73,27 @@
   m_speed         = DVD_PLAYSPEED_NORMAL;
   m_started       = false;
   m_stalled       = false;
-  m_audioClock    = 0;
+  m_audioClock    = DVD_NOPTS_VALUE;
   m_buffer_empty  = false;
   m_nChannels     = 0;
   m_DecoderOpen   = false;
-  m_freq          = CurrentHostFrequency();
   m_bad_state     = false;
   m_hints_current.Clear();
 
-  m_av_clock->SetMasterClock(false);
+  bool small_mem = g_RBP.GetArmMem() < 256;
+  m_messageQueue.SetMaxDataSize((small_mem ? 3:6) * 1024 * 1024);
 
-  m_messageQueue.SetMaxDataSize(3 * 1024 * 1024);
   m_messageQueue.SetMaxTimeSize(8.0);
+
+  /* PLEX */
+  g_AudioCachePts = INFINITY;
+  /* END PLEX */
+  m_use_passthrough = false;
+  m_passthrough = false;
+  m_use_hw_decode = false;
+  m_hw_decode = false;
+  m_silence = false;
+  m_flush = false;
 }
 
 
@@ -134,24 +144,18 @@
     m_hints.bitspersample = 16;
 
   m_speed           = DVD_PLAYSPEED_NORMAL;
-  m_audioClock      = 0;
-  m_error           = 0;
-  m_errorbuff       = 0;
-  m_errorcount      = 0;
-  m_integral        = 0;
-  m_skipdupcount    = 0;
-  m_prevskipped     = false;
-  m_syncclock       = true;
+  m_audioClock      = DVD_NOPTS_VALUE;
   m_hw_decode       = false;
-  m_errortime       = CurrentHostCounter();
   m_silence         = false;
   m_started         = false;
   m_flush           = false;
   m_nChannels       = 0;
-  m_synctype        = SYNC_DISCON;
   m_stalled         = m_messageQueue.GetPacketCount(CDVDMsg::DEMUXER_PACKET) == 0;
-  m_use_passthrough = (g_guiSettings.GetInt("audiooutput.mode") == AUDIO_HDMI) ? true : false ;
+  m_use_passthrough = (g_guiSettings.GetInt("audiooutput.mode") == AUDIO_HDMI && !g_guiSettings.GetBool("audiooutput.dualaudio")) ? true : false ;
   m_use_hw_decode   = g_advancedSettings.m_omxHWAudioDecode;
+  m_format.m_dataFormat    = GetDataFormat(m_hints);
+  m_format.m_sampleRate    = 0;
+  m_format.m_channelLayout = 0;
 }
 
 bool OMXPlayerAudio::CloseStream(bool bWaitForBuffers)
@@ -190,110 +194,6 @@
   CLog::Log(LOGNOTICE, "thread end: OMXPlayerAudio::OnExit()");
 }
 
-
-
-void OMXPlayerAudio::HandleSyncError(double duration)
-{
-  double clock = m_av_clock->GetClock();
-  double error = m_audioClock - clock;
-  int64_t now;
-
-  if( fabs(error) > DVD_MSEC_TO_TIME(100) || m_syncclock )
-  {
-    m_av_clock->Discontinuity(clock+error);
-    /*
-    if(m_speed == DVD_PLAYSPEED_NORMAL)
-    CLog::Log(LOGDEBUG, "OMXPlayerAudio:: Discontinuity - was:%f, should be:%f, error:%f\n", clock, clock+error, error);
-    */
-
-    m_errorbuff = 0;
-    m_errorcount = 0;
-    m_skipdupcount = 0;
-    m_error = 0;
-    m_syncclock = false;
-    m_errortime = CurrentHostCounter();
-
-    return;
-  }
-
-  if (m_speed != DVD_PLAYSPEED_NORMAL)
-  {
-    m_errorbuff = 0;
-    m_errorcount = 0;
-    m_integral = 0;
-    m_skipdupcount = 0;
-    m_error = 0;
-    m_errortime = CurrentHostCounter();
-    return;
-  }
-
-  //check if measured error for 1 second
-  now = CurrentHostCounter();
-  if ((now - m_errortime) >= m_freq)
-  {
-    m_errortime = now;
-    m_error = m_errorbuff / m_errorcount;
-
-    m_errorbuff = 0;
-    m_errorcount = 0;
-
-    if (m_synctype == SYNC_DISCON)
-    {
-      double limit, error;
-
-      if (m_av_clock->GetRefreshRate(&limit) > 0)
-      {
-        //when the videoreferenceclock is running, the discontinuity limit is one vblank period
-        limit *= DVD_TIME_BASE;
-
-        //make error a multiple of limit, rounded towards zero,
-        //so it won't interfere with the sync methods in CXBMCRenderManager::WaitPresentTime
-        if (m_error > 0.0)
-          error = limit * floor(m_error / limit);
-        else
-          error = limit * ceil(m_error / limit);
-      }
-      else
-      {
-        limit = DVD_MSEC_TO_TIME(10);
-        error = m_error;
-      }
-
-      /*
-      limit = DVD_MSEC_TO_TIME(10);
-      error = m_error;
-      */
-
-      if (fabs(error) > limit - 0.001)
-      {
-        m_av_clock->Discontinuity(clock+error);
-        /*
-        if(m_speed == DVD_PLAYSPEED_NORMAL)
-          CLog::Log(LOGDEBUG, "COMXPlayerAudio:: Discontinuity - was:%f, should be:%f, error:%f", clock, clock+error, error);
-        */
-      }
-    }
-    /*
-    else if (m_synctype == SYNC_SKIPDUP && m_skipdupcount == 0 && fabs(m_error) > DVD_MSEC_TO_TIME(10))
-    if (m_skipdupcount == 0 && fabs(m_error) > DVD_MSEC_TO_TIME(10))
-    {
-      //check how many packets to skip/duplicate
-      m_skipdupcount = (int)(m_error / duration);
-      //if less than one frame off, see if it's more than two thirds of a frame, so we can get better in sync
-      if (m_skipdupcount == 0 && fabs(m_error) > duration / 3 * 2)
-        m_skipdupcount = (int)(m_error / (duration / 3 * 2));
-
-      if (m_skipdupcount > 0)
-        CLog::Log(LOGDEBUG, "OMXPlayerAudio:: Duplicating %i packet(s) of %.2f ms duration",
-                  m_skipdupcount, duration / DVD_TIME_BASE * 1000.0);
-      else if (m_skipdupcount < 0)
-        CLog::Log(LOGDEBUG, "OMXPlayerAudio:: Skipping %i packet(s) of %.2f ms duration ",
-                  m_skipdupcount * -1,  duration / DVD_TIME_BASE * 1000.0);
-    }
-    */
-  }
-}
-
 bool OMXPlayerAudio::CodecChange()
 {
   unsigned int old_bitrate = m_hints.bitrate;
@@ -305,16 +205,18 @@
     m_hints.samplerate = m_pAudioCodec->GetSampleRate();
   }
 
-  /* only check bitrate changes on CODEC_ID_DTS, CODEC_ID_AC3, CODEC_ID_EAC3 */
-  if(m_hints.codec != CODEC_ID_DTS && m_hints.codec != CODEC_ID_AC3 && m_hints.codec != CODEC_ID_EAC3)
+  /* only check bitrate changes on AV_CODEC_ID_DTS, AV_CODEC_ID_AC3, AV_CODEC_ID_EAC3 */
+  if(m_hints.codec != AV_CODEC_ID_DTS && m_hints.codec != AV_CODEC_ID_AC3 && m_hints.codec != AV_CODEC_ID_EAC3)
     new_bitrate = old_bitrate = 0;
-    
+
+  // for passthrough we only care about the codec and the samplerate
+  bool minor_change = m_hints_current.channels       != m_hints.channels ||
+                      m_hints_current.bitspersample  != m_hints.bitspersample ||
+                      old_bitrate                    != new_bitrate;
+
   if(m_hints_current.codec          != m_hints.codec ||
-     m_hints_current.channels       != m_hints.channels ||
      m_hints_current.samplerate     != m_hints.samplerate ||
-     m_hints_current.bitspersample  != m_hints.bitspersample ||
-     old_bitrate                    != new_bitrate ||
-     !m_DecoderOpen)
+     (!m_passthrough && minor_change) || !m_DecoderOpen)
   {
     m_hints_current = m_hints;
     return true;
@@ -334,7 +236,7 @@
   const uint8_t *data_dec = pkt->pData;
   int            data_len = pkt->iSize;
 
-  if(!OMX_IS_RAW(m_format.m_dataFormat))
+  if(!OMX_IS_RAW(m_format.m_dataFormat) && !bDropPacket)
   {
     while(!m_bStop && data_len > 0)
     {
@@ -391,18 +293,12 @@
           }
         }
 
-        int n = (m_nChannels * m_hints.bitspersample * m_hints.samplerate)>>3;
-        if (n > 0)
-          m_audioClock += ((double)decoded_size * DVD_TIME_BASE) / n;
-
-        if(m_speed == DVD_PLAYSPEED_NORMAL)
-          HandleSyncError((((double)decoded_size * DVD_TIME_BASE) / n));
         break;
 
       }
     }
   }
-  else
+  else if(!bDropPacket)
   {
     if(CodecChange())
     {
@@ -430,9 +326,6 @@
         m_omxAudio.AddPackets(pkt->pData, pkt->iSize, m_audioClock, m_audioClock);
       }
 
-      if(m_speed == DVD_PLAYSPEED_NORMAL)
-        HandleSyncError(0);
-
       m_audioStats.AddSampleBytes(pkt->iSize);
 
       break;
@@ -442,16 +335,6 @@
   if(bDropPacket)
     m_stalled = false;
 
-  if(m_omxAudio.GetCacheTime() < 0.1 /*&& min(99,m_messageQueue.GetLevel() + MathUtils::round_int(100.0/8.0*GetCacheTime())) > 10*/)
-  {
-    m_stalled = true;
-    if(!m_av_clock->OMXAudioBuffer() && m_av_clock->HasVideo() && m_speed == DVD_PLAYSPEED_NORMAL)
-    {
-      clock_gettime(CLOCK_REALTIME, &m_starttime);
-      m_av_clock->OMXAudioBufferStart();
-    }
-  }
-
   // signal to our parent that we have initialized
   if(m_started == false)
   {
@@ -495,25 +378,28 @@
       CLog::Log(LOGINFO, "Audio: dts:%.0f pts:%.0f size:%d (s:%d f:%d d:%d l:%d) s:%d %d/%d late:%d,%d", pPacket->dts, pPacket->pts,
            (int)pPacket->iSize, m_started, m_flush, bPacketDrop, m_stalled, m_speed, 0, 0, (int)m_omxAudio.GetAudioRenderingLatency(), (int)m_hints_current.samplerate);
       #endif
+
+      /* PLEX */
+      // if Audio is ahead Video, they yield to other thread
+      if (pPacket->pts > g_VideoCachePts)
+        Sleep(0);
+      /* END PLEX */
+
       if(Decode(pPacket, m_speed > DVD_PLAYSPEED_NORMAL || m_speed < 0 || bPacketDrop))
       {
-        if (m_stalled && (m_omxAudio.GetCacheTime() > (AUDIO_BUFFER_SECONDS * 0.75f)))
+        // we are not running until something is cached in output device
+        if(m_stalled && m_omxAudio.GetCacheTime() > 0.0)
         {
           CLog::Log(LOGINFO, "COMXPlayerAudio - Switching to normal playback");
           m_stalled = false;
-          if(m_av_clock->HasVideo() && m_av_clock->OMXAudioBuffer())
-            m_av_clock->OMXAudioBufferStop();
         }
       }
-      // hard unlock audio out buffering
-      clock_gettime(CLOCK_REALTIME, &m_endtime);
-      //int iLevel = min(99,m_messageQueue.GetLevel() + MathUtils::round_int(100.0/8.0*GetCacheTime()));
-      if(/*iLevel < 10 &&*/ m_stalled && m_av_clock->OMXAudioBuffer() && (m_endtime.tv_sec - m_starttime.tv_sec) > 1)
-      {
-        m_stalled = false;
-        if(m_av_clock->HasVideo() && m_av_clock->OMXAudioBuffer())
-          m_av_clock->OMXAudioBufferStop();
-      }
+
+      /* PLEX */
+      // update out position
+      g_AudioCachePts = pPacket->pts;
+      /* END PLEX */
+
     }
     else if (pMsg->IsType(CDVDMsg::GENERAL_SYNCHRONIZE))
     {
@@ -526,45 +412,36 @@
     { //player asked us to set internal clock
       CDVDMsgGeneralResync* pMsgGeneralResync = (CDVDMsgGeneralResync*)pMsg;
 
-      if (pMsgGeneralResync->m_timestamp != DVD_NOPTS_VALUE)
-        m_audioClock = pMsgGeneralResync->m_timestamp;
-
-      if (pMsgGeneralResync->m_clock)
+      if (pMsgGeneralResync->m_clock && pMsgGeneralResync->m_timestamp != DVD_NOPTS_VALUE)
       {
-        CLog::Log(LOGDEBUG, "COMXPlayerAudio - CDVDMsg::GENERAL_RESYNC(%f, 1)", m_audioClock);
-        m_av_clock->Discontinuity(m_audioClock);
-        //m_av_clock->OMXUpdateClock(m_audioClock);
+        CLog::Log(LOGDEBUG, "CDVDPlayerAudio - CDVDMsg::GENERAL_RESYNC(%f, %f, 1)", m_audioClock, pMsgGeneralResync->m_timestamp);
+        m_av_clock->Discontinuity(pMsgGeneralResync->m_timestamp);
       }
       else
-        CLog::Log(LOGDEBUG, "COMXPlayerAudio - CDVDMsg::GENERAL_RESYNC(%f, 0)", m_audioClock);
+        CLog::Log(LOGDEBUG, "CDVDPlayerAudio - CDVDMsg::GENERAL_RESYNC(%f, 0)", m_audioClock);
+
       m_flush = false;
+      m_audioClock = DVD_NOPTS_VALUE;
     }
     else if (pMsg->IsType(CDVDMsg::GENERAL_RESET))
     {
       CLog::Log(LOGDEBUG, "COMXPlayerAudio - CDVDMsg::GENERAL_RESET");
       if (m_pAudioCodec)
         m_pAudioCodec->Reset();
-      m_av_clock->Lock();
-      m_av_clock->OMXStop(false);
       m_omxAudio.Flush();
-      m_av_clock->OMXReset(false);
-      m_av_clock->UnLock();
       m_started = false;
+      m_audioClock = DVD_NOPTS_VALUE;
     }
     else if (pMsg->IsType(CDVDMsg::GENERAL_FLUSH))
     {
       CLog::Log(LOGDEBUG, "COMXPlayerAudio - CDVDMsg::GENERAL_FLUSH");
-      m_av_clock->Lock();
-      m_av_clock->OMXStop(false);
       m_omxAudio.Flush();
-      m_av_clock->OMXReset(false);
-      m_av_clock->UnLock();
-      m_syncclock = true;
       m_stalled   = true;
       m_started   = false;
 
       if (m_pAudioCodec)
         m_pAudioCodec->Reset();
+      m_audioClock = DVD_NOPTS_VALUE;
     }
     else if (pMsg->IsType(CDVDMsg::PLAYER_STARTED))
     {
@@ -579,18 +456,8 @@
     }
     else if (pMsg->IsType(CDVDMsg::GENERAL_DELAY))
     {
-      if (m_speed != DVD_PLAYSPEED_PAUSE)
-      {
-        double timeout = static_cast<CDVDMsgDouble*>(pMsg)->m_value;
-
-        CLog::Log(LOGDEBUG, "COMXPlayerAudio - CDVDMsg::GENERAL_DELAY(%f)", timeout);
-
-        timeout *= (double)DVD_PLAYSPEED_NORMAL / abs(m_speed);
-        timeout += m_av_clock->GetAbsoluteClock();
-
-        while(!m_bStop && m_av_clock->GetAbsoluteClock() < timeout)
-          Sleep(1);
-      }
+      double timeout = static_cast<CDVDMsgDouble*>(pMsg)->m_value;
+      CLog::Log(LOGDEBUG, "COMXPlayerAudio - CDVDMsg::GENERAL_DELAY(%f)", timeout);
     }
     else if (pMsg->IsType(CDVDMsg::PLAYER_SETSPEED))
     {
@@ -599,10 +466,6 @@
         m_speed = static_cast<CDVDMsgInt*>(pMsg)->m_value;
         CLog::Log(LOGDEBUG, "COMXPlayerAudio - CDVDMsg::PLAYER_SETSPEED %d", m_speed);
       }
-      if (m_speed != DVD_PLAYSPEED_NORMAL)
-      {
-        m_syncclock = true;
-      }
     }
     else if (pMsg->IsType(CDVDMsg::AUDIO_SILENCE))
     {
@@ -615,6 +478,7 @@
     else if (pMsg->IsType(CDVDMsg::GENERAL_STREAMCHANGE))
     {
       COMXMsgAudioCodecChange* msg(static_cast<COMXMsgAudioCodecChange*>(pMsg));
+      CLog::Log(LOGDEBUG, "COMXPlayerAudio - CDVDMsg::GENERAL_STREAMCHANGE");
       OpenStream(msg->m_hints, msg->m_codec);
       msg->m_codec = NULL;
     }
@@ -657,7 +521,6 @@
     hdmi_passthrough_ac3 = true;
   if (m_DllBcmHost.vc_tv_hdmi_audio_supported(EDID_AudioFormat_eDTS, 2, EDID_AudioSampleRate_e44KHz, EDID_AudioSampleSize_16bit ) == 0)
     hdmi_passthrough_dts = true;
-  //printf("Audio support AC3=%d, DTS=%d\n", hdmi_passthrough_ac3, hdmi_passthrough_dts);
 
   m_passthrough = false;
   m_hw_decode   = false;
@@ -667,12 +530,12 @@
   /* pathrought is overriding hw decode*/
   if(AUDIO_IS_BITSTREAM(g_guiSettings.GetInt("audiooutput.mode")) && m_use_passthrough)
   {
-    if(hints.codec == CODEC_ID_AC3 && g_guiSettings.GetBool("audiooutput.ac3passthrough") && hdmi_passthrough_ac3)
+    if(hints.codec == AV_CODEC_ID_AC3 && g_guiSettings.GetBool("audiooutput.ac3passthrough") && hdmi_passthrough_ac3)
     {
       dataFormat = AE_FMT_AC3;
       m_passthrough = true;
     }
-    if(hints.codec == CODEC_ID_DTS && g_guiSettings.GetBool("audiooutput.dtspassthrough") && hdmi_passthrough_dts)
+    if(hints.codec == AV_CODEC_ID_DTS && g_guiSettings.GetBool("audiooutput.dtspassthrough") && hdmi_passthrough_dts)
     {
       dataFormat = AE_FMT_DTS;
       m_passthrough = true;
@@ -682,12 +545,12 @@
   /* hw decode */
   if(m_use_hw_decode && !m_passthrough)
   {
-    if(hints.codec == CODEC_ID_AC3 && COMXAudio::CanHWDecode(m_hints.codec))
+    if(hints.codec == AV_CODEC_ID_AC3 && COMXAudio::CanHWDecode(m_hints.codec))
     {
       dataFormat = AE_FMT_AC3;
       m_hw_decode = true;
     }
-    if(hints.codec == CODEC_ID_DTS && COMXAudio::CanHWDecode(m_hints.codec))
+    if(hints.codec == AV_CODEC_ID_DTS && COMXAudio::CanHWDecode(m_hints.codec))
     {
       dataFormat = AE_FMT_DTS;
       m_hw_decode = true;
@@ -697,10 +560,10 @@
   /* software path */
   if(!m_passthrough && !m_hw_decode)
   {
-    /* 6 channel have to be mapped to 8 for PCM */
-    if(m_nChannels > 4)
-      m_nChannels = 8;
-    dataFormat = AE_FMT_S16NE;
+    if (m_pAudioCodec && m_pAudioCodec->GetBitsPerSample() == 16)
+      dataFormat = AE_FMT_S16NE;
+    else
+      dataFormat = AE_FMT_FLOAT;
   }
 
   return dataFormat;
@@ -712,33 +575,25 @@
   m_passthrough = false;
   m_hw_decode   = false;
 
-  bool bSendParent = false;
-
   if(m_DecoderOpen)
   {
-    WaitCompletion();
     m_omxAudio.Deinitialize();
     m_DecoderOpen = false;
-    bSendParent = true;
   }
 
   /* setup audi format for audio render */
   m_format.m_sampleRate    = m_hints.samplerate;
-  m_format.m_channelLayout = m_pAudioCodec->GetChannelMap(); 
   /* GetDataFormat is setting up evrything */
   m_format.m_dataFormat = GetDataFormat(m_hints);
 
-  std::string device = "";
-  
-  if(g_guiSettings.GetInt("audiooutput.mode") == AUDIO_HDMI)
-    device = "hdmi";
-  else
-    device = "local";
-
-  m_av_clock->Lock();
-  m_av_clock->OMXStop(false);
-
-  bool bAudioRenderOpen = m_omxAudio.Initialize(m_format, device, m_av_clock, m_hints, m_passthrough, m_hw_decode);
+  uint64_t channelMap = 0;
+  if (m_pAudioCodec && !m_passthrough)
+    channelMap = m_pAudioCodec->GetChannelMap();
+  else if (m_passthrough)
+    // we just want to get the channel count right to stop OMXAudio.cpp rejecting stream
+    // the actual layout is not used
+    channelMap = (1<<m_nChannels)-1;
+  bool bAudioRenderOpen = m_omxAudio.Initialize(m_format, m_av_clock, m_hints, channelMap, m_passthrough, m_hw_decode);
 
   m_codec_name = "";
   m_bad_state  = !bAudioRenderOpen;
@@ -754,31 +609,14 @@
       m_codec_name.c_str(), m_nChannels, m_hints.samplerate, m_hints.bitspersample);
   }
 
-  m_av_clock->OMXStateExecute(false);
-  m_av_clock->HasAudio(bAudioRenderOpen);
-  m_av_clock->OMXReset(false);
-  m_av_clock->UnLock();
-
   m_started = false;
 
-  // TODO : Send FLUSH to parent, only if we had a valid open codec. 
-  // this is just a workaround to get the omx video decoder happy again
-  // This situation happens, for example where we have in the stream an audio codec change
-  if(bSendParent)
-    m_messageParent.Put(new CDVDMsg(CDVDMsg::GENERAL_FLUSH));
-
   return bAudioRenderOpen;
 }
 
 void OMXPlayerAudio::CloseDecoder()
 {
-  m_av_clock->Lock();
-  m_av_clock->OMXStop(false);
   m_omxAudio.Deinitialize();
-  m_av_clock->HasAudio(false);
-  m_av_clock->OMXReset(false);
-  m_av_clock->UnLock();
-
   m_DecoderOpen = false;
 }
 
@@ -792,6 +630,11 @@
   return m_omxAudio.GetCacheTime();
 }
 
+double OMXPlayerAudio::GetCacheTotal()
+{
+  return m_omxAudio.GetCacheTotal();
+}
+
 void OMXPlayerAudio::SubmitEOS()
 {
   if(!m_bad_state)
@@ -824,21 +667,6 @@
   }
 }
 
-void OMXPlayerAudio::RegisterAudioCallback(IAudioCallback *pCallback)
-{
-  m_omxAudio.RegisterAudioCallback(pCallback);
-}
-
-void OMXPlayerAudio::UnRegisterAudioCallback()
-{
-  m_omxAudio.UnRegisterAudioCallback();
-}
-
-void OMXPlayerAudio::SetCurrentVolume(float fVolume)
-{
-  m_omxAudio.SetCurrentVolume(fVolume);
-}
-
 void OMXPlayerAudio::SetSpeed(int speed)
 {
   if(m_messageQueue.IsInited())
diff -ur a/xbmc/cores/omxplayer/OMXPlayerAudio.h b/xbmc/cores/omxplayer/OMXPlayerAudio.h
--- a/xbmc/cores/omxplayer/OMXPlayerAudio.h	2015-03-12 20:52:41.090096999 +0100
+++ b/xbmc/cores/omxplayer/OMXPlayerAudio.h	2015-03-12 20:48:25.166096999 +0100
@@ -55,35 +55,18 @@
   bool                      m_use_hw_decode;
   bool                      m_hw_decode;
   AEAudioFormat             m_format;
-  CAEChannelInfo            m_channelLayout;
   COMXAudioCodecOMX         *m_pAudioCodec;
   int                       m_speed;
   bool                      m_silence;
   double                    m_audioClock;
-  double m_error;    //last average error
-
-  int64_t m_errortime; //timestamp of last time we measured
-  int64_t m_freq;
-
-  void   HandleSyncError(double duration);
-  double m_errorbuff; //place to store average errors
-  int    m_errorcount;//number of errors stored
-  bool   m_syncclock;
-
-  double m_integral; //integral correction for resampler
-  int    m_skipdupcount; //counter for skip/duplicate synctype
-  bool   m_prevskipped;
 
   bool                      m_stalled;
   bool                      m_started;
 
   BitstreamStats            m_audioStats;
 
-  struct timespec           m_starttime, m_endtime;
   bool                      m_buffer_empty;
   bool                      m_flush;
-  //SYNC_DISCON, SYNC_SKIPDUP, SYNC_RESAMPLE
-  int                       m_synctype;
   int                       m_nChannels;
   bool                      m_DecoderOpen;
 
@@ -118,16 +101,28 @@
   void CloseDecoder();
   double GetDelay();
   double GetCacheTime();
-  double GetCurrentPTS() { return m_audioClock; };
+  double GetCacheTotal();
+  double GetCurrentPts() { return m_audioClock; };
   void WaitCompletion();
   void SubmitEOS();
-  void  RegisterAudioCallback(IAudioCallback* pCallback);
-  void  UnRegisterAudioCallback();
-  void SetCurrentVolume(float fVolume);
+
+  void  RegisterAudioCallback(IAudioCallback* pCallback) { m_omxAudio.RegisterAudioCallback(pCallback); }
+  void  UnRegisterAudioCallback()                        { m_omxAudio.UnRegisterAudioCallback(); }
+  void SetVolume(float fVolume)                          { m_omxAudio.SetVolume(fVolume); }
+  void SetMute(bool bOnOff)                              { m_omxAudio.SetMute(bOnOff); }
+  void SetDynamicRangeCompression(long drc)              { m_omxAudio.SetDynamicRangeCompression(drc); }
+  float GetDynamicRangeAmplification()                   { return m_omxAudio.GetDynamicRangeAmplification(); }
   void SetSpeed(int iSpeed);
   int  GetAudioBitrate();
   std::string GetPlayerInfo();
 
   bool BadState() { return m_bad_state; }
 };
+
+/* PLEX */
+extern CEvent g_CacheSyncEvent;
+extern double g_VideoCachePts;
+extern double g_AudioCachePts;
+/* END PLEX */
+
 #endif
diff -ur a/xbmc/cores/omxplayer/OMXPlayer.cpp b/xbmc/cores/omxplayer/OMXPlayer.cpp
--- a/xbmc/cores/omxplayer/OMXPlayer.cpp	2015-03-12 20:52:41.090096999 +0100
+++ b/xbmc/cores/omxplayer/OMXPlayer.cpp	2015-03-12 20:48:25.166096999 +0100
@@ -1,5 +1,5 @@
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2005-2012 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -18,6 +18,15 @@
  *
  */
 
+/* PLEX */
+#include <boost/algorithm/string/replace.hpp>
+#include <boost/foreach.hpp>
+#include <boost/enable_shared_from_this.hpp>
+#include <boost/thread.hpp>
+#include <boost/thread/locks.hpp>
+/* END PLEX */
+
+#include "threads/SystemClock.h"
 #include "system.h"
 
 #if defined (HAS_OMXPLAYER)
@@ -62,33 +71,88 @@
 #include "DVDInputStreams/DVDInputStreamTV.h"
 #include "DVDInputStreams/DVDInputStreamPVRManager.h"
 
+#include "DVDDemuxers/DVDDemux.h"
 #include "DVDDemuxers/DVDDemuxUtils.h"
 #include "DVDDemuxers/DVDDemuxVobsub.h"
 #include "DVDDemuxers/DVDFactoryDemuxer.h"
 #include "DVDDemuxers/DVDDemuxFFmpeg.h"
 
-#include "DVDFileInfo.h"
+#include "DVDCodecs/DVDCodecs.h"
+#include "DVDCodecs/DVDFactoryCodec.h"
 
-#include "Util.h"
-#include "LangInfo.h"
+#include "DVDFileInfo.h"
 
-#include "utils/JobManager.h"
-//#include "cores/AudioEngine/AEFactory.h"
-//#include "cores/AudioEngine/Utils/AEUtil.h"
-#include "video/VideoThumbLoader.h"
+#include "utils/LangCodeExpander.h"
+#include "guilib/LocalizeStrings.h"
 
+#include "utils/URIUtils.h"
+#include "GUIInfoManager.h"
+#include "guilib/GUIWindowManager.h"
+#include "Application.h"
+#include "ApplicationMessenger.h"
+#include "DVDPerformanceCounter.h"
+#include "filesystem/File.h"
+#include "pictures/Picture.h"
+#include "DllSwScale.h"
+#ifdef HAS_VIDEO_PLAYBACK
+#include "cores/VideoRenderers/RenderManager.h"
+#endif
+#ifdef HAS_PERFORMANCE_SAMPLE
+#include "xbmc/utils/PerformanceSample.h"
+#else
+#define MEASURE_FUNCTION
+#endif
+#include "settings/AdvancedSettings.h"
+#include "FileItem.h"
+#include "settings/GUISettings.h"
+#include "GUIUserMessages.h"
+#include "settings/Settings.h"
+#include "utils/log.h"
+#include "utils/TimeUtils.h"
+#include "utils/StreamDetails.h"
 #include "pvr/PVRManager.h"
 #include "pvr/channels/PVRChannel.h"
 #include "pvr/windows/GUIWindowPVR.h"
 #include "pvr/addons/PVRClients.h"
 #include "filesystem/PVRFile.h"
-
+#include "video/dialogs/GUIDialogFullScreenInfo.h"
+#include "utils/StreamUtils.h"
+#include "utils/Variant.h"
+#include "storage/MediaManager.h"
+#include "dialogs/GUIDialogBusy.h"
+#include "dialogs/GUIDialogKaiToast.h"
+#include "xbmc/playlists/PlayListM3U.h"
 #include "utils/StringUtils.h"
+#include "Util.h"
+#include "URL.h"
+#include "LangInfo.h"
+#include "ApplicationMessenger.h"
+
+/* PLEX */
+#include "FileSystem/PlexDirectory.h"
+#include "Client/PlexServerManager.h"
 
-using namespace XFILE;
+#include <boost/lexical_cast.hpp>
+
+#include "Client/PlexMediaServerClient.h"
+#include "ApplicationMessenger.h"
+#include "Client/PlexTranscoderClient.h"
+#include "PlexApplication.h"
+#include "FileSystem/PlexFile.h"
+
+CEvent g_CacheSyncEvent;
+double g_VideoCachePts;
+double g_AudioCachePts;
+/* END PLEX */
+
+// video not playing from clock, but stepped
+#define TP(speed)  ((speed) < 0 || (speed) > 4*DVD_PLAYSPEED_NORMAL)
+// audio not playing
+#define TPA(speed) ((speed) != DVD_PLAYSPEED_PAUSE && (speed) != DVD_PLAYSPEED_NORMAL)
+
+using namespace std;
 using namespace PVR;
 
-// ****************************************************************
 void COMXSelectionStreams::Clear(StreamType type, StreamSource source)
 {
   CSingleLock lock(m_section);
@@ -393,7 +457,6 @@
   }
 }
 
-// ****************************************************************
 COMXPlayer::COMXPlayer(IPlayerCallback &callback) 
     : IPlayer(callback),
       CThread("COMXPlayer"),
@@ -402,35 +465,53 @@
       m_CurrentSubtitle(STREAM_SUBTITLE, DVDPLAYER_SUBTITLE),
       m_CurrentTeletext(STREAM_TELETEXT, DVDPLAYER_TELETEXT),
       m_messenger("player"),
-      m_player_video(&m_av_clock, &m_overlayContainer, m_messenger),
-      m_player_audio(&m_av_clock, m_messenger),
-      m_player_subtitle(&m_overlayContainer),
-      m_player_teletext(),
+      m_omxPlayerVideo(&m_av_clock, &m_overlayContainer, m_messenger),
+      m_omxPlayerAudio(&m_av_clock, m_messenger),
+      m_dvdPlayerSubtitle(&m_overlayContainer),
+      m_dvdPlayerTeletext(),
+      /* PLEX */
+      m_hidingSub(false),
+      m_vobsubToDisplay(-1),
+      m_readRate(0),
+      /* END PLEX */
       m_ready(true)
 {
-  m_bAbortRequest     = false;
   m_pDemuxer          = NULL;
   m_pSubtitleDemuxer  = NULL;
   m_pInputStream      = NULL;
-  m_UpdateApplication = 0;
-  m_caching           = CACHESTATE_DONE;
-  m_playSpeed         = DVD_PLAYSPEED_NORMAL;
-  m_HasVideo = false;
-  m_HasAudio = false;
 
   m_dvd.Clear();
   m_State.Clear();
   m_EdlAutoSkipMarkers.Clear();
+  m_UpdateApplication = 0;
+
+  m_bAbortRequest = false;
+  m_errorCount = 0;
+  m_offset_pts = 0.0;
+  m_playSpeed = DVD_PLAYSPEED_NORMAL;
+  m_caching           = CACHESTATE_DONE;
+  m_HasVideo          = false;
+  m_HasAudio          = false;
+  m_stepped           = false;
+  m_video_fifo        = 0;
+  m_audio_fifo        = 0;
+  m_last_check_time   = 0.0;
+  m_stamp             = 0.0;
 
   memset(&m_SpeedState, 0, sizeof(m_SpeedState));
+
+#ifdef DVDDEBUG_MESSAGE_TRACKER
+  g_dvdMessageTracker.Init();
+#endif
 }
 
 COMXPlayer::~COMXPlayer()
 {
   CloseFile();
 
-  if(m_messenger.IsInited())
-    m_messenger.End();
+#ifdef DVDDEBUG_MESSAGE_TRACKER
+  g_dvdMessageTracker.DeInit();
+#endif
 }
 
 bool COMXPlayer::OpenFile(const CFileItem &file, const CPlayerOptions &options)
@@ -444,34 +525,24 @@
     if(IsRunning())
       CloseFile();
 
-    if(!m_av_clock.OMXInitialize(false, false))
-    {
-      return false;
-    }
-    if(g_guiSettings.GetBool("videoplayer.adjustrefreshrate"))
-      m_av_clock.HDMIClockSync();
+    m_bAbortRequest = false;
 
-    m_playSpeed = DVD_PLAYSPEED_NORMAL;
     SetPlaySpeed(DVD_PLAYSPEED_NORMAL);
 
-    m_PlayerOptions     = options;
-    m_bAbortRequest     = false;
-
+    m_State.Clear();
     m_UpdateApplication = 0;
     m_offset_pts        = 0;
-    m_current_volume    = 0;
-    m_current_mute      = false;
-    m_change_volume     = true;
 
+    m_PlayerOptions = options;
     m_item              = file;
     m_mimetype          = file.GetMimeType();
     m_filename          = file.GetPath();
 
-    m_State.Clear();
-
     m_ready.Reset();
 
+#if defined(HAS_VIDEO_PLAYBACK)
     g_renderManager.PreInit();
+#endif
 
     Create();
     if(!m_ready.WaitMSec(100))
@@ -480,8 +551,18 @@
       if(dialog)
       {
         dialog->Show();
-        while(!m_ready.WaitMSec(1))
+        while(!m_ready.WaitMSec(100))
+        {
+          /* PLEX */
+          if (dialog->IsCanceled())
+          {
+            m_bStop = true;
+            Abort();
+          }
+          /* END PLEX */
+
           g_windowManager.ProcessRenderLoop(false);
+        }
         dialog->Close();
       }
     }
@@ -501,7 +582,7 @@
 
 bool COMXPlayer::CloseFile()
 {
-  CLog::Log(LOGDEBUG, "COMXPlayer::CloseFile");
+  CLog::Log(LOGNOTICE, "COMXPlayer::CloseFile");
 
   // unpause the player
   SetPlaySpeed(DVD_PLAYSPEED_NORMAL);
@@ -519,14 +600,12 @@
   if(m_pInputStream)
     m_pInputStream->Abort();
 
-  CLog::Log(LOGDEBUG, "COMXPlayer: waiting for threads to exit");
+  CLog::Log(LOGNOTICE, "COMXPlayer: waiting for threads to exit");
 
   // wait for the main thread to finish up
   // since this main thread cleans up all other resources and threads
   // we are done after the StopThread call
   StopThread();
-  
-  CLog::Log(LOGDEBUG, "COMXPlayer: finished waiting");
 
   m_Edl.Clear();
   m_EdlAutoSkipMarkers.Clear();
@@ -534,7 +613,10 @@
   m_HasVideo = false;
   m_HasAudio = false;
 
+  CLog::Log(LOGNOTICE, "COMXPlayer: finished waiting");
+#if defined(HAS_VIDEO_PLAYBACK)
   g_renderManager.UnInit();
+#endif
   return true;
 }
 
@@ -572,13 +654,26 @@
 
   // before creating the input stream, if this is an HLS playlist then get the
   // most appropriate bitrate based on our network settings
-  if (filename.Left(7) == "http://" && filename.Right(5) == ".m3u8")
+  // ensure to strip off the url options by using a temp CURL object
+#ifndef __PLEX__
+  if (filename.Left(7) == "http://" && CURL(filename).GetFileName().Right(5) == ".m3u8")
+#else
+  CURL url(filename);
+  if (url.GetFileName().Right(5) == ".m3u8" && (url.GetProtocol() == "http" || url.GetProtocol() == "https" || url.GetProtocol() == "plexserver"))
+#endif
   {
     // get the available bandwidth (as per user settings)
     int maxrate = g_guiSettings.GetInt("network.bandwidth");
     if(maxrate <= 0)
       maxrate = INT_MAX;
 
+    /* PLEX */
+    if (m_item.GetProperty("plexDidTranscode").asBoolean())
+      maxrate = INT_MAX;
+    else
+      maxrate = CPlexTranscoderClient::getBandwidthForQuality(g_guiSettings.GetInt("plexmediaserver.onlinemediaquality"));
+    /* END PLEX */
+
     // determine the most appropriate stream
     m_filename = PLAYLIST::CPlayListM3U::GetBestBandwidthStream(m_filename, (size_t)maxrate);
   }
@@ -609,6 +704,7 @@
   &&  !m_pInputStream->IsStreamType(DVDSTREAM_TYPE_TV)
   &&  !m_pInputStream->IsStreamType(DVDSTREAM_TYPE_HTSP))
   {
+#ifndef __PLEX__
     // find any available external subtitles
     std::vector<CStdString> filenames;
     CUtil::ScanForExternalSubtitles( m_filename, filenames );
@@ -635,14 +731,125 @@
         }
       }
     } // end loop over all subtitle files
+#else
+    CFileItemPtr part = m_item.m_selectedMediaPart;
+    if (part)
+    {
+      CFileItemPtr   lastIdxStream;
+      int            lastIdxSource = -1;
+
+      BOOST_FOREACH(CFileItemPtr stream, part->m_mediaPartStreams)
+      {
+        if (stream->GetProperty("streamType").asInteger() == PLEX_STREAM_SUBTITLE &&
+            (stream->GetProperty("index").asInteger(-1) == -1) &&
+          (!g_guiSettings.GetBool("plexmediaserver.transcodesubtitles")))
+        {
+          OMXSelectionStream s;
+          s.type     = STREAM_SUBTITLE;
+          s.id       = stream->GetProperty("subIndex").asInteger() >= 0 ? stream->GetProperty("subIndex").asInteger() : stream->GetProperty("id").asInteger();
+          s.plexID   = stream->GetProperty("id").asInteger();
+          s.filename = stream->GetProperty("key").asString();
+          s.name     = stream->GetProperty("language").asString();
 
+          if (stream->GetProperty("codec").asString() == "idx")
+          {
+            // All IDX streams have the same source.
+            if (lastIdxStream)
+              s.source = lastIdxSource;
+            else
+              s.source = m_SelectionStreams.Source(STREAM_SOURCE_DEMUX_SUB, stream->GetProperty("key").asString());
+          }
+          else
+          {
+            // New file, new source.
+            s.source = m_SelectionStreams.Source(STREAM_SOURCE_TEXT, stream->GetProperty("key").asString());
+          }
+
+          // Cache the subtitle locally. Since multiple streams can be served out of a single file,
+          // let's not download it multiple times, one for each stream.
+          //
+          CFileItemPtr idxStream = stream;
+          if (lastIdxStream)
+            idxStream = lastIdxStream;
+
+          CStdString path = "special://temp/subtitle.plex." + idxStream->GetProperty("id").asString() + "." + idxStream->GetProperty("codec").asString();
+          CLog::Log(LOGINFO, "Considering caching Plex subtitle locally for stream %s (codec: %s) to %s (exists: %d)",
+                    idxStream->GetProperty("id").asString().c_str(),
+                    idxStream->GetProperty("codec").asString().c_str(),
+                    path.c_str(),
+                    CFile::Exists(path));
+
+          CURL newUrl(idxStream->GetProperty("key").asString());
+          CStdString encoding = g_langInfo.GetSubtitleCharSet();
+          if (encoding == "UTF-8")
+            newUrl.SetOption("encoding", "utf-8");
+
+
+          /* PLEX */
+          if (CFile::Exists(path))
+          {
+            s.filename = path;
+            m_SelectionStreams.Update(s);
+          }
+          else
+          {
+            CURL plexUrl(newUrl);
+            CPlexFile::BuildHTTPURL(plexUrl);
+            if (g_plexApplication.busy.blockWaitingForJob(new CPlexDownloadFileJob(plexUrl.Get(), path), NULL))
+            {
+              CLog::Log(LOGDEBUG,"file %s was downloaded successfully", path.c_str());
+              s.filename = path;
+              m_SelectionStreams.Update(s);
+            }
+            else
+            {
+              CLog::Log(LOGERROR,"Failed to download  %s", path.c_str());
+              return false;
+            }
+          }
+          /* END PLEX */
+
+          // If it's an IDX, we need to cache the SUB file as well.
+          if (idxStream->GetProperty("codec").asString() == "idx")
+          {
+            CStdString path = "special://temp/subtitle.plex." + idxStream->GetProperty("id").asString() + ".sub";
+            if (CFile::Exists(path) == false)
+            {
+              CLog::Log(LOGINFO, "Caching Plex subtitle locally for stream %lld to %s", idxStream->GetProperty("id").asInteger(), path.c_str());
+
+              CURL subUrl(idxStream->GetProperty("key").asString());
+              subUrl.SetFileName(subUrl.GetFileName() + ".sub");
+
+              CURL plexUrl(subUrl);
+              CPlexFile::BuildHTTPURL(plexUrl);
+
+              if (g_plexApplication.busy.blockWaitingForJob(new CPlexDownloadFileJob(plexUrl.Get(), path), NULL))
+              {
+                CLog::Log(LOGDEBUG,"file %s was downloaded successfully", path.c_str());
+              }
+              else
+              {
+                CLog::Log(LOGERROR,"Failed to download  %s", path.c_str());
+                return false;
+              }
+            }
+
+            // Remember the last IDX stream.
+            lastIdxStream = idxStream;
+            lastIdxSource = s.source;
+          }
+        }
+      }
+    }
+#endif
     g_settings.m_currentVideoSettings.m_SubtitleCached = true;
   }
 
   SetAVDelay(g_settings.m_currentVideoSettings.m_AudioDelay);
   SetSubTitleDelay(g_settings.m_currentVideoSettings.m_SubtitleDelay);
-  m_av_clock.Reset();
+  m_clock.Reset();
   m_dvd.Clear();
+  m_errorCount = 0;
   m_iChannelEntryTimeOut = 0;
 
   return true;
@@ -660,7 +867,11 @@
     int attempts = 10;
     while(!m_bStop && attempts-- > 0)
     {
-      m_pDemuxer = CDVDFactoryDemuxer::CreateDemuxer(m_pInputStream);
+      /* PLEX */
+      CStdString error;
+      m_pDemuxer = CDVDFactoryDemuxer::CreateDemuxer(m_pInputStream, error);
+      /* END PLEX */
+
       if(!m_pDemuxer && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER))
       {
         continue;
@@ -690,14 +901,19 @@
   m_SelectionStreams.Clear(STREAM_NONE, STREAM_SOURCE_NAV);
   m_SelectionStreams.Update(m_pInputStream, m_pDemuxer);
 
+  // Update Plex streams from the demuxer.
+  RelinkPlexStreams();
+  /* END PLEX */
+
   int64_t len = m_pInputStream->GetLength();
   int64_t tim = m_pDemuxer->GetStreamLength();
   if(len > 0 && tim > 0)
-    m_pInputStream->SetReadRate(len * 1000 / tim);
+    m_pInputStream->SetReadRate(g_advancedSettings.m_readBufferFactor * len * 1000 / tim);
 
   return true;
 }
 
+#ifndef __PLEX__
 void COMXPlayer::OpenDefaultStreams(bool reset)
 {
   // if input stream dictate, we will open later
@@ -735,7 +951,7 @@
     CloseAudioStream(true);
 
   // enable subtitles
-  m_player_video.EnableSubtitle(g_settings.m_currentVideoSettings.m_SubtitleOn);
+  m_omxPlayerVideo.EnableSubtitle(g_settings.m_currentVideoSettings.m_SubtitleOn);
 
   // open subtitle stream
   streams = m_SelectionStreams.Get(STREAM_SUBTITLE, PredicateSubtitlePriority);
@@ -746,34 +962,30 @@
     {
       valid = true;
       if(it->flags & CDemuxStream::FLAG_FORCED)
-        m_player_video.EnableSubtitle(true);
+        m_omxPlayerVideo.EnableSubtitle(true);
     }
   }
   if(!valid)
     CloseSubtitleStream(true);
 
   // open teletext stream
-  /*
   streams = m_SelectionStreams.Get(STREAM_TELETEXT);
   valid   = false;
-  for(SelectionStreams::iterator it = streams.begin(); it != streams.end() && !valid; ++it)
+  for(OMXSelectionStreams::iterator it = streams.begin(); it != streams.end() && !valid; ++it)
   {
     if(OpenTeletextStream(it->id, it->source))
       valid = true;
   }
   if(!valid)
     CloseTeletextStream(true);
-  */
-
-  //m_av_clock.OMXStop();
-  //m_av_clock.OMXReset();
 }
+#endif
 
 bool COMXPlayer::ReadPacket(DemuxPacket*& packet, CDemuxStream*& stream)
 {
 
   // check if we should read from subtitle demuxer
-  if(m_player_subtitle.AcceptsData() &&  m_pSubtitleDemuxer)
+  if(m_dvdPlayerSubtitle.AcceptsData() && m_pSubtitleDemuxer)
   {
     if(m_pSubtitleDemuxer)
       packet = m_pSubtitleDemuxer->Read();
@@ -843,6 +1055,27 @@
       {
         m_SelectionStreams.Clear(STREAM_NONE, STREAM_SOURCE_DEMUX);
         m_SelectionStreams.Update(m_pInputStream, m_pDemuxer);
+
+        /* PLEX */
+        // Make sure the Plex streams are still linked.
+        RelinkPlexStreams();
+
+        if (m_vobsubToDisplay != -1)
+        {
+          int count = m_SelectionStreams.Count(STREAM_SUBTITLE);
+          for (int i = 0; i<count; i++)
+          {
+            OMXSelectionStream& s = m_SelectionStreams.Get(STREAM_SUBTITLE, i);
+            if (s.plexID == m_vobsubToDisplay && OpenSubtitleStream(s.id, s.source))
+            {
+              OpenSubtitleStream(s.id, s.source);
+              break;
+            }
+          }
+
+          m_vobsubToDisplay = -1;
+        }
+        /* END PLEX */
       }
     }
     return true;
@@ -944,16 +1177,36 @@
   bool bOmxWaitVideo = false;
   bool bOmxWaitAudio = false;
   bool bOmxSentEOFs = false;
+  float m_threshold = 0.2f;
 
+#ifndef __PLEX__
   if (!OpenInputStream())
   {
     m_bAbortRequest = true;
     return;
   }
+#else
+  m_EndPlaybackRequest = false;
+
+  try
+  {
+    if (!OpenInputStream())
+    {
+      m_bAbortRequest = true;
+      return;
+    }
+  }
+  catch (CRedirectException* ex)
+  {
+    CApplicationMessenger::Get().RestartWithNewPlayer(0, ex->m_pNewUrl->Get());
+    delete ex;
+    return;
+  }
+#endif
 
   if (CDVDInputStream::IMenus* ptr = dynamic_cast<CDVDInputStream::IMenus*>(m_pInputStream))
   {
-    CLog::Log(LOGNOTICE, "OMXPlayer: playing a file with menu's");
+    CLog::Log(LOGNOTICE, "OMXPlayer: playing a dvd with menu's");
     m_PlayerOptions.starttime = 0;
 
     if(m_PlayerOptions.state.size() > 0)
@@ -970,7 +1223,19 @@
     return;
   }
 
-  m_player_video.EnableFullscreen(true);
+  // allow renderer to switch to fullscreen if requested
+  m_omxPlayerVideo.EnableFullscreen(m_PlayerOptions.fullscreen);
+
+  if(!m_av_clock.OMXInitialize(&m_clock))
+  {
+    m_bAbortRequest = true;
+    return;
+  }
+  if(g_guiSettings.GetBool("videoplayer.adjustrefreshrate"))
+    m_av_clock.HDMIClockSync();
+  m_av_clock.OMXStateIdle();
+  m_av_clock.OMXStop();
+  m_av_clock.OMXPause();
 
   OpenDefaultStreams();
 
@@ -981,7 +1246,9 @@
   if (m_CurrentVideo.id >= 0 && m_CurrentVideo.hint.fpsrate > 0 && m_CurrentVideo.hint.fpsscale > 0)
   {
     fFramesPerSecond = (float)m_CurrentVideo.hint.fpsrate / (float)m_CurrentVideo.hint.fpsscale;
+#ifndef __PLEX__
     m_Edl.ReadEditDecisionLists(m_filename, fFramesPerSecond, m_CurrentVideo.hint.height);
+#endif
   }
 
   /*
@@ -1057,39 +1324,125 @@
   if (!CachePVRStream())
     SetCaching(CACHESTATE_FLUSH);
 
-  // stop thumb jobs
-  CJobManager::GetInstance().Pause(kJobTypeMediaFlags);
+  EDEINTERLACEMODE current_deinterlace = g_settings.m_currentVideoSettings.m_DeinterlaceMode;
 
-  /*
-  if (CJobManager::GetInstance().IsProcessing(kJobTypeMediaFlags) > 0)
+  while (!m_bAbortRequest)
   {
-    if (!WaitForPausedThumbJobs(20000))
+    double now = m_clock.GetAbsoluteClock();
+    if (m_last_check_time == 0.0 || m_last_check_time + DVD_MSEC_TO_TIME(20) <= now)
     {
-      CJobManager::GetInstance().UnPause(kJobTypeMediaFlags);
-      CLog::Log(LOGINFO, "COMXPlayer::Process:thumbgen jobs still running !!!");
-    }
-  }
-  */
+      m_last_check_time = now;
+      m_stamp = m_av_clock.OMXMediaTime();
+      const bool m_Pause = m_playSpeed == DVD_PLAYSPEED_PAUSE;
+      const bool not_accepts_data = (!m_omxPlayerAudio.AcceptsData() && m_CurrentAudio.id >= 0) ||
+          (!m_omxPlayerVideo.AcceptsData() && m_CurrentVideo.id >= 0);
+      /* when the video/audio fifos are low, we pause clock, when high we resume */
+      double audio_pts = floor(m_omxPlayerAudio.GetCurrentPts());
+      double video_pts = floor(m_omxPlayerVideo.GetCurrentPts());
+
+      float audio_fifo = audio_pts / DVD_TIME_BASE - m_stamp * 1e-6;
+      float video_fifo = video_pts / DVD_TIME_BASE - m_stamp * 1e-6;
+      float threshold = 0.1f;
+      bool audio_fifo_low = false, video_fifo_low = false, audio_fifo_high = false, video_fifo_high = false;
+
+      // if deinterlace setting has changed, we should close and open video
+      if (current_deinterlace != g_settings.m_currentVideoSettings.m_DeinterlaceMode)
+      {
+        int iStream = m_CurrentVideo.id, source = m_CurrentVideo.source;
+        CloseVideoStream(false);
+        OpenVideoStream(iStream, source);
+        if (m_State.canseek)
+          m_messenger.Put(new CDVDMsgPlayerSeek(GetTime(), true, true, true, true, true));
+        current_deinterlace = g_settings.m_currentVideoSettings.m_DeinterlaceMode;
+      }
+
+      m_video_fifo = (int)(100.0*(m_omxPlayerVideo.GetDecoderBufferSize()-m_omxPlayerVideo.GetDecoderFreeSpace())/m_omxPlayerVideo.GetDecoderBufferSize());
+      m_audio_fifo = (int)(100.0*audio_fifo/m_omxPlayerAudio.GetCacheTotal());
+
+      #ifdef _DEBUG
+      static unsigned count;
+      if ((count++ & 7) == 0)
+      {
+        char response[80];
+        if (m_omxPlayerVideo.GetDecoderBufferSize() && m_omxPlayerAudio.GetCacheTotal())
+          vc_gencmd(response, sizeof response, "render_bar 4 video_fifo %d %d %d %d",
+              m_video_fifo,
+              (int)(100.0*video_fifo/m_omxPlayerAudio.GetCacheTotal()),
+              0, 100);
+        if (m_omxPlayerAudio.GetCacheTotal())
+          vc_gencmd(response, sizeof response, "render_bar 5 audio_fifo %d %d %d %d",
+              m_audio_fifo,
+              (int)(100.0*m_omxPlayerAudio.GetDelay()/m_omxPlayerAudio.GetCacheTotal()),
+              0, 100);
+        vc_gencmd(response, sizeof response, "render_bar 6 video_queue %d %d %d %d",
+              m_omxPlayerVideo.GetLevel(), 0, 0, 100);
+        vc_gencmd(response, sizeof response, "render_bar 7 audio_queue %d %d %d %d",
+              m_omxPlayerAudio.GetLevel(), 0, 0, 100);
+      }
+      #endif
+      if (audio_pts != DVD_NOPTS_VALUE)
+      {
+        audio_fifo_low = m_HasAudio && audio_fifo < threshold;
+        audio_fifo_high = audio_pts != DVD_NOPTS_VALUE && audio_fifo >= m_threshold;
+      }
+      if (video_pts != DVD_NOPTS_VALUE)
+      {
+        video_fifo_low = m_HasVideo && video_fifo < threshold;
+        video_fifo_high = video_pts != DVD_NOPTS_VALUE && video_fifo >= m_threshold;
+      }
+      if (!m_HasAudio && m_HasVideo)
+        audio_fifo_high = true;
+      if (!m_HasVideo && m_HasAudio)
+        video_fifo_high = true;
+
+      #ifdef _DEBUG
+      CLog::Log(LOGDEBUG, "%s - M:%.6f-%.6f (A:%.6f V:%.6f) PEF:%d%d%d S:%.2f A:%.2f V:%.2f/T:%.2f (A:%d%d V:%d%d) A:%d%% V:%d%% (%.2f,%.2f)", __FUNCTION__,
+        m_stamp*1e-6, m_av_clock.OMXClockAdjustment()*1e-6, audio_pts*1e-6, video_pts*1e-6, m_av_clock.OMXIsPaused(), bOmxSentEOFs, not_accepts_data, m_playSpeed * (1.0f/DVD_PLAYSPEED_NORMAL),
+        audio_pts == DVD_NOPTS_VALUE ? 0.0:audio_fifo, video_pts == DVD_NOPTS_VALUE ? 0.0:video_fifo, m_threshold,
+        audio_fifo_low, audio_fifo_high, video_fifo_low, video_fifo_high,
+        m_omxPlayerAudio.GetLevel(), m_omxPlayerVideo.GetLevel(), m_omxPlayerAudio.GetDelay(), (float)m_omxPlayerAudio.GetCacheTotal());
+      #endif
 
-  while (!m_bAbortRequest)
-  {
-    #ifdef _DEBUG
-    char response[80];
-    static unsigned count;
-    if ((count++ & 15) == 0)
-    {
-      vc_gencmd(response, sizeof response, "render_bar 4 video_fifo %d %d %d %d",
-            m_player_video.GetDecoderBufferSize()-m_player_video.GetDecoderFreeSpace(),
-            0 , 0, m_player_video.GetDecoderBufferSize());
-      vc_gencmd(response, sizeof response, "render_bar 5 audio_fifo %d %d %d %d",
-            (int)(100.0*m_player_audio.GetDelay()), 0, 0, 100*AUDIO_BUFFER_SECONDS);
-      vc_gencmd(response, sizeof response, "render_bar 6 video_queue %d %d %d %d",
-            m_player_video.GetLevel(), 0, 0, 100);
-      vc_gencmd(response, sizeof response, "render_bar 7 audio_queue %d %d %d %d",
-            m_player_audio.GetLevel(), 0, 0, 100);
+      if (TP(m_playSpeed))
+      {
+        if (m_CurrentVideo.started)
+        {
+          if (m_stamp == 0.0 && (!m_stepped || m_playSpeed > 0))
+          {
+            /* trickplay modes progress by stepping */
+            CLog::Log(LOGDEBUG, "COMXPlayer::Process - Seeking step speed:%.2f last:%.2f v:%.2f", (double)m_playSpeed / DVD_PLAYSPEED_NORMAL, m_SpeedState.lastpts*1e-6, video_pts*1e-6);
+            m_av_clock.OMXStep();
+          }
+          else
+          {
+            m_av_clock.OMXMediaTime(0.0);
+            m_last_check_time = 0.0;
+            m_stepped = true;
+          }
+        }
+      }
+      else if(!m_Pause && (bOmxSentEOFs || not_accepts_data || (audio_fifo_high && video_fifo_high)))
+      {
+        if (m_av_clock.OMXIsPaused())
+        {
+          CLog::Log(LOGDEBUG, "Resume %.2f,%.2f (A:%d%d V:%d%d) EOF:%d FULL:%d T:%.2f\n", audio_fifo, video_fifo,
+            audio_fifo_low, audio_fifo_high, video_fifo_low, video_fifo_high, bOmxSentEOFs, not_accepts_data, m_threshold);
+          m_av_clock.OMXStateExecute();
+          m_av_clock.OMXResume();
+        }
+      }
+      else if (m_Pause || audio_fifo_low || video_fifo_low)
+      {
+        if (!m_av_clock.OMXIsPaused() && !TPA(m_playSpeed))
+        {
+          if (!m_Pause)
+            m_threshold = std::min(2.0f*m_threshold, 16.0f);
+          CLog::Log(LOGDEBUG, "Pause %.2f,%.2f (A:%d%d V:%d%d) EOF:%d FULL:%d T:%.2f\n", audio_fifo, video_fifo,
+            audio_fifo_low, audio_fifo_high, video_fifo_low, video_fifo_high, bOmxSentEOFs, not_accepts_data, m_threshold);
+          m_av_clock.OMXPause();
+        }
+      }
     }
-    #endif
-    // handle messages send to this thread, like seek or demuxer reset requests
     HandleMessages();
 
     if(m_bAbortRequest)
@@ -1141,9 +1494,9 @@
     UpdateApplication(1000);
 
     // OMX emergency exit
-    if(HasAudio() && m_player_audio.BadState())
+    if(HasAudio() && m_omxPlayerAudio.BadState())
     {
-      CLog::Log(LOGERROR, "%s - Closing stream due to m_player_audio.BadState()", __FUNCTION__);
+      CLog::Log(LOGERROR, "%s - Closing stream due to m_omxPlayerAudio.BadState()", __FUNCTION__);
       m_bAbortRequest = true;
       break;
     }
@@ -1152,16 +1505,16 @@
       continue;
 
     // if the queues are full, no need to read more
-    if ((!m_player_audio.AcceptsData() && m_CurrentAudio.id >= 0)
-    ||  (!m_player_video.AcceptsData() && m_CurrentVideo.id >= 0))
+    if ((!m_omxPlayerAudio.AcceptsData() && m_CurrentAudio.id >= 0) ||
+        (!m_omxPlayerVideo.AcceptsData() && m_CurrentVideo.id >= 0))
     {
       Sleep(10);
       continue;
     }
 
     // always yield to players if they have data levels > 50 percent
-    if((m_player_audio.GetLevel() > 50 || m_CurrentAudio.id < 0)
-    && (m_player_video.GetLevel() > 50 || m_CurrentVideo.id < 0))
+    if((m_omxPlayerAudio.GetLevel() > 50 || m_CurrentAudio.id < 0)
+    && (m_omxPlayerVideo.GetLevel() > 50 || m_CurrentVideo.id < 0))
       Sleep(0);
 
     DemuxPacket* pPacket = NULL;
@@ -1173,7 +1526,13 @@
       CDVDDemuxUtils::FreeDemuxPacket(pPacket);
       continue;
     }
-
+    if (pPacket)
+    {
+      // reset eos state when we get a packet (e.g. for case of seek after eos)
+      bOmxWaitVideo = false;
+      bOmxWaitAudio = false;
+      bOmxSentEOFs = false;
+    }
     if (!pPacket)
     {
       // when paused, demuxer could be be returning empty
@@ -1219,33 +1578,28 @@
         Sleep(100);
         continue;
       }
-      else if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER))
-      {
-        CDVDInputStreamPVRManager* pStream = static_cast<CDVDInputStreamPVRManager*>(m_pInputStream);
-        if (pStream->IsEOF())
-          break;
-
-        Sleep(100);
-        continue;
-      }
 
       // make sure we tell all players to finish it's data
       if (!bOmxSentEOFs)
       {
         if(m_CurrentAudio.inited)
         {
-          m_player_audio.SendMessage   (new CDVDMsg(CDVDMsg::GENERAL_EOF));
+          m_omxPlayerAudio.SendMessage   (new CDVDMsg(CDVDMsg::GENERAL_EOF));
           bOmxWaitAudio = true;
         }
         if(m_CurrentVideo.inited)
         {
-          m_player_video.SendMessage   (new CDVDMsg(CDVDMsg::GENERAL_EOF));
+          m_omxPlayerVideo.SendMessage   (new CDVDMsg(CDVDMsg::GENERAL_EOF));
           bOmxWaitVideo = true;
         }
         if(m_CurrentSubtitle.inited)
-          m_player_subtitle.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_EOF));
+          m_dvdPlayerSubtitle.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_EOF));
         if(m_CurrentTeletext.inited)
-          m_player_teletext.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_EOF));
+          m_dvdPlayerTeletext.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_EOF));
+        m_CurrentAudio.inited    = false;
+        m_CurrentVideo.inited    = false;
+        m_CurrentSubtitle.inited = false;
+        m_CurrentTeletext.inited = false;
         bOmxSentEOFs = true;
       }
 
@@ -1253,20 +1607,20 @@
       SetCaching(CACHESTATE_DONE);
 
       // while players are still playing, keep going to allow seekbacks
-      if(m_player_video.HasData()
-      || m_player_audio.HasData())
+      if(m_omxPlayerVideo.HasData()
+      || m_omxPlayerAudio.HasData())
       {
         Sleep(100);
         continue;
       }
 
       // wait for omx components to finish
-      if(bOmxWaitVideo && !m_player_video.IsEOS())
+      if(bOmxWaitVideo && !m_omxPlayerVideo.IsEOS())
       {
         Sleep(100);
         continue;
       }
-      if(bOmxWaitAudio && !m_player_audio.IsEOS())
+      if(bOmxWaitAudio && !m_omxPlayerAudio.IsEOS())
       {
         Sleep(100);
         continue;
@@ -1275,10 +1629,6 @@
       if (!m_pInputStream->IsEOF())
         CLog::Log(LOGINFO, "%s - eof reading from demuxer", __FUNCTION__);
 
-      m_CurrentAudio.inited    = false;
-      m_CurrentVideo.inited    = false;
-      m_CurrentSubtitle.inited = false;
-      m_CurrentTeletext.inited = false;
       m_CurrentAudio.started    = false;
       m_CurrentVideo.started    = false;
       m_CurrentSubtitle.started = false;
@@ -1287,10 +1637,13 @@
       break;
     }
 
+    // it's a valid data packet, reset error counter
+    m_errorCount = 0;
+
     // check so that none of our streams has become invalid
-    if (!IsValidStream(m_CurrentAudio)    && m_player_audio.IsStalled())    CloseAudioStream(true);
-    if (!IsValidStream(m_CurrentVideo)    && m_player_video.IsStalled())    CloseVideoStream(true);
-    if (!IsValidStream(m_CurrentSubtitle) && m_player_subtitle.IsStalled()) CloseSubtitleStream(true);
+    if (!IsValidStream(m_CurrentAudio)    && m_omxPlayerAudio.IsStalled())    CloseAudioStream(true);
+    if (!IsValidStream(m_CurrentVideo)    && m_omxPlayerVideo.IsStalled())    CloseVideoStream(true);
+    if (!IsValidStream(m_CurrentSubtitle) && m_dvdPlayerSubtitle.IsStalled()) CloseSubtitleStream(true);
     if (!IsValidStream(m_CurrentTeletext))                                  CloseTeletextStream(true);
 
     // see if we can find something better to play
@@ -1299,12 +1652,6 @@
     if (IsBetterStream(m_CurrentSubtitle, pStream)) OpenSubtitleStream(pStream->iId, pStream->source);
     if (IsBetterStream(m_CurrentTeletext, pStream)) OpenTeletextStream(pStream->iId, pStream->source);
 
-    if(m_change_volume && m_CurrentAudio.started)
-    {
-      m_player_audio.SetCurrentVolume(m_current_mute ? VOLUME_MINIMUM : m_current_volume);
-      m_change_volume = false;
-    }
-
     // process the packet
     ProcessPacket(pStream, pPacket);
 
@@ -1312,8 +1659,15 @@
     CheckAutoSceneSkip();
   }
 
-  // let thumbgen jobs resume.
-  CJobManager::GetInstance().UnPause(kJobTypeMediaFlags);
+  /* PLEX */
+  // We're done, if we transcoded we need to stop that now
+  if (m_item.GetProperty("plexDidTranscode").asBoolean() && g_plexApplication.serverManager)
+  {
+    CPlexServerPtr server = g_plexApplication.serverManager->FindByUUID(m_item.GetProperty("plexserver").asString());
+    if (server)
+      g_plexApplication.mediaServerClient->StopTranscodeSession(server);
+  }
+  /* END PLEX */
 }
 
 bool COMXPlayer::CheckDelayedChannelEntry(void)
@@ -1397,17 +1751,17 @@
   else if (m_Edl.InCut(DVD_TIME_TO_MSEC(m_CurrentAudio.dts + m_offset_pts), &cut) && cut.action == CEdl::MUTE // Inside EDL mute
   &&      !m_EdlAutoSkipMarkers.mute) // Mute not already triggered
   {
-    m_player_audio.SendMessage(new CDVDMsgBool(CDVDMsg::AUDIO_SILENCE, true));
+    m_omxPlayerAudio.SendMessage(new CDVDMsgBool(CDVDMsg::AUDIO_SILENCE, true));
     m_EdlAutoSkipMarkers.mute = true;
   }
   else if (!m_Edl.InCut(DVD_TIME_TO_MSEC(m_CurrentAudio.dts + m_offset_pts), &cut) // Outside of any EDL
   &&        m_EdlAutoSkipMarkers.mute) // But the mute hasn't been removed yet
   {
-    m_player_audio.SendMessage(new CDVDMsgBool(CDVDMsg::AUDIO_SILENCE, false));
+    m_omxPlayerAudio.SendMessage(new CDVDMsgBool(CDVDMsg::AUDIO_SILENCE, false));
     m_EdlAutoSkipMarkers.mute = false;
   }
 
-  m_player_audio.SendMessage(new CDVDMsgDemuxerPacket(pPacket, drop));
+  m_omxPlayerAudio.SendMessage(new CDVDMsgDemuxerPacket(pPacket, drop));
 }
 
 void COMXPlayer::ProcessVideoData(CDemuxStream* pStream, DemuxPacket* pPacket)
@@ -1440,7 +1794,7 @@
   if (CheckSceneSkip(m_CurrentVideo))
     drop = true;
 
-  m_player_video.SendMessage(new CDVDMsgDemuxerPacket(pPacket, drop));
+  m_omxPlayerVideo.SendMessage(new CDVDMsgDemuxerPacket(pPacket, drop));
 }
 
 void COMXPlayer::ProcessSubData(CDemuxStream* pStream, DemuxPacket* pPacket)
@@ -1466,10 +1820,10 @@
   if (CheckSceneSkip(m_CurrentSubtitle))
     drop = true;
 
-  m_player_subtitle.SendMessage(new CDVDMsgDemuxerPacket(pPacket, drop));
+  m_dvdPlayerSubtitle.SendMessage(new CDVDMsgDemuxerPacket(pPacket, drop));
 
   if(m_pInputStream && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD))
-    m_player_subtitle.UpdateOverlayInfo((CDVDInputStreamNavigator*)m_pInputStream, LIBDVDNAV_BUTTON_NORMAL);
+    m_dvdPlayerSubtitle.UpdateOverlayInfo((CDVDInputStreamNavigator*)m_pInputStream, LIBDVDNAV_BUTTON_NORMAL);
 }
 
 void COMXPlayer::ProcessTeletextData(CDemuxStream* pStream, DemuxPacket* pPacket)
@@ -1493,7 +1847,7 @@
   if (CheckSceneSkip(m_CurrentTeletext))
     drop = true;
 
-  m_player_teletext.SendMessage(new CDVDMsgDemuxerPacket(pPacket, drop));
+  m_dvdPlayerTeletext.SendMessage(new CDVDMsgDemuxerPacket(pPacket, drop));
 }
 
 bool COMXPlayer::GetCachingTimes(double& level, double& delay, double& offset)
@@ -1533,9 +1887,11 @@
 
   delay = cache_left - play_left;
 
+#ifndef __PLEX__
   if (full && (currate < maxrate) )
     level = -1.0;                          /* buffer is full & our read rate is too low  */
   else
+#endif
     level = (cached + queued) / (cache_need + queued);
 
   return true;
@@ -1554,14 +1910,17 @@
     if(GetCachingTimes(level, delay, offset))
     {
       if(level  < 0.0)
+      {
+        CGUIDialogKaiToast::QueueNotification(g_localizeStrings.Get(21454), g_localizeStrings.Get(21455));
         caching = CACHESTATE_INIT;
+      }
       if(level >= 1.0)
         caching = CACHESTATE_INIT;
     }
     else
     {
-      if ((!m_player_audio.AcceptsData() && m_CurrentAudio.id >= 0)
-      ||  (!m_player_video.AcceptsData() && m_CurrentVideo.id >= 0))
+      if ((!m_omxPlayerAudio.AcceptsData() && m_CurrentAudio.id >= 0)
+      ||  (!m_omxPlayerVideo.AcceptsData() && m_CurrentVideo.id >= 0))
         caching = CACHESTATE_INIT;
     }
   }
@@ -1576,8 +1935,8 @@
     // handle situation that we get no data on one stream
     if(m_CurrentAudio.id >= 0 && m_CurrentVideo.id >= 0)
     {
-      if ((!m_player_audio.AcceptsData() && !m_CurrentVideo.started)
-      ||  (!m_player_video.AcceptsData() && !m_CurrentAudio.started))
+      if ((!m_omxPlayerAudio.AcceptsData() && !m_CurrentVideo.started)
+      ||  (!m_omxPlayerVideo.AcceptsData() && !m_CurrentAudio.started))
       {
         caching = CACHESTATE_DONE;
       }
@@ -1588,10 +1947,19 @@
   {
     bool bGotAudio(m_pDemuxer->GetNrOfAudioStreams() > 0);
     bool bGotVideo(m_pDemuxer->GetNrOfVideoStreams() > 0);
-    bool bAudioLevelOk(m_player_audio.GetLevel() > g_advancedSettings.m_iPVRMinAudioCacheLevel);
-    bool bVideoLevelOk(m_player_video.GetLevel() > g_advancedSettings.m_iPVRMinVideoCacheLevel);
-    bool bAudioFull(!m_player_audio.AcceptsData());
-    bool bVideoFull(!m_player_video.AcceptsData());
+
+    /* PLEX */
+    #ifndef TARGET_RASPBERRY_PI
+    bool bAudioLevelOk(m_omxPlayerAudio.GetLevel() > g_advancedSettings.m_iPVRMinAudioCacheLevel);
+    bool bVideoLevelOk(m_omxPlayerVideo.GetLevel() > g_advancedSettings.m_iPVRMinVideoCacheLevel);
+    #else
+    bool bAudioLevelOk((m_omxPlayerAudio.GetCacheTime() > 0.9 * AUDIO_BUFFER_SECONDS) && (m_omxPlayerAudio.GetLevel() > 80));
+    bool bVideoLevelOk((m_omxPlayerVideo.GetCacheLevel() > 90) && (m_omxPlayerVideo.GetLevel() > 80));
+    #endif
+    /* END PLEX */
+
+    bool bAudioFull(!m_omxPlayerAudio.AcceptsData());
+    bool bVideoFull(!m_omxPlayerVideo.AcceptsData());
 
     if (/* if all streams got at least g_advancedSettings.m_iPVRMinCacheLevel in their buffers, we're done */
         ((bGotVideo || bGotAudio) && (!bGotAudio || bAudioLevelOk) && (!bGotVideo || bVideoLevelOk)) ||
@@ -1599,8 +1967,8 @@
         (bAudioFull || bVideoFull))
     {
       CLog::Log(LOGDEBUG, "set caching from pvr to done. audio (%d) = %d. video (%d) = %d",
-          bGotAudio, m_player_audio.GetLevel(),
-          bGotVideo, m_player_video.GetLevel());
+          bGotAudio, m_omxPlayerAudio.GetLevel(),
+          bGotVideo, m_omxPlayerVideo.GetLevel());
 
       CFileItem currentItem(g_application.CurrentFileItem());
       if (currentItem.HasPVRChannelInfoTag())
@@ -1612,17 +1980,17 @@
     {
       /* ensure that automatically started players are stopped while caching */
       if (m_CurrentAudio.started)
-        m_player_audio.SetSpeed(DVD_PLAYSPEED_PAUSE);
+        m_omxPlayerAudio.SetSpeed(DVD_PLAYSPEED_PAUSE);
       if (m_CurrentVideo.started)
-        m_player_video.SetSpeed(DVD_PLAYSPEED_PAUSE);
+        m_omxPlayerVideo.SetSpeed(DVD_PLAYSPEED_PAUSE);
     }
   }
 
   if(caching == CACHESTATE_PLAY)
   {
     // if all enabled streams have started playing we are done
-    if((m_CurrentVideo.id < 0 || !m_player_video.IsStalled())
-    && (m_CurrentAudio.id < 0 || !m_player_audio.IsStalled()))
+    if((m_CurrentVideo.id < 0 || !m_omxPlayerVideo.IsStalled())
+    && (m_CurrentAudio.id < 0 || !m_omxPlayerAudio.IsStalled()))
       caching = CACHESTATE_DONE;
   }
 
@@ -1640,10 +2008,11 @@
     }
     else if (m_CurrentVideo.id >= 0
           &&  m_CurrentVideo.inited == true
-          &&  m_SpeedState.lastpts  != m_player_video.GetCurrentPTS()
-          &&  m_SpeedState.lasttime != GetTime())
+          &&  m_SpeedState.lastpts  != m_omxPlayerVideo.GetCurrentPts()
+          &&  m_SpeedState.lasttime != GetTime()
+          &&  m_stepped)
     {
-      m_SpeedState.lastpts  = m_player_video.GetCurrentPTS();
+      m_SpeedState.lastpts  = m_omxPlayerVideo.GetCurrentPts();
       m_SpeedState.lasttime = GetTime();
       // check how much off clock video is when ff/rw:ing
       // a problem here is that seeking isn't very accurate
@@ -1656,13 +2025,13 @@
       // when seeking, give the player a headstart to make sure
       // the time it takes to seek doesn't make a difference.
       double error;
-      error  = m_av_clock.GetClock() - m_SpeedState.lastpts;
+      error  = m_clock.GetClock() - m_SpeedState.lastpts;
       error *= m_playSpeed / abs(m_playSpeed);
 
       if(error > DVD_MSEC_TO_TIME(1000))
       {
         CLog::Log(LOGDEBUG, "COMXPlayer::Process - Seeking to catch up");
-        int64_t iTime = (int64_t)DVD_TIME_TO_MSEC(m_av_clock.GetClock() + m_State.time_offset + 500000.0 * m_playSpeed / DVD_PLAYSPEED_NORMAL);
+        int64_t iTime = (int64_t)DVD_TIME_TO_MSEC(m_clock.GetClock() + m_State.time_offset + 500000.0 * m_playSpeed / DVD_PLAYSPEED_NORMAL);
         m_messenger.Put(new CDVDMsgPlayerSeek(iTime, (GetPlaySpeed() < 0), true, false, false, true));
       }
     }
@@ -1678,13 +2047,13 @@
   if(IsInMenu())
     return false;
 
-  if((current.type == STREAM_AUDIO && m_player_audio.IsStalled())
-  || (current.type == STREAM_VIDEO && m_player_video.IsStalled()))
+  if((current.type == STREAM_AUDIO && m_omxPlayerAudio.IsStalled())
+  || (current.type == STREAM_VIDEO && m_omxPlayerVideo.IsStalled()))
   {
     if (CachePVRStream())
     {
-      if ((current.type == STREAM_AUDIO && current.started && m_player_audio.GetLevel() == 0) ||
-         (current.type == STREAM_VIDEO && current.started && m_player_video.GetLevel() == 0))
+      if ((current.type == STREAM_AUDIO && current.started && m_omxPlayerAudio.GetLevel() == 0) ||
+         (current.type == STREAM_VIDEO && current.started && m_omxPlayerVideo.GetLevel() == 0))
       {
         CLog::Log(LOGDEBUG, "%s stream stalled. start buffering", current.type == STREAM_AUDIO ? "audio" : "video");
         SetCaching(CACHESTATE_PVR);
@@ -1693,8 +2062,8 @@
     }
 
     // don't start caching if it's only a single stream that has run dry
-    if(m_player_audio.GetLevel() > 50
-    || m_player_video.GetLevel() > 50)
+    if(m_omxPlayerAudio.GetLevel() > 50
+    || m_omxPlayerVideo.GetLevel() > 50)
       return false;
 
     if(current.inited)
@@ -1779,13 +2148,14 @@
     }
 
     SendPlayerMessage(new CDVDMsgGeneralResync(current.dts, setclock), source);
+    if(setclock)
+      m_clock.Discontinuity(current.dts);
   }
   return false;
 }
 
 void COMXPlayer::UpdateCorrection(DemuxPacket* pkt, double correction)
 {
-  //CLog::Log(LOGINFO,"%s: %d dts:%.0f pts:%.0f s:%d c:%.0f (%d,%d)", __func__, (int)pkt->iStreamId, pkt->dts, pkt->pts, pkt->iSize, correction, pkt->dts==DVD_NOPTS_VALUE, pkt->pts==DVD_NOPTS_VALUE);
   if(pkt->dts != DVD_NOPTS_VALUE) pkt->dts -= correction;
   if(pkt->pts != DVD_NOPTS_VALUE) pkt->pts -= correction;
 }
@@ -1808,7 +2178,7 @@
   current.dts = dts;
 }
 
-void COMXPlayer::UpdateLimits(double& minimum, double& maximum, double dts)
+static void UpdateLimits(double& minimum, double& maximum, double dts)
 {
   if(dts == DVD_NOPTS_VALUE)
     return;
@@ -1974,15 +2344,15 @@
 
   CDVDMsgGeneralSynchronize* message = new CDVDMsgGeneralSynchronize(timeout, sources);
   if (m_CurrentAudio.id >= 0)
-    m_player_audio.SendMessage(message->Acquire());
+    m_omxPlayerAudio.SendMessage(message->Acquire());
 
   if (m_CurrentVideo.id >= 0)
-    m_player_video.SendMessage(message->Acquire());
+    m_omxPlayerVideo.SendMessage(message->Acquire());
 /* TODO - we have to rewrite the sync class, to not require
           all other players waiting for subtitle, should only
           be the oposite way
   if (m_CurrentSubtitle.id >= 0)
-    m_player_subtitle.SendMessage(message->Acquire()); 
+    m_dvdPlayerSubtitle.SendMessage(message->Acquire());
 */
   message->Release();
 }
@@ -1990,13 +2360,13 @@
 void COMXPlayer::SendPlayerMessage(CDVDMsg* pMsg, unsigned int target)
 {
   if(target == DVDPLAYER_AUDIO)
-    m_player_audio.SendMessage(pMsg);
+    m_omxPlayerAudio.SendMessage(pMsg);
   if(target == DVDPLAYER_VIDEO)
-    m_player_video.SendMessage(pMsg);
+    m_omxPlayerVideo.SendMessage(pMsg);
   if(target == DVDPLAYER_SUBTITLE)
-    m_player_subtitle.SendMessage(pMsg);
+    m_dvdPlayerSubtitle.SendMessage(pMsg);
   if(target == DVDPLAYER_TELETEXT)
-    m_player_teletext.SendMessage(pMsg);
+    m_dvdPlayerTeletext.SendMessage(pMsg);
 }
 
 void COMXPlayer::OnExit()
@@ -2059,7 +2429,7 @@
     // clean up all selection streams
     m_SelectionStreams.Clear(STREAM_NONE, STREAM_SOURCE_NONE);
 
-    m_messenger.Flush();
+    m_messenger.End();
 
     m_av_clock.OMXDeinitialize();
 
@@ -2075,7 +2445,7 @@
   // if we didn't stop playing, advance to the next item in xbmc's playlist
   if(m_PlayerOptions.identify == false)
   {
-    if (m_bAbortRequest)
+    if (m_bAbortRequest && !m_EndPlaybackRequest)
       m_callback.OnPlayBackStopped();
     else
       m_callback.OnPlayBackEnded();
@@ -2109,9 +2479,9 @@
         if(!msg.GetTrickPlay())
         {
           g_infoManager.SetDisplayAfterSeek(100000);
-          if(msg.GetFlush())
-            SetCaching(CACHESTATE_FLUSH);
         }
+        if(msg.GetFlush())
+          SetCaching(CACHESTATE_FLUSH);
 
         double start = DVD_NOPTS_VALUE;
 
@@ -2131,6 +2501,12 @@
               CLog::Log(LOGDEBUG, "failed to seek subtitle demuxer: %d, success", time);
           }
           FlushBuffers(!msg.GetFlush(), start, msg.GetAccurate());
+          // mark mediatime as invalid
+          if(TP(m_playSpeed))
+          {
+            m_av_clock.OMXMediaTime(0.0);
+            m_last_check_time = 0.0;
+          }
         }
         else
           CLog::Log(LOGWARNING, "error while seeking");
@@ -2225,7 +2601,7 @@
       {
         CDVDMsgBool* pValue = (CDVDMsgBool*)pMsg;
 
-        m_player_video.EnableSubtitle(pValue->m_value);
+        m_omxPlayerVideo.EnableSubtitle(pValue->m_value);
 
         if (m_pInputStream && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD))
           static_cast<CDVDInputStreamNavigator*>(m_pInputStream)->EnableSubtitleStream(pValue->m_value);
@@ -2267,22 +2643,24 @@
         if(m_State.timestamp > 0)
         {
           double offset;
-          offset  = m_av_clock.GetAbsoluteClock() - m_State.timestamp;
+          offset  = m_clock.GetAbsoluteClock() - m_State.timestamp;
           offset *= m_playSpeed / DVD_PLAYSPEED_NORMAL;
           if(offset >  1000) offset =  1000;
           if(offset < -1000) offset = -1000;
           m_State.time     += DVD_TIME_TO_MSEC(offset);
-          m_State.timestamp =  m_av_clock.GetAbsoluteClock();
+          m_State.timestamp =  m_clock.GetAbsoluteClock();
         }
 
         if (speed != DVD_PLAYSPEED_PAUSE && m_playSpeed != DVD_PLAYSPEED_PAUSE && speed != m_playSpeed)
           m_callback.OnPlayBackSpeedChanged(speed / DVD_PLAYSPEED_NORMAL);
 
+#ifndef __PLEX__
         if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER) && speed != m_playSpeed)
         {
           CDVDInputStreamPVRManager* pvrinputstream = static_cast<CDVDInputStreamPVRManager*>(m_pInputStream);
           pvrinputstream->Pause( speed == 0 );
         }
+#endif
 
         // if playspeed is different then DVD_PLAYSPEED_NORMAL or DVD_PLAYSPEED_PAUSE
         // audioplayer, stops outputing audio to audiorender, but still tries to
@@ -2290,12 +2668,21 @@
         // videoplayer just plays faster after the clock speed has been increased
         // 1. disable audio
         // 2. skip frames and adjust their pts or the clock
+
+        // when switching from trickplay to normal, we may not have a full set of reference frames
+        // in decoder and we may get corrupt frames out. Seeking to current time will avoid this.
+        if ( TP(speed) || TP(m_playSpeed) ||
+           ( (speed == DVD_PLAYSPEED_PAUSE || speed == DVD_PLAYSPEED_NORMAL) &&
+             (m_playSpeed != DVD_PLAYSPEED_PAUSE && m_playSpeed != DVD_PLAYSPEED_NORMAL) ) )
+          m_messenger.Put(new CDVDMsgPlayerSeek(GetTime(), (speed < 0), true, false, false, true));
+
         m_playSpeed = speed;
         m_caching = CACHESTATE_DONE;
-        m_av_clock.SetSpeed(speed);
+        m_clock.SetSpeed(speed);
         m_av_clock.OMXSetSpeed(speed);
-        m_player_audio.SetSpeed(speed);
-        m_player_video.SetSpeed(speed);
+        m_av_clock.OMXPause();
+        m_omxPlayerAudio.SetSpeed(speed);
+        m_omxPlayerVideo.SetSpeed(speed);
 
         // TODO - we really shouldn't pause demuxer
         //        until our buffers are somewhat filled
@@ -2380,7 +2767,16 @@
           m_CurrentAudio.started = true;
         if(player == DVDPLAYER_VIDEO)
           m_CurrentVideo.started = true;
-        CLog::Log(LOGDEBUG, "COMXPlayer::HandleMessages - player started %d", player);
+
+        if ((player == DVDPLAYER_AUDIO || player == DVDPLAYER_VIDEO) &&
+           (TPA(m_playSpeed) || !m_HasAudio || m_CurrentAudio.started) &&
+           (!m_HasVideo || m_CurrentVideo.started))
+        {
+          CLog::Log(LOGDEBUG, "COMXPlayer::HandleMessages - player started RESET");
+          m_av_clock.OMXReset(m_HasVideo, m_playSpeed != DVD_PLAYSPEED_NORMAL && m_playSpeed != DVD_PLAYSPEED_PAUSE ? false:m_HasAudio);
+        }
+
+        CLog::Log(LOGDEBUG, "COMXPlayer::HandleMessages - player started %d (tpa:%d,a:%d,v:%d)", player, TPA(m_playSpeed), m_CurrentAudio.started, m_CurrentVideo.started);
       }
     }
     catch (...)
@@ -2412,12 +2808,12 @@
   || state == CACHESTATE_INIT
   || state == CACHESTATE_PVR)
   {
-    m_av_clock.SetSpeed(DVD_PLAYSPEED_PAUSE);
-    m_av_clock.OMXSetSpeed(DVD_PLAYSPEED_PAUSE);
-    m_player_audio.SetSpeed(DVD_PLAYSPEED_PAUSE);
-    m_player_audio.SendMessage(new CDVDMsg(CDVDMsg::PLAYER_STARTED), 1);
-    m_player_video.SetSpeed(DVD_PLAYSPEED_PAUSE);
-    m_player_video.SendMessage(new CDVDMsg(CDVDMsg::PLAYER_STARTED), 1);
+    m_clock.SetSpeed(DVD_PLAYSPEED_PAUSE);
+    m_av_clock.OMXPause();
+    m_omxPlayerAudio.SetSpeed(DVD_PLAYSPEED_PAUSE);
+    m_omxPlayerAudio.SendMessage(new CDVDMsg(CDVDMsg::PLAYER_STARTED), 1);
+    m_omxPlayerVideo.SetSpeed(DVD_PLAYSPEED_PAUSE);
+    m_omxPlayerVideo.SendMessage(new CDVDMsg(CDVDMsg::PLAYER_STARTED), 1);
 
     if (state == CACHESTATE_PVR)
       m_pInputStream->ResetScanTimeout((unsigned int) g_guiSettings.GetInt("pvrplayback.scantime") * 1000);
@@ -2426,21 +2822,19 @@
   if(state == CACHESTATE_PLAY
   ||(state == CACHESTATE_DONE && m_caching != CACHESTATE_PLAY))
   {
-    m_av_clock.SetSpeed(m_playSpeed);
-    m_av_clock.OMXSetSpeed(m_playSpeed);
-    m_player_audio.SetSpeed(m_playSpeed);
-    m_player_video.SetSpeed(m_playSpeed);
+    m_clock.SetSpeed(m_playSpeed);
+    m_omxPlayerAudio.SetSpeed(m_playSpeed);
+    m_omxPlayerVideo.SetSpeed(m_playSpeed);
+    m_pInputStream->ResetScanTimeout(0);
   }
   m_caching = state;
 }
 
 void COMXPlayer::SetPlaySpeed(int speed)
 {
-  /* only pause and normal playspeeds are allowed */
-  if(speed < 0 || speed > DVD_PLAYSPEED_NORMAL)
-    return;
-
   m_messenger.Put(new CDVDMsgInt(CDVDMsg::PLAYER_SETSPEED, speed));
+  m_omxPlayerAudio.SetSpeed(speed);
+  m_omxPlayerVideo.SetSpeed(speed);
   SynchronizeDemuxer(100);
 }
 
@@ -2493,7 +2887,7 @@
 
 bool COMXPlayer::IsPassthrough() const
 {
-  return m_player_audio.Passthrough();
+  return m_omxPlayerAudio.Passthrough();
 }
 
 bool COMXPlayer::CanSeek()
@@ -2504,6 +2898,13 @@
 
 void COMXPlayer::Seek(bool bPlus, bool bLargeStep)
 {
+  // Single step
+  if( m_playSpeed == DVD_PLAYSPEED_PAUSE && bPlus && !bLargeStep)
+  {
+    m_av_clock.OMXStep();
+    return;
+  }
+
   if (!m_State.canseek)
     return;
 
@@ -2521,7 +2922,29 @@
     }
   }
 
+  /* PLEX */
   int64_t seek;
+#ifdef __PLEX__
+  if (bLargeStep)
+    seek = bPlus ? g_advancedSettings.m_videoTimeSeekForwardBig : g_advancedSettings.m_videoTimeSeekBackwardBig;
+  else
+    seek = bPlus ? g_advancedSettings.m_videoTimeSeekForward : g_advancedSettings.m_videoTimeSeekBackward;
+  seek *= 1000;
+
+  // if we are over movie length, then just move one sec before the end
+  // that's the maximum seek offset DVDPlayer will take into account.
+  if (seek + GetTime() > GetTotalTimeInMsec())
+  {
+    m_EndPlaybackRequest = true;
+    //seek = GetTotalTimeInMsec() - 1000;
+    CloseFile();
+    //return;
+  }
+  else
+  {
+    seek += GetTime();
+  }
+#else
   if (g_advancedSettings.m_videoUseTimeSeeking && GetTotalTime() > 2000*g_advancedSettings.m_videoTimeSeekForwardBig)
   {
     if (bLargeStep)
@@ -2540,7 +2963,8 @@
       percent = bPlus ? g_advancedSettings.m_videoPercentSeekForward : g_advancedSettings.m_videoPercentSeekBackward;
     seek = (int64_t)(GetTotalTimeInMsec()*(GetPercentage()+percent)/100);
   }
-
+#endif
+  /* END PLEX */
   bool restore = true;
   if (m_Edl.HasCut())
   {
@@ -2548,7 +2972,7 @@
      * Alter the standard seek position based on whether any commercial breaks have been
      * automatically skipped.
      */
-    const int clock = DVD_TIME_TO_MSEC(m_av_clock.GetClock());
+    const int clock = DVD_TIME_TO_MSEC(m_clock.GetClock());
     /*
      * If a large backwards seek occurs within 10 seconds of the end of the last automated
      * commercial skip, then seek back to the start of the commercial break under the assumption
@@ -2636,7 +3060,7 @@
   { CSingleLock lock(m_StateSection);
     strAudioInfo.Format("D(%s)", m_State.demux_audio.c_str());
   }
-  strAudioInfo.AppendFormat(" P(%s)", m_player_audio.GetPlayerInfo().c_str());
+  strAudioInfo.AppendFormat(" P(%s)", m_omxPlayerAudio.GetPlayerInfo().c_str());
 }
 
 void COMXPlayer::GetVideoInfo(CStdString &strVideoInfo)
@@ -2644,17 +3068,15 @@
   { CSingleLock lock(m_StateSection);
     strVideoInfo.Format("D(%s)", m_State.demux_video.c_str());
   }
-  strVideoInfo.AppendFormat(" P(%s)", m_player_video.GetPlayerInfo().c_str());
+  strVideoInfo.AppendFormat(" P(%s)", m_omxPlayerVideo.GetPlayerInfo().c_str());
 }
 
 void COMXPlayer::GetGeneralInfo(CStdString& strGeneralInfo)
 {
   if (!m_bStop)
   {
-    double dDelay = m_player_video.GetDelay() / DVD_TIME_BASE - g_renderManager.GetDisplayLatency();
-
-    double apts = m_player_audio.GetCurrentPTS();
-    double vpts = m_player_video.GetCurrentPTS();
+    double apts = m_omxPlayerAudio.GetCurrentPts();
+    double vpts = m_omxPlayerVideo.GetCurrentPts();
     double dDiff = 0;
 
     if( apts != DVD_NOPTS_VALUE && vpts != DVD_NOPTS_VALUE )
@@ -2674,28 +3096,29 @@
         strBuf.AppendFormat(" %d sec", DVD_TIME_TO_SEC(m_State.cache_delay));
     }
 
-    strGeneralInfo.Format("C( ad:% 6.3f, a/v:% 6.3f%s, dcpu:%2i%% acpu:%2i%% vcpu:%2i%%%s, omx vb:%8d ad:% 6.3f )"
-                         , dDelay
+    strGeneralInfo.Format("C( ad:% 6.3f a/v:% 6.3f%s, dcpu:%2i%% acpu:%2i%% vcpu:%2i%%%s af:%d%% vf:%d%% amp:% 5.2f )"
+                         , m_omxPlayerAudio.GetDelay()
                          , dDiff
                          , strEDL.c_str()
                          , (int)(CThread::GetRelativeUsage()*100)
-                         , (int)(m_player_audio.GetRelativeUsage()*100)
-                         , (int)(m_player_video.GetRelativeUsage()*100)
+                         , (int)(m_omxPlayerAudio.GetRelativeUsage()*100)
+                         , (int)(m_omxPlayerVideo.GetRelativeUsage()*100)
                          , strBuf.c_str()
-                         , m_player_video.GetFreeSpace()
-                         , m_player_audio.GetDelay());
+                         , m_audio_fifo
+                         , m_video_fifo
+                         , m_omxPlayerAudio.GetDynamicRangeAmplification());
 
   }
 }
 
-void COMXPlayer::SeekPercentage(float fPercent)
+void COMXPlayer::SeekPercentage(float iPercent)
 {
   int64_t iTotalTime = GetTotalTimeInMsec();
 
   if (!iTotalTime)
     return;
 
-  SeekTime((int64_t)(iTotalTime * fPercent / 100));
+  SeekTime((int64_t)(iTotalTime * iPercent / 100));
 }
 
 float COMXPlayer::GetPercentage()
@@ -2716,22 +3139,28 @@
 
 void COMXPlayer::SetAVDelay(float fValue)
 {
-  m_player_video.SetDelay(fValue * DVD_TIME_BASE);
+#ifndef __PLEX__
+  m_omxPlayerVideo.SetDelay( (fValue * DVD_TIME_BASE) ) ;
+#else
+  // Start with the global delay and offset from there.
+  float totalDelay = g_guiSettings.GetInt("audiooutput.defaultdelay")/1000.0 + fValue;
+  m_omxPlayerVideo.SetDelay( (totalDelay * DVD_TIME_BASE) ) ;
+#endif
 }
 
 float COMXPlayer::GetAVDelay()
 {
-  return m_player_video.GetDelay() / (float)DVD_TIME_BASE;
+  return m_omxPlayerVideo.GetDelay() / (float)DVD_TIME_BASE;
 }
 
 void COMXPlayer::SetSubTitleDelay(float fValue)
 {
-  m_player_video.SetSubtitleDelay(-fValue * DVD_TIME_BASE);
+  m_omxPlayerVideo.SetSubtitleDelay(-fValue * DVD_TIME_BASE);
 }
 
 float COMXPlayer::GetSubTitleDelay()
 {
-  return -m_player_video.GetSubtitleDelay() / DVD_TIME_BASE;
+  return -m_omxPlayerVideo.GetSubtitleDelay() / DVD_TIME_BASE;
 }
 
 // priority: 1: libdvdnav, 2: external subtitles, 3: muxed subtitles
@@ -2770,6 +3199,16 @@
 void COMXPlayer::SetSubtitle(int iStream)
 {
   m_messenger.Put(new CDVDMsgPlayerSetSubtitleStream(iStream));
+
+  /* PLEX */
+  // Return the ID of the selected stream.
+  OMXStreamLock lock(this);
+  OMXSelectionStream& s = m_SelectionStreams.Get(STREAM_SUBTITLE, iStream);
+
+  // Send the change to the Media Server.
+  CFileItemPtr item = g_application.CurrentFileItemPtr();
+  g_plexApplication.mediaServerClient->SelectStream(item, GetPlexMediaPartID(), g_settings.m_currentVideoSettings.m_SubtitleOn ? s.plexID : 0, -1);
+  /* END PLEX */
 }
 
 bool COMXPlayer::GetSubtitleVisible()
@@ -2783,13 +3222,24 @@
       return pStream->IsSubtitleStreamEnabled();
   }
 
-  return m_player_video.IsSubtitleEnabled();
+  return m_omxPlayerVideo.IsSubtitleEnabled();
 }
 
 void COMXPlayer::SetSubtitleVisible(bool bVisible)
 {
   g_settings.m_currentVideoSettings.m_SubtitleOn = bVisible;
   m_messenger.Put(new CDVDMsgBool(CDVDMsg::PLAYER_SET_SUBTITLESTREAM_VISIBLE, bVisible));
+
+  /* PLEX */
+  // Send the change to the Media Server.
+  CFileItemPtr item = g_application.CurrentFileItemPtr();
+  int partID = GetPlexMediaPartID();
+  int subtitleStreamID = GetSubtitlePlexID();
+
+  // Don't send the message over if we're just hiding the initial sub.
+  if (m_hidingSub == false)
+    g_plexApplication.mediaServerClient->SelectStream(item, partID, g_settings.m_currentVideoSettings.m_SubtitleOn ? subtitleStreamID : 0, -1);
+  /* END PLEX */
 }
 
 int COMXPlayer::GetAudioStreamCount()
@@ -2816,11 +3266,19 @@
   if(s.type == STREAM_NONE)
     strStreamName += " (Invalid)";
 }
- 
+
 void COMXPlayer::SetAudioStream(int iStream)
 {
   m_messenger.Put(new CDVDMsgPlayerSetAudioStream(iStream));
   SynchronizeDemuxer(100);
+
+  /* PLEX */
+  OMXStreamLock lock(this);
+
+  // Notify the Plex Media Server.
+  CFileItemPtr item = g_application.CurrentFileItemPtr();
+  g_plexApplication.mediaServerClient->SelectStream(item, GetPlexMediaPartID(), -1, GetAudioStreamPlexID());
+  /* END PLEX */
 }
 
 TextCacheStruct_t* COMXPlayer::GetTeletextCache()
@@ -2828,7 +3286,7 @@
   if (m_CurrentTeletext.id < 0)
     return 0;
 
-  return m_player_teletext.GetTeletextCache();
+  return m_dvdPlayerTeletext.GetTeletextCache();
 }
 
 void COMXPlayer::LoadPage(int p, int sp, unsigned char* buffer)
@@ -2836,7 +3294,7 @@
   if (m_CurrentTeletext.id < 0)
       return;
 
-  return m_player_teletext.LoadPage(p, sp, buffer);
+  return m_dvdPlayerTeletext.LoadPage(p, sp, buffer);
 }
 
 void COMXPlayer::SeekTime(int64_t iTime)
@@ -2855,12 +3313,12 @@
   const double limit  = DVD_MSEC_TO_TIME(200);
   if(m_State.timestamp > 0)
   {
-    offset  = m_av_clock.GetAbsoluteClock() - m_State.timestamp;
+    offset  = m_clock.GetAbsoluteClock() - m_State.timestamp;
     offset *= m_playSpeed / DVD_PLAYSPEED_NORMAL;
     if(offset >  limit) offset =  limit;
     if(offset < -limit) offset = -limit;
   }
-  //{CLog::Log(LOGINFO, "%s: time:%.2f stamp:%.2f dts:%d m:%d (p:%d,c:%d) =%llu", __func__, (double)m_State.time, (double)m_State.timestamp, (int)DVD_TIME_TO_MSEC(m_State.dts + m_offset_pts), (int)DVD_TIME_TO_MSEC(m_av_clock.OMXMediaTime()), (int)m_playSpeed, (int)m_caching, llrint(m_State.time + DVD_TIME_TO_MSEC(offset)));}
+  //{CLog::Log(LOGINFO, "%s: time:%.2f stamp:%.2f dts:%d m:%d (p:%d,c:%d) =%llu", __func__, (double)m_State.time, (double)m_State.timestamp, (int)DVD_TIME_TO_MSEC(m_State.dts + m_offset_pts), (int)DVD_TIME_TO_MSEC(m_stamp), (int)m_playSpeed, (int)m_caching, llrint(m_State.time + DVD_TIME_TO_MSEC(offset)));}
   return llrint(m_State.time + DVD_TIME_TO_MSEC(offset));
 }
 
@@ -2882,11 +3340,6 @@
   // can't rewind in menu as seeking isn't possible
   // forward is fine
   if (iSpeed < 0 && IsInMenu()) return;
-
-  /* only pause and normal playspeeds are allowed */
-  if(iSpeed > 1 || iSpeed < 0)
-    return;
-
   SetPlaySpeed(iSpeed * DVD_PLAYSPEED_NORMAL);
 }
 
@@ -2926,7 +3379,7 @@
   if(m_CurrentAudio.id    < 0
   || m_CurrentAudio.hint != hint)
   {
-    if(!m_player_audio.OpenStream(hint))
+    if(!m_omxPlayerAudio.OpenStream(hint))
     {
       /* mark stream as disabled, to disallaw further attempts*/
       CLog::Log(LOGWARNING, "%s - Unsupported stream %d. Stream disabled.", __FUNCTION__, iStream);
@@ -2934,11 +3387,9 @@
       pStream->SetDiscard(AVDISCARD_ALL);
       return false;
     }
-    m_av_clock.SetSpeed(DVD_PLAYSPEED_NORMAL);
-    m_av_clock.OMXSetSpeed(DVD_PLAYSPEED_NORMAL);
   }
   else if (reset)
-    m_player_audio.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
+    m_omxPlayerAudio.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
 
   /* store information about stream */
   m_CurrentAudio.id = iStream;
@@ -2946,13 +3397,14 @@
   m_CurrentAudio.hint = hint;
   m_CurrentAudio.stream = (void*)pStream;
   m_CurrentAudio.started = false;
+  m_clock.SetMasterClock(false);
   m_HasAudio = true;
 
   /* we are potentially going to be waiting on this */
-  m_player_audio.SendMessage(new CDVDMsg(CDVDMsg::PLAYER_STARTED), 1);
+  m_omxPlayerAudio.SendMessage(new CDVDMsg(CDVDMsg::PLAYER_STARTED), 1);
 
-  /* software decoding normaly consumes full cpu time so prio it */
-  m_player_audio.SetPriority(GetPriority()+1);
+  /* audio normally won't consume full cpu, so let it have prio */
+  m_omxPlayerAudio.SetPriority(GetPriority()+1);
 
   return true;
 }
@@ -3007,7 +3459,7 @@
   if(m_CurrentVideo.id    < 0
   || m_CurrentVideo.hint != hint)
   {
-    if (!m_player_video.OpenStream(hint))
+    if (!m_omxPlayerVideo.OpenStream(hint))
     {
       /* mark stream as disabled, to disallaw further attempts */
       CLog::Log(LOGWARNING, "%s - Unsupported stream %d. Stream disabled.", __FUNCTION__, iStream);
@@ -3015,18 +3467,16 @@
       pStream->SetDiscard(AVDISCARD_ALL);
       return false;
     }
-    m_av_clock.SetSpeed(DVD_PLAYSPEED_NORMAL);
-    m_av_clock.OMXSetSpeed(DVD_PLAYSPEED_NORMAL);
   }
   else if (reset)
-    m_player_video.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
+    m_omxPlayerVideo.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
 
   unsigned flags = 0;
   if(m_filename.find("3DSBS") != string::npos || m_filename.find("HSBS") != string::npos)
     flags = CONF_FLAGS_FORMAT_SBS;
   else if(m_filename.find("3DTAB") != string::npos || m_filename.find("HTAB") != string::npos)
     flags = CONF_FLAGS_FORMAT_TB;
-  m_player_video.SetFlags(flags);
+  m_omxPlayerVideo.SetFlags(flags);
 
   /* store information about stream */
   m_CurrentVideo.id = iStream;
@@ -3037,17 +3487,25 @@
   m_HasVideo = true;
 
   /* we are potentially going to be waiting on this */
-  m_player_video.SendMessage(new CDVDMsg(CDVDMsg::PLAYER_STARTED), 1);
+  m_omxPlayerVideo.SendMessage(new CDVDMsg(CDVDMsg::PLAYER_STARTED), 1);
 
   /* use same priority for video thread as demuxing thread, as */
   /* otherwise demuxer will starve if video consumes the full cpu */
-  m_player_video.SetPriority(GetPriority());
+  m_omxPlayerVideo.SetPriority(GetPriority());
 
   return true;
 }
 
 bool COMXPlayer::OpenSubtitleStream(int iStream, int source)
 {
+  /* PLEX */
+  if (g_guiSettings.GetBool("plexmediaserver.transcodesubtitles") && m_item.GetProperty("plexDidTranscode").asBoolean())
+  {
+    CLog::Log(LOGNOTICE, "Skipping Subtitle stream: %i source: %i, subtitles are transcoded", iStream, source);
+    return true;
+  }
+  /* END PLEX */
+
   CLog::Log(LOGNOTICE, "Opening Subtitle stream: %i source: %i", iStream, source);
 
   CDemuxStream* pStream = NULL;
@@ -3074,7 +3532,7 @@
     if(!pStream || pStream->disabled)
       return false;
     pStream->SetDiscard(AVDISCARD_NONE);
-    double pts = m_player_video.GetCurrentPTS();
+    double pts = m_omxPlayerVideo.GetCurrentPts();
     if(pts == DVD_NOPTS_VALUE)
       pts = m_CurrentVideo.dts;
     if(pts == DVD_NOPTS_VALUE)
@@ -3119,7 +3577,7 @@
       CloseSubtitleStream(false);
     }
 
-    if(!m_player_subtitle.OpenStream(hint, filename))
+    if(!m_dvdPlayerSubtitle.OpenStream(hint, filename))
     {
       CLog::Log(LOGWARNING, "%s - Unsupported stream %d. Stream disabled.", __FUNCTION__, iStream);
       if(pStream)
@@ -3131,7 +3589,7 @@
     }
   }
   else
-    m_player_subtitle.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
+    m_dvdPlayerSubtitle.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
 
   m_CurrentSubtitle.id     = iStream;
   m_CurrentSubtitle.source = source;
@@ -3153,7 +3611,7 @@
 
   CDVDStreamInfo hint(*pStream, true);
 
-  if (!m_player_teletext.CheckStream(hint))
+  if (!m_dvdPlayerTeletext.CheckStream(hint))
     return false;
 
   CLog::Log(LOGNOTICE, "Opening teletext stream: %i source: %i", iStream, source);
@@ -3167,7 +3625,7 @@
       CloseTeletextStream(true);
     }
 
-    if (!m_player_teletext.OpenStream(hint))
+    if (!m_dvdPlayerTeletext.OpenStream(hint))
     {
       /* mark stream as disabled, to disallaw further attempts*/
       CLog::Log(LOGWARNING, "%s - Unsupported teletext stream %d. Stream disabled.", __FUNCTION__, iStream);
@@ -3177,7 +3635,7 @@
     }
   }
   else
-    m_player_teletext.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
+    m_dvdPlayerTeletext.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
 
   /* store information about stream */
   m_CurrentTeletext.id      = iStream;
@@ -3199,7 +3657,7 @@
   if(bWaitForBuffers)
     SetCaching(CACHESTATE_DONE);
 
-  m_player_audio.CloseStream(bWaitForBuffers);
+  m_omxPlayerAudio.CloseStream(bWaitForBuffers);
 
   m_CurrentAudio.Clear();
   return true;
@@ -3215,7 +3673,7 @@
   if(bWaitForBuffers)
     SetCaching(CACHESTATE_DONE);
 
-  m_player_video.CloseStream(bWaitForBuffers);
+  m_omxPlayerVideo.CloseStream(bWaitForBuffers);
 
   m_CurrentVideo.Clear();
   return true;
@@ -3228,7 +3686,7 @@
 
   CLog::Log(LOGNOTICE, "Closing subtitle stream");
 
-  m_player_subtitle.CloseStream(!bKeepOverlays);
+  m_dvdPlayerSubtitle.CloseStream(!bKeepOverlays);
 
   m_CurrentSubtitle.Clear();
   return true;
@@ -3244,7 +3702,7 @@
   if(bWaitForBuffers)
     SetCaching(CACHESTATE_DONE);
 
-  m_player_teletext.CloseStream(bWaitForBuffers);
+  m_dvdPlayerTeletext.CloseStream(bWaitForBuffers);
 
   m_CurrentTeletext.Clear();
   return true;
@@ -3256,7 +3714,13 @@
 
   CLog::Log(LOGNOTICE, "FlushBuffers: q:%d pts:%.0f a:%d", queued, pts, accurate);
 
-  if(accurate)
+  if (!TP(m_playSpeed))
+    m_av_clock.OMXStop();
+  m_av_clock.OMXPause();
+  m_stepped           = false;
+
+  /* for now, ignore accurate flag as it discards keyframes and causes corrupt frames */
+  if(0 && accurate)
     startpts = pts;
   else
     startpts = DVD_NOPTS_VALUE;
@@ -3283,19 +3747,19 @@
 
   if(queued)
   {
-    m_player_audio.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
-    m_player_video.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
-    m_player_video.SendMessage(new CDVDMsg(CDVDMsg::VIDEO_NOSKIP));
-    m_player_subtitle.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
-    m_player_teletext.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
+    m_omxPlayerAudio.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
+    m_omxPlayerVideo.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
+    m_omxPlayerVideo.SendMessage(new CDVDMsg(CDVDMsg::VIDEO_NOSKIP));
+    m_dvdPlayerSubtitle.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
+    m_dvdPlayerTeletext.SendMessage(new CDVDMsg(CDVDMsg::GENERAL_RESET));
     SynchronizePlayers(SYNCSOURCE_ALL);
   }
   else
   {
-    m_player_video.Flush();
-    m_player_audio.Flush();
-    m_player_subtitle.Flush();
-    m_player_teletext.Flush();
+    m_omxPlayerAudio.Flush();
+    m_omxPlayerVideo.Flush();
+    m_dvdPlayerSubtitle.Flush();
+    m_dvdPlayerTeletext.Flush();
 
     // clear subtitle and menu overlays
     m_overlayContainer.Clear();
@@ -3305,8 +3769,8 @@
     {
       // make sure players are properly flushed, should put them in stalled state
       CDVDMsgGeneralSynchronize* msg = new CDVDMsgGeneralSynchronize(1000, 0);
-      m_player_video.SendMessage(msg->Acquire(), 1);
-      m_player_audio.SendMessage(msg->Acquire(), 1);
+      m_omxPlayerAudio.SendMessage(msg->Acquire(), 1);
+      m_omxPlayerVideo.SendMessage(msg->Acquire(), 1);
       msg->Wait(&m_bStop, 0);
       msg->Release();
 
@@ -3322,7 +3786,7 @@
     }
 
     if(pts != DVD_NOPTS_VALUE)
-      m_av_clock.Discontinuity(pts);
+      m_clock.Discontinuity(pts);
     UpdatePlayState(0);
   }
   // let clock know the new time so progress bar updates immediately
@@ -3344,7 +3808,7 @@
     else if(iMessage == 3)
       m_dvd.iSelectedSPUStream   = *(int*)pData;
     else if(iMessage == 4)
-      m_player_video.EnableSubtitle(*(int*)pData ? true: false);
+      m_omxPlayerVideo.EnableSubtitle(*(int*)pData ? true: false);
 
     return 0;
   }
@@ -3378,7 +3842,7 @@
           DWORD time = 0;
           if( m_CurrentVideo.stream && m_dvd.iDVDStillTime > 0 )
           {
-            time = (DWORD)(m_player_video.GetOutputDelay() / ( DVD_TIME_BASE / 1000 ));
+            time = (DWORD)(m_omxPlayerVideo.GetOutputDelay() / ( DVD_TIME_BASE / 1000 ));
             if( time < 10000 && time > 0 )
               m_dvd.iDVDStillTime += time;
           }
@@ -3392,7 +3856,7 @@
       break;
     case DVDNAV_SPU_CLUT_CHANGE:
       {
-        m_player_subtitle.SendMessage(new CDVDMsgSubtitleClutChange((BYTE*)pData));
+        m_dvdPlayerSubtitle.SendMessage(new CDVDMsgSubtitleClutChange((BYTE*)pData));
       }
       break;
     case DVDNAV_SPU_STREAM_CHANGE:
@@ -3402,7 +3866,7 @@
         int iStream = event->physical_wide;
         bool visible = !(iStream & 0x80);
 
-        m_player_video.EnableSubtitle(visible);
+        m_omxPlayerVideo.EnableSubtitle(visible);
 
         if (iStream >= 0)
           m_dvd.iSelectedSPUStream = (iStream & ~0x80);
@@ -3432,7 +3896,7 @@
         //dvdnav_highlight_event_t* pInfo = (dvdnav_highlight_event_t*)pData;
         int iButton = pStream->GetCurrentButton();
         CLog::Log(LOGDEBUG, "DVDNAV_HIGHLIGHT: Highlight button %d\n", iButton);
-        m_player_subtitle.UpdateOverlayInfo((CDVDInputStreamNavigator*)m_pInputStream, LIBDVDNAV_BUTTON_NORMAL);
+        m_dvdPlayerSubtitle.UpdateOverlayInfo((CDVDInputStreamNavigator*)m_pInputStream, LIBDVDNAV_BUTTON_NORMAL);
       }
       break;
     case DVDNAV_VTS_CHANGE:
@@ -3445,8 +3909,8 @@
 
         //Force an aspect ratio that is set in the dvdheaders if available
         m_CurrentVideo.hint.aspect = pStream->GetVideoAspectRatio();
-        if( m_player_video.IsInited() )
-          m_player_video.SendMessage(new CDVDMsgDouble(CDVDMsg::VIDEO_SET_ASPECT, m_CurrentVideo.hint.aspect));
+        if( m_omxPlayerVideo.IsInited() )
+          m_omxPlayerVideo.SendMessage(new CDVDMsgDouble(CDVDMsg::VIDEO_SET_ASPECT, m_CurrentVideo.hint.aspect));
 
         m_SelectionStreams.Clear(STREAM_NONE, STREAM_SOURCE_NAV);
         m_SelectionStreams.Update(m_pInputStream, m_pDemuxer);
@@ -3461,8 +3925,8 @@
 
         m_dvd.state = DVDSTATE_NORMAL;
 
-        if( m_player_video.IsInited() )
-          m_player_video.SendMessage(new CDVDMsg(CDVDMsg::VIDEO_NOSKIP));
+        if( m_omxPlayerVideo.IsInited() )
+          m_omxPlayerVideo.SendMessage(new CDVDMsg(CDVDMsg::VIDEO_NOSKIP));
       }
       break;
     case DVDNAV_NAV_PACKET:
@@ -3667,7 +4131,7 @@
           CLog::Log(LOGDEBUG, " - button select");
           // show button pushed overlay
           if(m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD))
-            m_player_subtitle.UpdateOverlayInfo((CDVDInputStreamNavigator*)m_pInputStream, LIBDVDNAV_BUTTON_CLICKED);
+            m_dvdPlayerSubtitle.UpdateOverlayInfo((CDVDInputStreamNavigator*)m_pInputStream, LIBDVDNAV_BUTTON_CLICKED);
 
           pMenus->ActivateButton();
         }
@@ -3783,15 +4247,15 @@
 
 bool COMXPlayer::GetCurrentSubtitle(CStdString& strSubtitle)
 {
+  double pts = m_av_clock.OMXMediaTime();
+
   if (m_pInputStream && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD))
     return false;
 
-  double pts = m_av_clock.OMXMediaTime(false);
-
-  m_player_subtitle.GetCurrentSubtitle(strSubtitle, pts - m_player_video.GetSubtitleDelay());
+  m_dvdPlayerSubtitle.GetCurrentSubtitle(strSubtitle, pts - m_omxPlayerVideo.GetSubtitleDelay());
 
   // In case we stalled, don't output any subs
-  if ((m_player_video.IsStalled() && HasVideo()) || (m_player_audio.IsStalled() && HasAudio()))
+  if ((m_omxPlayerVideo.IsStalled() && HasVideo()) || (m_omxPlayerAudio.IsStalled() && HasAudio()))
     strSubtitle = m_lastSub;
   else
     m_lastSub = strSubtitle;
@@ -3859,19 +4323,19 @@
 
 double COMXPlayer::GetQueueTime()
 {
-  int a = m_player_video.GetLevel();
-  int v = m_player_audio.GetLevel();
+  int a = m_omxPlayerVideo.GetLevel();
+  int v = m_omxPlayerAudio.GetLevel();
   return max(a, v) * 8000.0 / 100;
 }
 
 int COMXPlayer::GetAudioBitrate()
 {
-  return m_player_audio.GetAudioBitrate();
+  return m_omxPlayerAudio.GetAudioBitrate();
 }
 
 int COMXPlayer::GetVideoBitrate()
 {
-  return m_player_video.GetVideoBitrate();
+  return m_omxPlayerVideo.GetVideoBitrate();
 }
 
 int COMXPlayer::GetSourceBitrate()
@@ -3920,7 +4384,7 @@
 void COMXPlayer::UpdatePlayState(double timeout)
 {
   if(m_State.timestamp != 0
-  && m_State.timestamp + DVD_MSEC_TO_TIME(timeout) > m_av_clock.GetAbsoluteClock())
+  && m_State.timestamp + DVD_MSEC_TO_TIME(timeout) > m_clock.GetAbsoluteClock())
     return;
 
   SPlayerState state(m_State);
@@ -3940,7 +4404,7 @@
 
     // TODO : workaround until omx clock handling is rewritten
     if(m_playSpeed == DVD_PLAYSPEED_NORMAL)
-      state.time       = DVD_TIME_TO_MSEC(m_av_clock.OMXMediaTime(true));
+      state.time       = DVD_TIME_TO_MSEC(m_av_clock.OMXMediaTime());
     else
       state.time       = DVD_TIME_TO_MSEC(m_av_clock.GetClock() + m_offset_pts);
     state.time_total = m_pDemuxer->GetStreamLength();
@@ -4045,8 +4509,8 @@
   else
     state.cache_bytes = 0;
 
-  state.timestamp = m_av_clock.GetAbsoluteClock();
-  //{CLog::Log(LOGINFO, "%s: time:%.2f stamp:%.2f dts:%d m:%d (p:%d,c:%d) =%llu", __func__, (double)state.time, (double)state.timestamp, (int)DVD_TIME_TO_MSEC(state.dts + m_offset_pts), (int)DVD_TIME_TO_MSEC(m_av_clock.OMXMediaTime()), (int)m_playSpeed, (int)m_caching, llrint(state.time + DVD_TIME_TO_MSEC(offset)));}
+  state.timestamp = m_clock.GetAbsoluteClock();
+  //{CLog::Log(LOGINFO, "%s: time:%.2f stamp:%.2f dts:%d m:%d (p:%d,c:%d) =%llu", __func__, (double)state.time, (double)state.timestamp, (int)DVD_TIME_TO_MSEC(state.dts + m_offset_pts), (int)DVD_TIME_TO_MSEC(m_stamp), (int)m_playSpeed, (int)m_caching, llrint(state.time + DVD_TIME_TO_MSEC(offset)));}
 
   CSingleLock lock(m_StateSection);
   m_State = state;
@@ -4055,7 +4519,7 @@
 void COMXPlayer::UpdateApplication(double timeout)
 {
   if(m_UpdateApplication != 0
-  && m_UpdateApplication + DVD_MSEC_TO_TIME(timeout) > m_av_clock.GetAbsoluteClock())
+  && m_UpdateApplication + DVD_MSEC_TO_TIME(timeout) > m_clock.GetAbsoluteClock())
     return;
 
   CDVDInputStream::IChannel* pStream = dynamic_cast<CDVDInputStream::IChannel*>(m_pInputStream);
@@ -4068,7 +4532,7 @@
       CApplicationMessenger::Get().SetCurrentItem(item);
     }
   }
-  m_UpdateApplication = m_av_clock.GetAbsoluteClock();
+  m_UpdateApplication = m_clock.GetAbsoluteClock();
 }
 
 bool COMXPlayer::CanRecord()
@@ -4173,7 +4637,7 @@
 CStdString COMXPlayer::GetPlayingTitle()
 {
   /* Currently we support only Title Name from Teletext line 30 */
-  TextCacheStruct_t* ttcache = m_player_teletext.GetTeletextCache();
+  TextCacheStruct_t* ttcache = m_dvdPlayerTeletext.GetTeletextCache();
   if (ttcache && !ttcache->line30.empty())
     return ttcache->line30;
 
@@ -4210,82 +4674,260 @@
       g_advancedSettings.m_bPVRCacheInDvdPlayer;
 }
 
-void COMXPlayer::GetVideoRect(CRect& SrcRect, CRect& DestRect)
+void COMXPlayer::GetRenderFeatures(std::vector<int> &renderFeatures)
 {
-  g_renderManager.GetVideoRect(SrcRect, DestRect);
+  renderFeatures.push_back(RENDERFEATURE_STRETCH);
+  renderFeatures.push_back(RENDERFEATURE_CROP);
+  renderFeatures.push_back(RENDERFEATURE_PIXEL_RATIO);
+  renderFeatures.push_back(RENDERFEATURE_ZOOM);
 }
 
-void COMXPlayer::SetMute(bool bOnOff)
+void COMXPlayer::GetDeinterlaceMethods(std::vector<int> &deinterlaceMethods)
 {
-  m_current_mute = bOnOff;
-  m_change_volume = true;
+  deinterlaceMethods.push_back(VS_INTERLACEMETHOD_DEINTERLACE);
 }
 
-void COMXPlayer::SetVolume(float fVolume)
+void COMXPlayer::GetDeinterlaceModes(std::vector<int> &deinterlaceModes)
 {
-  m_current_volume = fVolume;
-  m_change_volume = true;
+  deinterlaceModes.push_back(VS_DEINTERLACEMODE_AUTO);
+  deinterlaceModes.push_back(VS_DEINTERLACEMODE_OFF);
+  deinterlaceModes.push_back(VS_DEINTERLACEMODE_FORCE);
 }
 
-bool COMXPlayer::WaitForPausedThumbJobs(int timeout_ms)
+void COMXPlayer::GetScalingMethods(std::vector<int> &scalingMethods)
 {
-  // use m_bStop and Sleep so we can get canceled.
-  while (!m_bStop && (timeout_ms > 0))
-  {
-    if (CJobManager::GetInstance().IsProcessing(kJobTypeMediaFlags) > 0)
-    {
-      Sleep(100);
-      timeout_ms -= 100;
-    }
-    else
-      return true;
-  }
-
-  return false;
 }
 
-void COMXPlayer::Update(bool bPauseDrawing)
+void COMXPlayer::GetAudioCapabilities(std::vector<int> &audioCaps)
 {
-  g_renderManager.Update(bPauseDrawing);
+  audioCaps.push_back(IPC_AUD_OFFSET);
+  audioCaps.push_back(IPC_AUD_SELECT_STREAM);
+  audioCaps.push_back(IPC_AUD_SELECT_OUTPUT);
+  audioCaps.push_back(IPC_AUD_AMP);
 }
 
-void COMXPlayer::GetVideoAspectRatio(float &fAR)
+void COMXPlayer::GetSubtitleCapabilities(std::vector<int> &subCaps)
 {
-  fAR = g_renderManager.GetAspectRatio();
+  subCaps.push_back(IPC_SUBS_ALL);
 }
 
-void COMXPlayer::GetRenderFeatures(std::vector<int> &renderFeatures)
+/* PLEX */
+void COMXPlayer::OpenDefaultStreams(bool reset)
 {
-  renderFeatures.push_back(RENDERFEATURE_STRETCH);
-  renderFeatures.push_back(RENDERFEATURE_CROP);
+  int  count;
+  bool valid;
+  OMXSelectionStream st;
+
+  // open video stream
+  count = m_SelectionStreams.Count(STREAM_VIDEO);
+  valid = false;
+
+  if(!valid
+  && m_SelectionStreams.Get(STREAM_VIDEO, CDemuxStream::FLAG_DEFAULT, st))
+  {
+    if(OpenVideoStream(st.id, st.source, reset))
+      valid = true;
+    else
+      CLog::Log(LOGWARNING, "%s - failed to open default stream (%d)", __FUNCTION__, st.id);
+  }
+
+  for(int i = 0;i<count && !valid;i++)
+  {
+    OMXSelectionStream& s = m_SelectionStreams.Get(STREAM_VIDEO, i);
+    if(OpenVideoStream(s.id, s.source, reset))
+      valid = true;
+  }
+  if(!valid)
+    CloseVideoStream(true);
+
+  if(!m_PlayerOptions.video_only)
+  {
+    // open audio stream
+    count = m_SelectionStreams.Count(STREAM_AUDIO);
+    valid = false;
+
+    // Pick selected audio stream.
+    CFileItemPtr part = m_item.m_selectedMediaPart;
+    if (part)
+    {
+      BOOST_FOREACH(CFileItemPtr stream, part->m_mediaPartStreams)
+      {
+        int streamType = stream->GetProperty("streamType").asInteger();
+        int streamId = stream->GetProperty("id").asInteger();
+        std::string streamLang = stream->GetProperty("language").asString();
+        bool selected = stream->GetProperty("selected").asBoolean();
+        CLog::Log(LOGINFO, "COMXPlayer::OpenDefaultStreams Considering Plex stream %d[%s] of type %d (selected: %d)",
+                  streamId, streamLang.c_str(), streamType, selected);
+
+        // If we've found the selected audio stream...
+        if (streamType == PLEX_STREAM_AUDIO && selected)
+        {
+          // ...see if we can match it up with our stream.
+          count = m_SelectionStreams.Count(STREAM_AUDIO);
+          for (int i=0; i<count && !valid; i++)
+          {
+            OMXSelectionStream& s = m_SelectionStreams.Get(STREAM_AUDIO, i);
+            if (s.plexID == streamId && OpenAudioStream(s.id, s.source, reset))
+            {
+              CLog::Log(LOGINFO, "COMXPlayer::OpenDefaultStreams selected stream %d[%s]", streamId, streamLang.c_str());
+              valid = true;
+            }
+          }
+        }
+
+        if (valid) break;
+      }
+    }
+
+    // If that didn't work, just pick the first valid stream.
+    for(int i = 0; i<count && !valid; i++)
+    {
+      OMXSelectionStream& s = m_SelectionStreams.Get(STREAM_AUDIO, i);
+      if(OpenAudioStream(s.id, s.source, reset))
+      {
+        CLog::Log(LOGINFO, "COMXPlayer::OpenDefaultStreams failed to find the stream based plexId, instead you will get %d[%s]", s.plexID, s.language.c_str());
+        valid = true;
+      }
+    }
+
+    // If we don't have an audio stream, close it.
+    if(!valid)
+      CloseAudioStream(true);
+  }
+
+  /* If user have selected to transcode subtitles we should not show it again here */
+  if (m_item.GetProperty("plexDidTranscode").asBoolean() && g_guiSettings.GetBool("plexmediaserver.transcodesubtitles"))
+    return;
+
+  // open subtitle stream
+  valid = false;
+  m_omxPlayerVideo.EnableSubtitle(true);
+
+  // Open subtitle stream.
+  CFileItemPtr part = m_item.m_selectedMediaPart;
+  if (part)
+  {
+    BOOST_FOREACH(CFileItemPtr stream, part->m_mediaPartStreams)
+    {
+      // If we've found the selected subtitle stream...
+      if (stream->GetProperty("streamType").asInteger() == PLEX_STREAM_SUBTITLE && stream->GetProperty("selected").asBoolean())
+      {
+        count = m_SelectionStreams.Count(STREAM_SUBTITLE);
+
+        for (int i = 0; i<count && !valid; i++)
+        {
+          OMXSelectionStream& s = m_SelectionStreams.Get(STREAM_SUBTITLE, i);
+          if (s.plexID == stream->GetProperty("id").asInteger() && OpenSubtitleStream(s.id, s.source))
+          {
+            // We're going to need to open this later.
+            if (s.source == STREAM_SOURCE_DEMUX_SUB)
+              m_vobsubToDisplay = s.plexID;
+
+            valid = true;
+          }
+        }
+      }
+
+      if (valid) break;
+    }
+
+    // If that didn't pick one, just open the first stream and make it invisible.
+    if (valid == false && count > 0)
+    {
+      OMXSelectionStream& s = m_SelectionStreams.Get(STREAM_SUBTITLE, 0);
+      OpenSubtitleStream(s.id, s.source);
+
+      if (s.source == STREAM_SOURCE_DEMUX_SUB)
+        m_vobsubToDisplay = s.plexID;
+    }
+
+    // Set them on/off based on whether we found one.
+    g_settings.m_currentVideoSettings.m_SubtitleOn = valid;
+
+    // We don't have subtitles to show, close.
+    if (valid == false)
+    {
+      m_hidingSub = true;
+      SetSubtitleVisible(false);
+      m_hidingSub = false;
+    }
+  }
 }
 
-void COMXPlayer::GetDeinterlaceMethods(std::vector<int> &deinterlaceMethods)
+void COMXPlayer::RelinkPlexStreams()
 {
-  deinterlaceMethods.push_back(VS_INTERLACEMETHOD_DEINTERLACE);
+  CFileItemPtr part = m_item.m_selectedMediaPart;
+  if (part)
+  {
+    BOOST_FOREACH(CFileItemPtr stream, part->m_mediaPartStreams)
+    {
+      StreamType type = STREAM_NONE;
+
+      if (stream->GetProperty("streamType").asInteger() == PLEX_STREAM_SUBTITLE)
+        type = STREAM_SUBTITLE;
+      else if (stream->GetProperty("streamType").asInteger() == PLEX_STREAM_AUDIO)
+        type = STREAM_AUDIO;
+
+      if (type != STREAM_NONE)
+      {
+        // Look for the right index and set the Plex stream ID.
+        int count = m_SelectionStreams.Count(type);
+        for (int i=0; i<count; i++)
+        {
+          OMXSelectionStream& s = m_SelectionStreams.Get(type, i);
+
+          if (s.id == stream->GetProperty("index").asInteger() || s.id == stream->GetProperty("subIndex").asInteger())
+          {
+            s.plexID = stream->GetProperty("id").asInteger();
+            s.language = stream->GetProperty("language").asString();
+
+            if (stream->GetProperty("streamType").asInteger() == PLEX_STREAM_SUBTITLE)
+              s.name = stream->GetProperty("language").asString();
+          }
+        }
+      }
+    }
+  }
 }
 
-void COMXPlayer::GetDeinterlaceModes(std::vector<int> &deinterlaceModes)
+int COMXPlayer::GetAudioStreamPlexID()
 {
-  deinterlaceModes.push_back(VS_DEINTERLACEMODE_AUTO);
-  deinterlaceModes.push_back(VS_DEINTERLACEMODE_OFF);
-  deinterlaceModes.push_back(VS_DEINTERLACEMODE_FORCE);
+  OMXSelectionStream& stream = m_SelectionStreams.Get(STREAM_AUDIO, m_SelectionStreams.IndexOf(STREAM_AUDIO, *this));
+  return stream.plexID;
 }
 
-void COMXPlayer::GetScalingMethods(std::vector<int> &scalingMethods)
+int COMXPlayer::GetSubtitlePlexID()
 {
+  OMXSelectionStream& stream = m_SelectionStreams.Get(STREAM_SUBTITLE, m_SelectionStreams.IndexOf(STREAM_SUBTITLE, *this));
+  return stream.plexID;
 }
 
-void COMXPlayer::GetAudioCapabilities(std::vector<int> &audioCaps)
+void COMXPlayer::SetAudioStreamPlexID(int plexID)
 {
-  audioCaps.push_back(IPC_AUD_OFFSET);
-  audioCaps.push_back(IPC_AUD_SELECT_STREAM);
-  audioCaps.push_back(IPC_AUD_SELECT_OUTPUT);
+  std::vector<OMXSelectionStream> audiost = m_SelectionStreams.Get(STREAM_AUDIO);
+  for (int i = 0; i < audiost.size(); i ++)
+  {
+    if (audiost[i].plexID == plexID)
+    {
+      SetAudioStream(audiost[i].type_index);
+      break;
+    }
+  }
 }
 
-void COMXPlayer::GetSubtitleCapabilities(std::vector<int> &subCaps)
+void COMXPlayer::SetSubtitleStreamPlexID(int plexID)
 {
-  subCaps.push_back(IPC_SUBS_ALL);
+  std::vector<OMXSelectionStream> subst = m_SelectionStreams.Get(STREAM_SUBTITLE);
+  for (int i = 0; i < subst.size(); i ++)
+  {
+    if (subst[i].plexID == plexID)
+    {
+      SetSubtitle(subst[i].type_index);
+      break;
+    }
+  }
 }
 
+/* END PLEX */
+
 #endif
diff -ur a/xbmc/cores/omxplayer/OMXPlayer.h b/xbmc/cores/omxplayer/OMXPlayer.h
--- a/xbmc/cores/omxplayer/OMXPlayer.h	2015-03-12 20:52:41.090096999 +0100
+++ b/xbmc/cores/omxplayer/OMXPlayer.h	2015-03-12 20:48:25.166096999 +0100
@@ -1,6 +1,7 @@
 #pragma once
+
 /*
- *      Copyright (C) 2011-2012 Team XBMC
+ *      Copyright (C) 2005-2012 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
@@ -19,21 +20,12 @@
  *
  */
 
-#if defined(HAVE_CONFIG_H) && !defined(TARGET_WINDOWS)
-#include "config.h"
-#define DECLARE_UNUSED(a,b) a __attribute__((unused)) b;
-#endif
-
-#include <semaphore.h>
-#include <deque>
-
-#include "FileItem.h"
 #include "cores/IPlayer.h"
-#include "cores/dvdplayer/IDVDPlayer.h"
-#include "dialogs/GUIDialogBusy.h"
 #include "threads/Thread.h"
-#include "threads/SingleLock.h"
 
+#include "cores/dvdplayer/IDVDPlayer.h"
+
+#include "DVDMessageQueue.h"
 #include "OMXCore.h"
 #include "OMXClock.h"
 #include "OMXPlayerAudio.h"
@@ -41,32 +33,32 @@
 #include "DVDPlayerSubtitle.h"
 #include "DVDPlayerTeletext.h"
 
+//#include "DVDChapterReader.h"
+#include "DVDSubtitles/DVDFactorySubtitle.h"
 #include "utils/BitstreamStats.h"
 
 #include "linux/DllBCM.h"
 #include "Edl.h"
+#include "FileItem.h"
+#include "threads/SingleLock.h"
 
-#define MAX_CHAPTERS 64
-
-#define DVDPLAYER_AUDIO    1
-#define DVDPLAYER_VIDEO    2
-#define DVDPLAYER_SUBTITLE 3
-#define DVDPLAYER_TELETEXT 4
-
-#define DVDSTATE_NORMAL           0x00000001 // normal dvd state
-#define DVDSTATE_STILL            0x00000002 // currently displaying a still frame
-#define DVDSTATE_WAIT             0x00000003 // waiting for demuxer read error
-#define DVDSTATE_SEEK             0x00000004 // we are finishing a seek request
+class CDVDInputStream;
 
 class COMXPlayer;
 class OMXPlayerVideo;
 class OMXPlayerAudio;
+class CStreamInfo;
 
 namespace PVR
 {
   class CPVRChannel;
 }
 
+#define DVDSTATE_NORMAL           0x00000001 // normal dvd state
+#define DVDSTATE_STILL            0x00000002 // currently displaying a still frame
+#define DVDSTATE_WAIT             0x00000003 // waiting for demuxer read error
+#define DVDSTATE_SEEK             0x00000004 // we are finishing a seek request
+
 class COMXCurrentStream
 {
 public:
@@ -114,7 +106,11 @@
   }
 };
 
+#ifndef __PLEX__
 typedef struct
+#else
+struct OMXSelectionStream
+#endif
 {
   StreamType   type;
   int          type_index;
@@ -127,7 +123,41 @@
   int          id;
   std::string  codec;
   int          channels;
+
+
+  /* PLEX */
+  OMXSelectionStream()
+    : plexID(-1)
+    , plexSubIndex(-1)
+  {}
+
+  OMXSelectionStream& operator=(const OMXSelectionStream& other)
+  {
+    // Preserve Plex ID by *not* copying over plexID member
+    type = other.type;
+    filename = other.filename;
+
+    // Stream language from Plex stream.
+    if (type != STREAM_SUBTITLE)
+      name = other.name;
+    else if (language.size() != 3)
+      name = language;
+
+    language = other.language;
+    id = other.id;
+    flags = other.flags;
+    source = other.source;
+
+    return *this;
+  }
+  int plexID;
+  int plexSubIndex;
+  /* END PLEX */
+#ifndef __PLEX__
 } OMXSelectionStream;
+#else
+};
+#endif
 
 typedef std::vector<OMXSelectionStream> OMXSelectionStreams;
 
@@ -166,83 +196,50 @@
 };
 
 
+#define DVDPLAYER_AUDIO    1
+#define DVDPLAYER_VIDEO    2
+#define DVDPLAYER_SUBTITLE 3
+#define DVDPLAYER_TELETEXT 4
+
 class COMXPlayer : public IPlayer, public CThread, public IDVDPlayer
 {
 public:
-
   COMXPlayer(IPlayerCallback &callback);
   virtual ~COMXPlayer();
   
-  virtual void RegisterAudioCallback(IAudioCallback* pCallback) { m_player_audio.RegisterAudioCallback(pCallback); };
-  virtual void UnRegisterAudioCallback()                        { m_player_audio.UnRegisterAudioCallback();        };
-
-  virtual bool  IsValidStream(COMXCurrentStream& stream);
-  virtual bool  IsBetterStream(COMXCurrentStream& current, CDemuxStream* stream);
-  virtual bool  CheckDelayedChannelEntry(void);
-  virtual bool  ReadPacket(DemuxPacket*& packet, CDemuxStream*& stream);
-  virtual bool  CloseAudioStream(bool bWaitForBuffers);
-  virtual bool  CloseVideoStream(bool bWaitForBuffers);
-  virtual bool  CloseSubtitleStream(bool bKeepOverlays);
-  virtual bool  CloseTeletextStream(bool bWaitForBuffers);
-  virtual bool  OpenAudioStream(int iStream, int source, bool reset = true);
-  virtual bool  OpenVideoStream(int iStream, int source, bool reset = true);
-  virtual bool  OpenSubtitleStream(int iStream, int source); 
-  virtual bool  OpenTeletextStream(int iStream, int source);
-  virtual void  OpenDefaultStreams(bool reset = true);
-  virtual bool  OpenDemuxStream();
-  virtual bool  OpenInputStream();
-  virtual bool  CheckPlayerInit(COMXCurrentStream& current, unsigned int source);
-  virtual void  UpdateCorrection(DemuxPacket* pkt, double correction);
-  virtual void  UpdateTimestamps(COMXCurrentStream& current, DemuxPacket* pPacket);
-  virtual void  UpdateLimits(double& minimum, double& maximum, double dts);
-  virtual bool  CheckSceneSkip(COMXCurrentStream& current);
-  virtual void  CheckAutoSceneSkip();
-  virtual void  CheckContinuity(COMXCurrentStream& current, DemuxPacket* pPacket);
-  virtual void  ProcessAudioData(CDemuxStream* pStream, DemuxPacket* pPacket);
-  virtual void  ProcessVideoData(CDemuxStream* pStream, DemuxPacket* pPacket);
-  virtual void  ProcessSubData(CDemuxStream* pStream, DemuxPacket* pPacket);
-  virtual void  ProcessTeletextData(CDemuxStream* pStream, DemuxPacket* pPacket);
-  virtual void  ProcessPacket(CDemuxStream* pStream, DemuxPacket* pPacket);
-  virtual void  SynchronizeDemuxer(unsigned int timeout);
-  virtual void  SynchronizePlayers(unsigned int sources);
-  virtual void  SendPlayerMessage(CDVDMsg* pMsg, unsigned int target);
-  virtual void  HandleMessages();
-
   virtual bool  OpenFile(const CFileItem &file, const CPlayerOptions &options);
-  virtual bool  QueueNextFile(const CFileItem &file)             {return false;}
-  virtual void  OnNothingToQueueNotify()                         {}
   virtual bool  CloseFile();
   virtual bool  IsPlaying() const;
-  virtual void  SetPlaySpeed(int speed);
-  int GetPlaySpeed()                                                { return m_playSpeed; }
   virtual void  Pause();
   virtual bool  IsPaused() const;
   virtual bool  HasVideo() const;
   virtual bool  HasAudio() const;
   virtual bool  IsPassthrough() const;
   virtual bool  CanSeek();
-  virtual void  Seek(bool bPlus = true, bool bLargeStep = false);
+  virtual void Seek(bool bPlus, bool bLargeStep);
   virtual bool  SeekScene(bool bPlus = true);
-  virtual void  SeekPercentage(float fPercent = 0.0f);
+  virtual void SeekPercentage(float iPercent);
   virtual float GetPercentage();
   virtual float GetCachePercentage();
 
-  virtual void  SetMute(bool bOnOff);
-  virtual bool  ControlsVolume() {return true;}
-  virtual void  SetVolume(float fVolume);
-  virtual void  SetDynamicRangeCompression(long drc)              {}
-  virtual void  GetAudioInfo(CStdString &strAudioInfo);
-  virtual void  GetVideoInfo(CStdString &strVideoInfo);
-  virtual void  GetGeneralInfo(CStdString &strVideoInfo);
-  virtual void  Update(bool bPauseDrawing);
-  virtual void  GetVideoRect(CRect& SrcRect, CRect& DestRect);
-  virtual void  GetVideoAspectRatio(float &fAR);
-  virtual void  UpdateApplication(double timeout);
-  virtual bool  CanRecord();
-  virtual bool  IsRecording();
-  virtual bool  CanPause();
-  virtual bool  Record(bool bOnOff);
-  virtual void  SetAVDelay(float fValue = 0.0f);
+  virtual void RegisterAudioCallback(IAudioCallback* pCallback) { m_omxPlayerAudio.RegisterAudioCallback(pCallback); }
+  virtual void UnRegisterAudioCallback()                        { m_omxPlayerAudio.UnRegisterAudioCallback(); }
+  virtual void SetVolume(float nVolume)                         { m_omxPlayerAudio.SetVolume(nVolume); }
+  virtual void SetMute(bool bOnOff)                             { m_omxPlayerAudio.SetMute(bOnOff); }
+  virtual void SetDynamicRangeCompression(long drc)             { m_omxPlayerAudio.SetDynamicRangeCompression(drc); }
+  virtual bool ControlsVolume() {return true;}
+  virtual void GetAudioInfo(CStdString &strAudioInfo);
+  virtual void GetVideoInfo(CStdString &strVideoInfo);
+  virtual void GetGeneralInfo(CStdString &strVideoInfo);
+  virtual void Update(bool bPauseDrawing)                       {}
+  virtual void GetVideoRect(CRect& SrcRect, CRect& DestRect)    { g_renderManager.GetVideoRect(SrcRect, DestRect); }
+  virtual void GetVideoAspectRatio(float& fAR)                  { fAR = m_omxPlayerVideo.GetAspectRatio(); }
+
+  virtual bool CanRecord();
+  virtual bool IsRecording();
+  virtual bool CanPause();
+  virtual bool Record(bool bOnOff);
+  virtual void SetAVDelay(float fValue = 0.0f);
   virtual float GetAVDelay();
 
   virtual void  SetSubTitleDelay(float fValue = 0.0f);
@@ -271,28 +268,25 @@
   virtual void  GetChapterName(CStdString& strChapterName);
   virtual int   SeekChapter(int iChapter);
 
-  virtual void  SeekTime(int64_t iTime = 0);
-  virtual int64_t GetTotalTimeInMsec();
+  virtual void SeekTime(int64_t iTime);
   virtual int64_t GetTime();
   virtual int64_t GetTotalTime();
-  virtual void  ToFFRW(int iSpeed = 0);
-  virtual int   GetAudioBitrate();
-  virtual int   GetVideoBitrate();
-  virtual int   GetSourceBitrate();
-  virtual int   GetChannels();
+  virtual void ToFFRW(int iSpeed);
+  virtual bool OnAction(const CAction &action);
+  virtual bool HasMenu();
+  virtual int GetAudioBitrate();
+  virtual int GetVideoBitrate();
+  virtual int GetSourceBitrate();
+  virtual int GetChannels();
   virtual CStdString GetAudioCodecName();
   virtual CStdString GetVideoCodecName();
   virtual int   GetPictureWidth();
   virtual int   GetPictureHeight();
   virtual bool  GetStreamDetails(CStreamDetails &details);
 
-  virtual bool  IsInMenu() const;
-  virtual bool  HasMenu();
-
   virtual bool  GetCurrentSubtitle(CStdString& strSubtitle);
-  //returns a state that is needed for resuming from a specific time
   virtual CStdString GetPlayerState();
-  virtual bool  SetPlayerState(CStdString state);
+  virtual bool SetPlayerState(CStdString state);
   
   virtual CStdString GetPlayingTitle();
 
@@ -308,23 +302,10 @@
   , CACHESTATE_FLUSH    // temporary state player will choose startup between init or full
   };
 
-  int m_playSpeed;
-  struct SSpeedState
-  {
-    double lastpts;  // holds last display pts during ff/rw operations
-    double lasttime;
-  } m_SpeedState;
-
-  void    HandlePlaySpeed();
-  bool    GetCachingTimes(double& play_left, double& cache_left, double& file_offset);
-  bool    CheckStartCaching(COMXCurrentStream& current);
-  void    SetCaching(ECacheState state);
-  double  GetQueueTime();
-  virtual bool  IsCaching() const                                 { return m_caching == CACHESTATE_FULL; }
+  virtual bool  IsCaching() const                                 { return m_caching == CACHESTATE_FULL || m_caching == CACHESTATE_PVR; }
   virtual int   GetCacheLevel() const;
 
   virtual int  OnDVDNavResult(void* pData, int iMessage);
-  virtual bool OnAction(const CAction &action);
 
   virtual void  GetRenderFeatures(std::vector<int> &renderFeatures);
   virtual void  GetDeinterlaceMethods(std::vector<int> &deinterlaceMethods);
@@ -332,6 +313,23 @@
   virtual void  GetScalingMethods(std::vector<int> &scalingMethods);
   virtual void  GetAudioCapabilities(std::vector<int> &audioCaps);
   virtual void  GetSubtitleCapabilities(std::vector<int> &subCaps);
+
+  /* PLEX */
+  virtual int GetSubtitlePlexID();
+  virtual int GetAudioStreamPlexID();
+  virtual void SetAudioStreamPlexID(int plexID);
+  virtual void SetSubtitleStreamPlexID(int plexID);
+  virtual int GetPlexMediaPartID()
+  {
+    CFileItemPtr part = m_item.m_selectedMediaPart;
+    if (part)
+      return part->GetProperty("id").asInteger();
+
+    return -1;
+  }
+  virtual bool CanOpenAsync() { return false; }
+  virtual void Abort() { m_bAbortRequest = true; }
+  /* END PLEX */
 protected:
   friend class COMXSelectionStreams;
 
@@ -343,19 +341,122 @@
 
   virtual void  OnStartup();
   virtual void  OnExit();
-  bool WaitForPausedThumbJobs(int timeout_ms);
   virtual void  Process();
 
+  bool OpenAudioStream(int iStream, int source, bool reset = true);
+  bool OpenVideoStream(int iStream, int source, bool reset = true);
+  bool OpenSubtitleStream(int iStream, int source);
+  bool OpenTeletextStream(int iStream, int source);
+  bool CloseAudioStream(bool bWaitForBuffers);
+  bool CloseVideoStream(bool bWaitForBuffers);
+  bool CloseSubtitleStream(bool bKeepOverlays);
+  bool CloseTeletextStream(bool bWaitForBuffers);
+
+  void ProcessPacket(CDemuxStream* pStream, DemuxPacket* pPacket);
+  void ProcessAudioData(CDemuxStream* pStream, DemuxPacket* pPacket);
+  void ProcessVideoData(CDemuxStream* pStream, DemuxPacket* pPacket);
+  void ProcessSubData(CDemuxStream* pStream, DemuxPacket* pPacket);
+  void ProcessTeletextData(CDemuxStream* pStream, DemuxPacket* pPacket);
+
+  bool ShowPVRChannelInfo();
+
+  int  AddSubtitleFile(const std::string& filename, const std::string& subfilename = "", CDemuxStream::EFlags flags = CDemuxStream::FLAG_NONE);
+
+  /**
+   * one of the DVD_PLAYSPEED defines
+   */
+  void SetPlaySpeed(int iSpeed);
+  int GetPlaySpeed()                                                { return m_playSpeed; }
+  void    SetCaching(ECacheState state);
+
+  int64_t GetTotalTimeInMsec();
+
+  double  GetQueueTime();
+  bool    GetCachingTimes(double& play_left, double& cache_left, double& file_offset);
+
+
+  void FlushBuffers(bool queued, double pts = DVD_NOPTS_VALUE, bool accurate = true);
+
+
+  void  HandleMessages();
+  void    HandlePlaySpeed();
+  bool  IsInMenu() const;
+
+  void SynchronizePlayers(unsigned int sources);
+  void SynchronizeDemuxer(unsigned int timeout);
+  void CheckAutoSceneSkip();
+  void CheckContinuity(COMXCurrentStream& current, DemuxPacket* pPacket);
+  bool CheckSceneSkip(COMXCurrentStream& current);
+  bool CheckPlayerInit(COMXCurrentStream& current, unsigned int source);
+  bool CheckStartCaching(COMXCurrentStream& current);
+  void UpdateCorrection(DemuxPacket* pkt, double correction);
+  void UpdateTimestamps(COMXCurrentStream& current, DemuxPacket* pPacket);
+  void SendPlayerMessage(CDVDMsg* pMsg, unsigned int target);
+  bool ReadPacket(DemuxPacket*& packet, CDemuxStream*& stream);
+  bool IsValidStream(COMXCurrentStream& stream);
+  bool IsBetterStream(COMXCurrentStream& current, CDemuxStream* stream);
+  bool CheckDelayedChannelEntry(void);
+  bool OpenInputStream();
+  bool OpenDemuxStream();
+  void OpenDefaultStreams(bool reset = true);
+
+  void UpdateApplication(double timeout);
+  void UpdatePlayState(double timeout);
+  double m_UpdateApplication;
+
+  bool m_bAbortRequest;
+
+  /* PLEX */
+  bool m_EndPlaybackRequest;
+  /* END PLEX */
+
   std::string           m_filename; // holds the actual filename
-  CDVDInputStream       *m_pInputStream;
-  CDVDDemux             *m_pDemuxer;
+  std::string  m_mimetype;  // hold a hint to what content file contains (mime type)
+  ECacheState  m_caching;
+  CFileItem    m_item;
+  unsigned int m_iChannelEntryTimeOut;
+
+
+  COMXCurrentStream m_CurrentAudio;
+  COMXCurrentStream m_CurrentVideo;
+  COMXCurrentStream m_CurrentSubtitle;
+  COMXCurrentStream m_CurrentTeletext;
+
+  COMXSelectionStreams m_SelectionStreams;
+
+  int m_playSpeed;
+  struct SSpeedState
+  {
+    double lastpts;  // holds last display pts during ff/rw operations
+    double lasttime;
+  } m_SpeedState;
+
+  int m_errorCount;
+  double m_offset_pts;
+
+  CDVDMessageQueue m_messenger;     // thread messenger
+
+  OMXPlayerVideo m_omxPlayerVideo; // video part
+  OMXPlayerAudio m_omxPlayerAudio; // audio part
+  CDVDPlayerSubtitle m_dvdPlayerSubtitle; // subtitle part
+  CDVDTeletextData m_dvdPlayerTeletext; // teletext part
+
+  CDVDClock m_clock;                // master clock
+  OMXClock m_av_clock;
+
+  bool m_stepped;
+  int m_video_fifo;
+  int m_audio_fifo;
+  double m_last_check_time;         // we periodically check for gpu underrun
+  double m_stamp;                   // last media stamp
+
+  CDVDOverlayContainer m_overlayContainer;
+
+  CDVDInputStream* m_pInputStream;  // input stream for current playing file
+  CDVDDemux* m_pDemuxer;            // demuxer for current playing file
   CDVDDemux*            m_pSubtitleDemuxer;
-  COMXSelectionStreams  m_SelectionStreams;
-  std::string           m_mimetype;
-  COMXCurrentStream     m_CurrentAudio;
-  COMXCurrentStream     m_CurrentVideo;
-  COMXCurrentStream     m_CurrentSubtitle;
-  COMXCurrentStream     m_CurrentTeletext;
+
+  CStdString m_lastSub;
 
   struct SDVDInfo
   {
@@ -439,6 +540,9 @@
   } m_State;
   CCriticalSection m_StateSection;
 
+  CEvent m_ready;
+  CCriticalSection m_critStreamSection; // need to have this lock when switching streams (audio / video)
+
   CEdl m_Edl;
 
   struct SEdlAutoSkipMarkers {
@@ -460,45 +564,19 @@
 
   } m_EdlAutoSkipMarkers;
 
-  bool ShowPVRChannelInfo();
-
-  int  AddSubtitleFile(const std::string& filename, const std::string& subfilename = "", CDemuxStream::EFlags flags = CDemuxStream::FLAG_NONE);
-  virtual void UpdatePlayState(double timeout);
-
-  double m_UpdateApplication;
-
-  void RenderUpdateCallBack(const void *ctx, const CRect &SrcRect, const CRect &DestRect);
-
-private:
-  void FlushBuffers(bool queued, double pts = DVD_NOPTS_VALUE, bool accurate = true);
-
-  CCriticalSection        m_critStreamSection;
-
-  bool                    m_paused;
-  bool                    m_bAbortRequest;
-  CFileItem               m_item;
   CPlayerOptions          m_PlayerOptions;
-  unsigned int            m_iChannelEntryTimeOut;
-
-  std::string             m_lastSub;
-
-  double                  m_offset_pts;
-
-  CDVDMessageQueue        m_messenger;
-
-  OMXClock                m_av_clock;
-  OMXPlayerVideo          m_player_video;
-  OMXPlayerAudio          m_player_audio;
-  CDVDPlayerSubtitle      m_player_subtitle;
-  CDVDTeletextData        m_player_teletext;
 
-  CEvent                  m_ready;
+  /* PLEX */
+  void RelinkPlexStreams();
 
-  float                   m_current_volume;
-  bool                    m_current_mute;
-  bool                    m_change_volume;
-  CDVDOverlayContainer    m_overlayContainer;
-  ECacheState             m_caching;
+  CStdString   m_strError;
+  CFileItemPtr m_itemWithDetails;
+  bool         m_hidingSub;
+  int          m_vobsubToDisplay;
+
+  unsigned int m_readRate;
+  void UpdateReadRate();
+  /* END PLEX */
 
   bool m_HasVideo;
   bool m_HasAudio;
diff -ur a/xbmc/cores/omxplayer/OMXPlayerVideo.cpp b/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
--- a/xbmc/cores/omxplayer/OMXPlayerVideo.cpp	2015-03-12 20:52:41.090096999 +0100
+++ b/xbmc/cores/omxplayer/OMXPlayerVideo.cpp	2015-03-12 20:48:25.166096999 +0100
@@ -44,8 +44,10 @@
 #include "settings/Settings.h"
 #include "cores/VideoRenderers/RenderFormats.h"
 #include "cores/VideoRenderers/RenderFlags.h"
+#include "guilib/GraphicContext.h"
 
 #include "OMXPlayer.h"
+#include "linux/RBP.h"
 
 class COMXMsgVideoCodecChange : public CDVDMsg
 {
@@ -72,7 +74,6 @@
 {
   m_av_clock              = av_clock;
   m_pOverlayContainer     = pOverlayContainer;
-  m_pTempOverlayPicture   = NULL;
   m_open                  = false;
   m_stream_id             = -1;
   m_fFrameRate            = 25.0f;
@@ -81,20 +82,32 @@
   m_stalled               = false;
   m_codecname             = "";
   m_iSubtitleDelay        = 0;
-  m_FlipTimeStamp         = 0.0;
   m_bRenderSubs           = false;
   m_flags                 = 0;
   m_bAllowFullscreen      = false;
   m_iCurrentPts           = DVD_NOPTS_VALUE;
   m_iVideoDelay           = 0;
-  m_droptime              = 0.0;
-  m_dropbase              = 0.0;
-  m_autosync              = 1;
   m_fForcedAspectRatio    = 0.0f;
-  m_messageQueue.SetMaxDataSize(10 * 1024 * 1024);
+  bool small_mem = g_RBP.GetArmMem() < 256;
+#ifdef TARGET_RASPBERRY_PI_1
+  m_messageQueue.SetMaxDataSize(5 * 1024 * 1024);
+#else
+  m_messageQueue.SetMaxDataSize((small_mem ? 10:40) * 1024 * 1024);
+#endif
   m_messageQueue.SetMaxTimeSize(8.0);
 
   m_dst_rect.SetRect(0, 0, 0, 0);
+
+  /* PLEX */
+  g_VideoCachePts = INFINITY;
+  /* END PLEX */
+
+  m_started = false;
+  m_iCurrentPts = DVD_NOPTS_VALUE;
+  m_nextOverlay = DVD_NOPTS_VALUE;
+  m_flush = false;
+  m_view_mode = 0;
+  m_history_valid_pts = 0;
 }
 
 OMXPlayerVideo::~OMXPlayerVideo()
@@ -104,19 +117,12 @@
 
 bool OMXPlayerVideo::OpenStream(CDVDStreamInfo &hints)
 {
-  /*
-  if(IsRunning())
-    CloseStream(false);
-  */
-
   m_hints       = hints;
-  m_Deinterlace = ( g_settings.m_currentVideoSettings.m_DeinterlaceMode == VS_DEINTERLACEMODE_OFF ) ? false : true;
   m_hdmi_clock_sync = (g_guiSettings.GetInt("videoplayer.adjustrefreshrate") != ADJUST_REFRESHRATE_OFF);
   m_started     = false;
   m_flush       = false;
   m_stalled     = m_messageQueue.GetPacketCount(CDVDMsg::DEMUXER_PACKET) == 0;
-  m_autosync    = 1;
-  m_iSleepEndTime = DVD_NOPTS_VALUE;
+  m_nextOverlay = DVD_NOPTS_VALUE;
   // force SetVideoRect to be called initially
   m_dst_rect.SetRect(0, 0, 0, 0);
 
@@ -139,16 +145,9 @@
     Create();
   }
 
-  /*
-  if(!OpenStream(hints, NULL))
-    return false;
-
-  CLog::Log(LOGNOTICE, "Creating video thread");
-  m_messageQueue.Init();
-  Create();
-  */
-
   m_open        = true;
+  m_iCurrentPts = DVD_NOPTS_VALUE;
+  m_nextOverlay = DVD_NOPTS_VALUE;
 
   return true;
 }
@@ -175,18 +174,7 @@
   m_speed         = DVD_PLAYSPEED_NORMAL;
   m_started       = false;
 
-  if (m_pTempOverlayPicture)
-  {
-    CDVDCodecUtils::FreePicture(m_pTempOverlayPicture);
-    m_pTempOverlayPicture = NULL;
-  }
-
-  m_av_clock->Lock();
-  m_av_clock->OMXStop(false);
   m_omxVideo.Close();
-  m_av_clock->HasVideo(false);
-  m_av_clock->OMXReset(false);
-  m_av_clock->UnLock();
 
   if(m_DllBcmHost.IsLoaded())
     m_DllBcmHost.Unload();
@@ -196,8 +184,6 @@
 
 void OMXPlayerVideo::OnStartup()
 {
-  m_iCurrentPts = DVD_NOPTS_VALUE;
-  m_FlipTimeStamp = m_av_clock->GetAbsoluteClock();
 }
 
 void OMXPlayerVideo::OnExit()
@@ -205,6 +191,40 @@
   CLog::Log(LOGNOTICE, "thread end: video_thread");
 }
 
+double OMXPlayerVideo::NextOverlay(double pts)
+{
+  double delta_start, delta_stop, min_delta = DVD_NOPTS_VALUE;
+
+  CSingleLock lock(*m_pOverlayContainer);
+  VecOverlays* pVecOverlays = m_pOverlayContainer->GetOverlays();
+  VecOverlaysIter it = pVecOverlays->begin();
+
+  //Find the minimum time before a subtitle is added or removed
+  while (it != pVecOverlays->end())
+  {
+    CDVDOverlay* pOverlay = *it++;
+    if(!pOverlay->bForced && !m_bRenderSubs)
+      continue;
+
+    double pts2 = pOverlay->bForced ? pts : pts - m_iSubtitleDelay;
+
+    delta_start = pOverlay->iPTSStartTime - pts2;
+    delta_stop = pOverlay->iPTSStopTime - pts2;
+
+    // when currently on screen, we periodically update to allow (limited rate) ASS animation
+    if (delta_start <= 0.0 && delta_stop > 0.0 && (min_delta == DVD_NOPTS_VALUE || DVD_MSEC_TO_TIME(100) < min_delta))
+      min_delta = DVD_MSEC_TO_TIME(100);
+
+    else if (delta_start > 0.0 && (min_delta == DVD_NOPTS_VALUE || delta_start < min_delta))
+      min_delta = delta_start;
+
+    else if (delta_stop > 0.0 && (min_delta == DVD_NOPTS_VALUE || delta_stop < min_delta))
+      min_delta = delta_stop;
+  }
+  return min_delta == DVD_NOPTS_VALUE ? pts+DVD_MSEC_TO_TIME(500) : pts+min_delta;
+}
+
+
 void OMXPlayerVideo::ProcessOverlays(int iGroupId, double pts)
 {
   // remove any overlays that are out of time
@@ -251,114 +271,44 @@
 void OMXPlayerVideo::Output(int iGroupId, double pts, bool bDropPacket)
 {
   if (!g_renderManager.IsStarted()) {
-    CLog::Log(LOGERROR, "%s - renderer not started", __FUNCTION__);
+    CLog::Log(LOGINFO, "%s - renderer not started", __FUNCTION__);
     return;
   }
 
-  // calculate the time we need to delay this picture before displaying
-  double iSleepTime, iClockSleep, iFrameSleep, iPlayingClock, iCurrentClock, iFrameDuration;
-
-  iPlayingClock = m_av_clock->GetClock(iCurrentClock, false); // snapshot current clock
-  iClockSleep = pts - iPlayingClock; //sleep calculated by pts to clock comparison
-  iFrameSleep = m_FlipTimeStamp - iCurrentClock; // sleep calculated by duration of frame
-  iFrameDuration = (double)DVD_TIME_BASE / m_fFrameRate; //pPacket->duration;
-
-  // correct sleep times based on speed
-  if(m_speed)
-  {
-    iClockSleep = iClockSleep * DVD_PLAYSPEED_NORMAL / m_speed;
-    iFrameSleep = iFrameSleep * DVD_PLAYSPEED_NORMAL / abs(m_speed);
-    iFrameDuration = iFrameDuration * DVD_PLAYSPEED_NORMAL / abs(m_speed);
-  }
-  else
-  {
-    iClockSleep = 0;
-    iFrameSleep = 0;
-  }
-
-  // dropping to a very low framerate is not correct (it should not happen at all)
-  iClockSleep = min(iClockSleep, DVD_MSEC_TO_TIME(500));
-  iFrameSleep = min(iFrameSleep, DVD_MSEC_TO_TIME(500));
-
-  if( m_stalled )
-    iSleepTime = iFrameSleep;
-  else
-    iSleepTime = iFrameSleep + (iClockSleep - iFrameSleep) / m_autosync;
-
-  // present the current pts of this frame to user, and include the actual
-  // presentation delay, to allow him to adjust for it
-  if( m_stalled )
-    m_iCurrentPts = DVD_NOPTS_VALUE;
-  else
-    m_iCurrentPts = pts - max(0.0, iSleepTime);
-
-  // timestamp when we think next picture should be displayed based on current duration
-  m_FlipTimeStamp  = iCurrentClock;
-  m_FlipTimeStamp += max(0.0, iSleepTime);
-  m_FlipTimeStamp += iFrameDuration;
-
-  if( m_speed < 0 )
-  {
-    if( iClockSleep < -DVD_MSEC_TO_TIME(200))
-      return;
-  }
-
-  if(bDropPacket)
+  if (CThread::m_bStop)
     return;
 
-#if 0
-  if( m_speed != DVD_PLAYSPEED_NORMAL)
-  {
-    // calculate frame dropping pattern to render at this speed
-    // we do that by deciding if this or next frame is closest
-    // to the flip timestamp
-    double current   = fabs(m_dropbase -  m_droptime);
-    double next      = fabs(m_dropbase - (m_droptime + iFrameDuration));
-    double frametime = (double)DVD_TIME_BASE / m_fFrameRate;
-
-    m_droptime += iFrameDuration;
-#ifndef PROFILE
-    if( next < current /*&& !(pPicture->iFlags & DVP_FLAG_NOSKIP) */)
-      return /*result | EOS_DROPPED*/;
-#endif
+  // we aim to submit subtitles 100ms early
+  const double preroll = DVD_MSEC_TO_TIME(100);
+  double media_pts = m_av_clock->OMXMediaTime();
 
-    while(!m_bStop && m_dropbase < m_droptime)             m_dropbase += frametime;
-    while(!m_bStop && m_dropbase - frametime > m_droptime) m_dropbase -= frametime;
-  }
-  else
-  {
-    m_droptime = 0.0f;
-    m_dropbase = 0.0f;
-  }
-#else
-  m_droptime = 0.0f;
-  m_dropbase = 0.0f;
-#endif
+  if (m_nextOverlay != DVD_NOPTS_VALUE && media_pts + preroll <= m_nextOverlay)
+    return;
 
-  // DVDPlayer sleeps until m_iSleepEndTime here before calling FlipPage.
-  // Video playback in asynchronous in OMXPlayer, so we don't want to do that here, as it prevents the video fifo from being kept full.
-  // So, we keep track of when FlipPage would have been called on DVDPlayer and return early if it is not time.
-  // m_iSleepEndTime == DVD_NOPTS_VALUE means we are not waiting to call FlipPage, otherwise it is the time we want to call FlipPage
-  if (m_iSleepEndTime == DVD_NOPTS_VALUE) {
-    m_iSleepEndTime = iCurrentClock + iSleepTime;
-  }
+  double subtitle_pts = m_nextOverlay;
+  double time = subtitle_pts != DVD_NOPTS_VALUE ? subtitle_pts - media_pts : 0.0;
 
-  if (!CThread::m_bStop && m_av_clock->GetAbsoluteClock(false) < m_iSleepEndTime + DVD_MSEC_TO_TIME(500))
-    return;
+  if (m_nextOverlay != DVD_NOPTS_VALUE)
+    media_pts = m_nextOverlay;
 
-  double pts_media = m_av_clock->OMXMediaTime(false);
-  ProcessOverlays(iGroupId, pts_media);
+  m_nextOverlay = NextOverlay(media_pts);
 
-  g_renderManager.FlipPage(CThread::m_bStop, m_iSleepEndTime / DVD_TIME_BASE, -1, FS_NONE);
+  ProcessOverlays(iGroupId, media_pts);
 
-  m_iSleepEndTime = DVD_NOPTS_VALUE;
+  time += m_av_clock->GetAbsoluteClock();
+  g_renderManager.FlipPage(CThread::m_bStop, time/DVD_TIME_BASE);
+}
 
-  //m_av_clock->WaitAbsoluteClock((iCurrentClock + iSleepTime));
+static unsigned count_bits(int32_t value)
+{
+  unsigned bits = 0;
+  for(;value;++bits)
+    value &= value - 1;
+  return bits;
 }
 
 void OMXPlayerVideo::Process()
 {
-  double pts = 0;
   double frametime = (double)DVD_TIME_BASE / m_fFrameRate;
   bool bRequestDrop = false;
 
@@ -399,39 +349,25 @@
     {
       CDVDMsgGeneralResync* pMsgGeneralResync = (CDVDMsgGeneralResync*)pMsg;
 
-      if(pMsgGeneralResync->m_timestamp != DVD_NOPTS_VALUE)
-        pts = pMsgGeneralResync->m_timestamp;
+      double delay = 0;
 
-      double delay = m_FlipTimeStamp - m_av_clock->GetAbsoluteClock();
-      if( delay > frametime ) delay = frametime;
-      else if( delay < 0 )    delay = 0;
-
-      if(pMsgGeneralResync->m_clock)
+      if(pMsgGeneralResync->m_clock && pMsgGeneralResync->m_timestamp != DVD_NOPTS_VALUE)
       {
-        CLog::Log(LOGDEBUG, "COMXPlayerVideo - CDVDMsg::GENERAL_RESYNC(%f, 1)", pts);
-        m_av_clock->Discontinuity(pts - delay);
-        //m_av_clock->OMXUpdateClock(pts - delay);
+        CLog::Log(LOGDEBUG, "CDVDPlayerVideo - CDVDMsg::GENERAL_RESYNC(%f, %f, 1)", m_iCurrentPts, pMsgGeneralResync->m_timestamp);
+        m_av_clock->Discontinuity(pMsgGeneralResync->m_timestamp - delay);
       }
       else
-        CLog::Log(LOGDEBUG, "COMXPlayerVideo - CDVDMsg::GENERAL_RESYNC(%f, 0)", pts);
+        CLog::Log(LOGDEBUG, "CDVDPlayerVideo - CDVDMsg::GENERAL_RESYNC(%f, 0)", m_iCurrentPts);
 
+      m_nextOverlay = DVD_NOPTS_VALUE;
+      m_iCurrentPts = DVD_NOPTS_VALUE;
       pMsgGeneralResync->Release();
       continue;
     }
     else if (pMsg->IsType(CDVDMsg::GENERAL_DELAY))
     {
-      if (m_speed != DVD_PLAYSPEED_PAUSE)
-      {
-        double timeout = static_cast<CDVDMsgDouble*>(pMsg)->m_value;
-
-        CLog::Log(LOGDEBUG, "COMXPlayerVideo - CDVDMsg::GENERAL_DELAY(%f)", timeout);
-
-        timeout *= (double)DVD_PLAYSPEED_NORMAL / abs(m_speed);
-        timeout += m_av_clock->GetAbsoluteClock();
-
-        while(!m_bStop && m_av_clock->GetAbsoluteClock() < timeout)
-          Sleep(1);
-      }
+      double timeout = static_cast<CDVDMsgDouble*>(pMsg)->m_value;
+      CLog::Log(LOGDEBUG, "COMXPlayerVideo - CDVDMsg::GENERAL_DELAY(%f)", timeout);
     }
     else if (pMsg->IsType(CDVDMsg::VIDEO_SET_ASPECT))
     {
@@ -441,25 +377,19 @@
     else if (pMsg->IsType(CDVDMsg::GENERAL_RESET))
     {
       CLog::Log(LOGDEBUG, "COMXPlayerVideo - CDVDMsg::GENERAL_RESET");
-      m_av_clock->Lock();
-      m_av_clock->OMXStop(false);
       m_omxVideo.Reset();
-      m_av_clock->OMXReset(false);
-      m_av_clock->UnLock();
       m_started = false;
-      m_iSleepEndTime = DVD_NOPTS_VALUE;
+      m_nextOverlay = DVD_NOPTS_VALUE;
+      m_iCurrentPts = DVD_NOPTS_VALUE;
     }
     else if (pMsg->IsType(CDVDMsg::GENERAL_FLUSH)) // private message sent by (COMXPlayerVideo::Flush())
     {
       CLog::Log(LOGDEBUG, "COMXPlayerVideo - CDVDMsg::GENERAL_FLUSH");
       m_stalled = true;
       m_started = false;
-      m_iSleepEndTime = DVD_NOPTS_VALUE;
-      m_av_clock->Lock();
-      m_av_clock->OMXStop(false);
+      m_nextOverlay = DVD_NOPTS_VALUE;
+      m_iCurrentPts = DVD_NOPTS_VALUE;
       m_omxVideo.Reset();
-      m_av_clock->OMXReset(false);
-      m_av_clock->UnLock();
       m_flush = false;
     }
     else if (pMsg->IsType(CDVDMsg::PLAYER_SETSPEED))
@@ -494,8 +424,15 @@
 
       #ifdef _DEBUG
       CLog::Log(LOGINFO, "Video: dts:%.0f pts:%.0f size:%d (s:%d f:%d d:%d l:%d) s:%d %d/%d late:%d\n", pPacket->dts, pPacket->pts, 
-          (int)pPacket->iSize, m_started, m_flush, bPacketDrop, m_stalled, m_speed, 0, 0, m_av_clock->OMXLateCount(1));
+          (int)pPacket->iSize, m_started, m_flush, bPacketDrop, m_stalled, m_speed, 0, 0, 0);
       #endif
+
+      /* PLEX */
+      // if Video is ahead Audio, they yield to other thread
+      if (pPacket->pts > g_AudioCachePts)
+        Sleep(0);
+      /* END PLEX */
+
       if (m_messageQueue.GetDataSize() == 0
       ||  m_speed < 0)
       {
@@ -526,32 +463,21 @@
           m_stalled = false;
         }
 
-        double output_pts = 0;
-        // validate picture timing,
-        // if both dts/pts invalid, use pts calulated from picture.iDuration
-        // if pts invalid use dts, else use picture.pts as passed
-        if (pPacket->dts == DVD_NOPTS_VALUE && pPacket->pts == DVD_NOPTS_VALUE)
-          output_pts = pts;
-        else if (pPacket->pts == DVD_NOPTS_VALUE)
-          output_pts = pts;
-        else
-          output_pts = pPacket->pts;
-
-        if(pPacket->pts != DVD_NOPTS_VALUE)
-          pPacket->pts += m_iVideoDelay;
-
-        if(pPacket->dts != DVD_NOPTS_VALUE)
-          pPacket->dts += m_iVideoDelay;
-
-        if(pPacket->duration == 0)
-          pPacket->duration = frametime;
-
-        if(output_pts != DVD_NOPTS_VALUE)
-          pts = output_pts;
-
-        m_omxVideo.Decode(pPacket->pData, pPacket->iSize, pPacket->dts, pPacket->pts);
-
-        Output(pPacket->iGroupId, output_pts, bRequestDrop);
+        // some packed bitstream AVI files set almost all pts values to DVD_NOPTS_VALUE, but have a scattering of real pts values.
+        // the valid pts values match the dts values.
+        // if a stream has had more than 4 valid pts values in the last 16, the use UNKNOWN, otherwise use dts
+        m_history_valid_pts = (m_history_valid_pts << 1) | (pPacket->pts != DVD_NOPTS_VALUE);
+        double pts = pPacket->pts;
+        if(pPacket->pts == DVD_NOPTS_VALUE && count_bits(m_history_valid_pts & 0xffff) < 4)
+          pts = pPacket->dts;
+
+        if (pts != DVD_NOPTS_VALUE)
+          pts += m_iVideoDelay;
+
+        m_omxVideo.Decode(pPacket->pData, pPacket->iSize, pts);
+        Output(pPacket->iGroupId, pts, bRequestDrop);
+        if(pts != DVD_NOPTS_VALUE)
+          m_iCurrentPts = pts;
 
         if(m_started == false)
         {
@@ -560,16 +486,18 @@
           m_messageParent.Put(new CDVDMsgInt(CDVDMsg::PLAYER_STARTED, DVDPLAYER_VIDEO));
         }
 
-        // guess next frame pts. iDuration is always valid
-        if (m_speed != 0)
-          pts += pPacket->duration * m_speed / abs(m_speed);
-
         break;
       }
 
       bRequestDrop = false;
 
       m_videoStats.AddSampleBytes(pPacket->iSize);
+
+      /* PLEX */
+      // update out position
+      g_VideoCachePts = pPacket->pts;
+      /* END PLEX */
+
     }
     pMsg->Release();
 
@@ -598,14 +526,13 @@
     CLog::Log(LOGINFO, "OMXPlayerVideo::OpenDecoder : Invalid framerate %d, using forced 25fps and just trust timestamps\n", (int)m_fFrameRate);
     m_fFrameRate = 25;
   }
-  // use aspect in stream always
-  m_fForcedAspectRatio = m_hints.aspect;
-
-
-  m_av_clock->Lock();
-  m_av_clock->OMXStop(false);
+  // use aspect in stream if available
+  if (m_hints.forced_aspect)
+    m_fForcedAspectRatio = m_hints.aspect;
+  else
+    m_fForcedAspectRatio = 0.0;
 
-  bool bVideoDecoderOpen = m_omxVideo.Open(m_hints, m_av_clock, m_Deinterlace, m_hdmi_clock_sync);
+  bool bVideoDecoderOpen = m_omxVideo.Open(m_hints, m_av_clock, g_settings.m_currentVideoSettings.m_DeinterlaceMode, m_hdmi_clock_sync);
   m_omxVideo.RegisterResolutionUpdateCallBack((void *)this, ResolutionUpdateCallBack);
 
   if(!bVideoDecoderOpen)
@@ -632,10 +559,8 @@
       m_av_clock->SetRefreshRate(m_fFrameRate);
   }
 
-  m_av_clock->OMXStateExecute(false);
-  m_av_clock->HasVideo(bVideoDecoderOpen);
-  m_av_clock->OMXReset(false);
-  m_av_clock->UnLock();
+  // start from assuming all recent frames had valid pts
+  m_history_valid_pts = ~0;
 
   return bVideoDecoderOpen;
 }
@@ -750,7 +675,7 @@
   player->SetVideoRect(SrcRect, DestRect);
 }
 
-void OMXPlayerVideo::ResolutionUpdateCallBack(uint32_t width, uint32_t height)
+void OMXPlayerVideo::ResolutionUpdateCallBack(uint32_t width, uint32_t height, float display_aspect)
 {
   RESOLUTION res  = g_graphicsContext.GetVideoResolution();
   uint32_t video_width   = g_settings.m_ResInfo[res].iScreenWidth;
@@ -788,6 +713,8 @@
   /* use forced aspect if any */
   if( m_fForcedAspectRatio != 0.0f )
     iDisplayWidth = (int) (iDisplayHeight * m_fForcedAspectRatio);
+  else if( display_aspect != 0.0f )
+    iDisplayWidth = (int) (iDisplayHeight * display_aspect);
 
   CLog::Log(LOGDEBUG,"%s - change configuration. video:%dx%d. framerate: %4.2f. %dx%d format: BYPASS",
       __FUNCTION__, video_width, video_height, m_fFrameRate, iDisplayWidth, iDisplayHeight);
@@ -803,9 +730,9 @@
   g_renderManager.RegisterRenderUpdateCallBack((const void*)this, RenderUpdateCallBack);
 }
 
-void OMXPlayerVideo::ResolutionUpdateCallBack(void *ctx, uint32_t width, uint32_t height)
+void OMXPlayerVideo::ResolutionUpdateCallBack(void *ctx, uint32_t width, uint32_t height, float display_aspect)
 {
   OMXPlayerVideo *player = static_cast<OMXPlayerVideo*>(ctx);
-  player->ResolutionUpdateCallBack(width, height);
+  player->ResolutionUpdateCallBack(width, height, display_aspect);
 }
 
diff -ur a/xbmc/cores/omxplayer/OMXPlayerVideo.h b/xbmc/cores/omxplayer/OMXPlayerVideo.h
--- a/xbmc/cores/omxplayer/OMXPlayerVideo.h	2015-03-12 20:52:41.090096999 +0100
+++ b/xbmc/cores/omxplayer/OMXPlayerVideo.h	2015-03-12 20:48:25.166096999 +0100
@@ -50,23 +50,17 @@
   bool                      m_open;
   CDVDStreamInfo            m_hints;
   double                    m_iCurrentPts;
-  double                    m_iSleepEndTime;
+  double                    m_nextOverlay;
   OMXClock                  *m_av_clock;
   COMXVideo                 m_omxVideo;
   float                     m_fFrameRate;
-  bool                      m_Deinterlace;
   bool                      m_hdmi_clock_sync;
   double                    m_iVideoDelay;
   int                       m_speed;
-  double                    m_FlipTimeStamp; // time stamp of last flippage. used to play at a forced framerate
-  int                       m_audio_count;
   bool                      m_stalled;
   bool                      m_started;
   bool                      m_flush;
   std::string               m_codecname;
-  double                    m_droptime;
-  double                    m_dropbase;
-  unsigned int              m_autosync;
   double                    m_iSubtitleDelay;
   bool                      m_bRenderSubs;
   bool                      m_bAllowFullscreen;
@@ -77,6 +71,7 @@
   CRect                     m_dst_rect;
   int                       m_view_mode;
 
+  uint32_t                  m_history_valid_pts;
   DllBcmHost                m_DllBcmHost;
 
   CDVDOverlayContainer  *m_pOverlayContainer;
@@ -84,9 +79,8 @@
 
   BitstreamStats m_videoStats;
 
-  DVDVideoPicture* m_pTempOverlayPicture;
-
   void ProcessOverlays(int iGroupId, double pts);
+  double NextOverlay(double pts);
 
   virtual void OnStartup();
   virtual void OnExit();
@@ -111,7 +105,7 @@
   bool OpenDecoder();
   int  GetDecoderBufferSize();
   int  GetDecoderFreeSpace();
-  double GetCurrentPTS() { return m_iCurrentPts; };
+  double GetCurrentPts() { return m_iCurrentPts; };
   double GetFPS() { return m_fFrameRate; };
   void  SubmitEOS();
   bool SubmittedEOS();
@@ -131,7 +125,22 @@
   int GetFreeSpace();
   void  SetVideoRect(const CRect &SrcRect, const CRect &DestRect);
   static void RenderUpdateCallBack(const void *ctx, const CRect &SrcRect, const CRect &DestRect);
-  void ResolutionUpdateCallBack(uint32_t width, uint32_t height);
-  static void ResolutionUpdateCallBack(void *ctx, uint32_t width, uint32_t height);
+  void ResolutionUpdateCallBack(uint32_t width, uint32_t height, float pixel_aspect);
+  static void ResolutionUpdateCallBack(void *ctx, uint32_t width, uint32_t height, float pixel_aspect);
+
+  inline int GetCacheLevel()
+  {
+    if (m_omxVideo.GetInputBufferSize() > 0)
+      return 100 - ((100 * m_omxVideo.GetFreeSpace()) / m_omxVideo.GetInputBufferSize());
+    else
+      return 0;
+  }
 };
+
+/* PLEX */
+extern CEvent g_CacheSyncEvent;
+extern double g_VideoCachePts;
+extern double g_AudioCachePts;
+/* END PLEX */
+
 #endif
diff -ur a/xbmc/cores/omxplayer/OMXVideo.cpp b/xbmc/cores/omxplayer/OMXVideo.cpp
--- a/xbmc/cores/omxplayer/OMXVideo.cpp	2015-03-12 20:52:41.090096999 +0100
+++ b/xbmc/cores/omxplayer/OMXVideo.cpp	2015-03-12 20:48:25.166096999 +0100
@@ -34,6 +34,7 @@
 #include "settings/Settings.h"
 #include "utils/BitstreamConverter.h"
 
+#include "linux/RBP.h"
 
 #include <sys/time.h>
 #include <inttypes.h>
@@ -43,20 +44,6 @@
 #endif
 #define CLASSNAME "COMXVideo"
 
-#if 0
-// TODO: These are Nvidia Tegra2 dependent, need to dynamiclly find the
-// right codec matched to video format.
-#define OMX_H264BASE_DECODER    "OMX.Nvidia.h264.decode"
-// OMX.Nvidia.h264ext.decode segfaults, not sure why.
-//#define OMX_H264MAIN_DECODER  "OMX.Nvidia.h264ext.decode"
-#define OMX_H264MAIN_DECODER    "OMX.Nvidia.h264.decode"
-#define OMX_H264HIGH_DECODER    "OMX.Nvidia.h264ext.decode"
-#define OMX_MPEG4_DECODER       "OMX.Nvidia.mp4.decode"
-#define OMX_MPEG4EXT_DECODER    "OMX.Nvidia.mp4ext.decode"
-#define OMX_MPEG2V_DECODER      "OMX.Nvidia.mpeg2v.decode"
-#define OMX_VC1_DECODER         "OMX.Nvidia.vc1.decode"
-#endif
-
 #define OMX_VIDEO_DECODER       "OMX.broadcom.video_decode"
 #define OMX_H264BASE_DECODER    OMX_VIDEO_DECODER
 #define OMX_H264MAIN_DECODER    OMX_VIDEO_DECODER
@@ -79,14 +66,16 @@
 COMXVideo::COMXVideo()
 {
   m_is_open           = false;
-  m_Pause             = false;
   m_extradata         = NULL;
   m_extrasize         = 0;
-  m_video_convert     = false;
-  m_video_codec_name  = "";
   m_deinterlace       = false;
+  m_deinterlace_request = VS_DEINTERLACEMODE_OFF;
   m_hdmi_clock_sync   = false;
   m_submitted_eos     = false;
+  m_failed_eos        = false;
+  m_settings_changed  = false;
+  m_setStartTime      = false;
+  m_transform         = OMX_DISPLAY_ROT0;
 }
 
 COMXVideo::~COMXVideo()
@@ -96,6 +85,7 @@
 
 bool COMXVideo::SendDecoderConfig()
 {
+  CSingleLock lock (m_critSection);
   OMX_ERRORTYPE omx_err   = OMX_ErrorNone;
 
   /* send decoder config */
@@ -131,11 +121,11 @@
   return true;
 }
 
-bool COMXVideo::NaluFormatStartCodes(enum CodecID codec, uint8_t *in_extradata, int in_extrasize)
+bool COMXVideo::NaluFormatStartCodes(enum AVCodecID codec, uint8_t *in_extradata, int in_extrasize)
 {
   switch(codec)
   {
-    case CODEC_ID_H264:
+    case AV_CODEC_ID_H264:
       if (in_extrasize < 7 || in_extradata == NULL)
         return true;
       // valid avcC atom data always starts with the value 1 (version), otherwise annexb
@@ -146,13 +136,210 @@
   return false;    
 }
 
-bool COMXVideo::Open(CDVDStreamInfo &hints, OMXClock *clock, bool deinterlace, bool hdmi_clock_sync)
+bool COMXVideo::PortSettingsChanged()
 {
+  CSingleLock lock (m_critSection);
+  OMX_ERRORTYPE omx_err   = OMX_ErrorNone;
+
+  if (m_settings_changed)
+  {
+    m_omx_decoder.DisablePort(m_omx_decoder.GetOutputPort(), true);
+  }
+
+  OMX_PARAM_PORTDEFINITIONTYPE port_image;
+  OMX_INIT_STRUCTURE(port_image);
+  port_image.nPortIndex = m_omx_decoder.GetOutputPort();
+  omx_err = m_omx_decoder.GetParameter(OMX_IndexParamPortDefinition, &port_image);
+  if(omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - error m_omx_decoder.GetParameter(OMX_IndexParamPortDefinition) omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+  }
+
+  OMX_CONFIG_POINTTYPE pixel_aspect;
+  OMX_INIT_STRUCTURE(pixel_aspect);
+  pixel_aspect.nPortIndex = m_omx_decoder.GetOutputPort();
+  omx_err = m_omx_decoder.GetParameter(OMX_IndexParamBrcmPixelAspectRatio, &pixel_aspect);
+  if(omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - error m_omx_decoder.GetParameter(OMX_IndexParamBrcmPixelAspectRatio) omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+  }
+
+  // let OMXPlayerVideo know about resolution so it can inform RenderManager
+  if (m_res_callback)
+  {
+    float display_aspect = 0.0f;
+    if (pixel_aspect.nX && pixel_aspect.nY)
+      display_aspect = (float)pixel_aspect.nX * port_image.format.video.nFrameWidth /
+        ((float)pixel_aspect.nY * port_image.format.video.nFrameHeight);
+    m_res_callback(m_res_ctx, port_image.format.video.nFrameWidth, port_image.format.video.nFrameHeight, display_aspect);
+  }
+
+  if (m_settings_changed)
+  {
+    m_omx_decoder.EnablePort(m_omx_decoder.GetOutputPort(), true);
+    return true;
+  }
+
+  OMX_CONFIG_INTERLACETYPE interlace;
+  OMX_INIT_STRUCTURE(interlace);
+  interlace.nPortIndex = m_omx_decoder.GetOutputPort();
+  omx_err = m_omx_decoder.GetConfig(OMX_IndexConfigCommonInterlace, &interlace);
+
+  if(m_deinterlace_request == VS_DEINTERLACEMODE_FORCE)
+    m_deinterlace = true;
+  else if(m_deinterlace_request == VS_DEINTERLACEMODE_OFF)
+    m_deinterlace = false;
+  else
+    m_deinterlace = interlace.eMode != OMX_InterlaceProgressive;
+
+  if(!m_omx_render.Initialize("OMX.broadcom.video_render", OMX_IndexParamVideoInit))
+    return false;
+
+  m_omx_render.ResetEos();
+
+  CLog::Log(LOGDEBUG, "%s::%s - %dx%d@%.2f interlace:%d deinterlace:%d", CLASSNAME, __func__,
+      port_image.format.video.nFrameWidth, port_image.format.video.nFrameHeight,
+      port_image.format.video.xFramerate / (float)(1<<16), interlace.eMode, m_deinterlace);
+
+  if(!m_omx_sched.Initialize("OMX.broadcom.video_scheduler", OMX_IndexParamVideoInit))
+    return false;
+
+  if(m_deinterlace)
+  {
+    if(!m_omx_image_fx.Initialize("OMX.broadcom.image_fx", OMX_IndexParamImageInit))
+      return false;
+  }
+
+  OMX_CONFIG_DISPLAYREGIONTYPE configDisplay;
+  OMX_INIT_STRUCTURE(configDisplay);
+  configDisplay.nPortIndex = m_omx_render.GetInputPort();
+
+  configDisplay.set = OMX_DISPLAY_SET_TRANSFORM;
+  configDisplay.transform = m_transform;
+  omx_err = m_omx_render.SetConfig(OMX_IndexConfigDisplayRegion, &configDisplay);
+  if(omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGWARNING, "%s::%s - could not set transform : %d", CLASSNAME, __func__, m_transform);
+    return false;
+  }
+
+  if(m_hdmi_clock_sync)
+  {
+    OMX_CONFIG_LATENCYTARGETTYPE latencyTarget;
+    OMX_INIT_STRUCTURE(latencyTarget);
+    latencyTarget.nPortIndex = m_omx_render.GetInputPort();
+    latencyTarget.bEnabled = OMX_TRUE;
+    latencyTarget.nFilter = 2;
+    latencyTarget.nTarget = 4000;
+    latencyTarget.nShift = 3;
+    latencyTarget.nSpeedFactor = -135;
+    latencyTarget.nInterFactor = 500;
+    latencyTarget.nAdjCap = 20;
+
+    omx_err = m_omx_render.SetConfig(OMX_IndexConfigLatencyTarget, &latencyTarget);
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - OMX_IndexConfigLatencyTarget omx_err(0%08x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+  }
+
+  if(m_deinterlace)
+  {
+    OMX_CONFIG_IMAGEFILTERPARAMSTYPE image_filter;
+    OMX_INIT_STRUCTURE(image_filter);
+
+    image_filter.nPortIndex = m_omx_image_fx.GetOutputPort();
+    image_filter.nNumParams = 1;
+    image_filter.nParams[0] = 3;
+    image_filter.eImageFilter = OMX_ImageFilterDeInterlaceAdvanced;
+
+    omx_err = m_omx_image_fx.SetConfig(OMX_IndexConfigCommonImageFilterParameters, &image_filter);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - OMX_IndexConfigCommonImageFilterParameters omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+  }
+
+  if(m_deinterlace)
+  {
+    m_omx_tunnel_decoder.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_image_fx, m_omx_image_fx.GetInputPort());
+    m_omx_tunnel_image_fx.Initialize(&m_omx_image_fx, m_omx_image_fx.GetOutputPort(), &m_omx_sched, m_omx_sched.GetInputPort());
+  }
+  else
+  {
+    m_omx_tunnel_decoder.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_sched, m_omx_sched.GetInputPort());
+  }
+  m_omx_tunnel_sched.Initialize(&m_omx_sched, m_omx_sched.GetOutputPort(), &m_omx_render, m_omx_render.GetInputPort());
+
+  m_omx_tunnel_clock.Initialize(m_omx_clock, m_omx_clock->GetInputPort()  + 1, &m_omx_sched, m_omx_sched.GetOutputPort()  + 1);
+
+  omx_err = m_omx_tunnel_clock.Establish();
+  if(omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - m_omx_tunnel_clock.Establish omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  omx_err = m_omx_tunnel_decoder.Establish();
+  if(omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - m_omx_tunnel_decoder.Establish omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  if(m_deinterlace)
+  {
+    omx_err = m_omx_tunnel_image_fx.Establish();
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - m_omx_tunnel_image_fx.Establish omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+
+    omx_err = m_omx_image_fx.SetStateForComponent(OMX_StateExecuting);
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - m_omx_image_fx.SetStateForComponent omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+  }
+
+  omx_err = m_omx_tunnel_sched.Establish();
+  if(omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - m_omx_tunnel_sched.Establish omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  omx_err = m_omx_sched.SetStateForComponent(OMX_StateExecuting);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - m_omx_sched.SetStateForComponent omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  omx_err = m_omx_render.SetStateForComponent(OMX_StateExecuting);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - m_omx_render.SetStateForComponent omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  m_settings_changed = true;
+  return true;
+}
+
+bool COMXVideo::Open(CDVDStreamInfo &hints, OMXClock *clock, EDEINTERLACEMODE deinterlace, bool hdmi_clock_sync)
+{
+  CSingleLock lock (m_critSection);
   bool vflip = false;
   Close();
-
   OMX_ERRORTYPE omx_err   = OMX_ErrorNone;
   std::string decoder_name;
+  m_settings_changed = false;
+  m_setStartTime = true;
 
   m_res_ctx           = NULL;
   m_res_callback      = NULL;
@@ -165,6 +352,7 @@
 
   m_hdmi_clock_sync = hdmi_clock_sync;
   m_submitted_eos = false;
+  m_failed_eos    = false;
 
   if(!m_decoded_width || !m_decoded_height)
     return false;
@@ -178,7 +366,7 @@
 
   switch (hints.codec)
   {
-    case CODEC_ID_H264:
+    case AV_CODEC_ID_H264:
     {
       switch(hints.profile)
       {
@@ -214,84 +402,66 @@
           m_video_codec_name = "omx-h264";
           break;
       }
-
-      /* check interlaced */
-      if(m_extrasize > 9 && m_extradata[0] == 1)
-      {
-        CBitstreamConverter converter;
-        converter.Open(hints.codec, (uint8_t *)hints.extradata, hints.extrasize, true);
-
-        int32_t  max_ref_frames = 0;
-        uint8_t  *spc = m_extradata + 6;
-        uint32_t sps_size = BS_RB16(spc);
-        bool     interlaced = true;
-        if (sps_size)
-          converter.parseh264_sps(spc+3, sps_size-1, &interlaced, &max_ref_frames);
-        if(!interlaced && deinterlace)
-          deinterlace = false;
-
-        converter.Close();
-      }
     }
     break;
-    case CODEC_ID_MPEG4:
+    case AV_CODEC_ID_MPEG4:
       // (role name) video_decoder.mpeg4
       // MPEG-4, DivX 4/5 and Xvid compatible
       decoder_name = OMX_MPEG4_DECODER;
       m_codingType = OMX_VIDEO_CodingMPEG4;
       m_video_codec_name = "omx-mpeg4";
       break;
-    case CODEC_ID_MPEG1VIDEO:
-    case CODEC_ID_MPEG2VIDEO:
+    case AV_CODEC_ID_MPEG1VIDEO:
+    case AV_CODEC_ID_MPEG2VIDEO:
       // (role name) video_decoder.mpeg2
       // MPEG-2
       decoder_name = OMX_MPEG2V_DECODER;
       m_codingType = OMX_VIDEO_CodingMPEG2;
       m_video_codec_name = "omx-mpeg2";
       break;
-    case CODEC_ID_H263:
+    case AV_CODEC_ID_H263:
       // (role name) video_decoder.mpeg4
       // MPEG-4, DivX 4/5 and Xvid compatible
       decoder_name = OMX_MPEG4_DECODER;
       m_codingType = OMX_VIDEO_CodingMPEG4;
       m_video_codec_name = "omx-h263";
       break;
-    case CODEC_ID_VP6:
+    case AV_CODEC_ID_VP6:
       // this form is encoded upside down
       vflip = true;
       // fall through
-    case CODEC_ID_VP6F:
-    case CODEC_ID_VP6A:
+    case AV_CODEC_ID_VP6F:
+    case AV_CODEC_ID_VP6A:
       // (role name) video_decoder.vp6
       // VP6
       decoder_name = OMX_VP6_DECODER;
       m_codingType = OMX_VIDEO_CodingVP6;
       m_video_codec_name = "omx-vp6";
     break;
-    case CODEC_ID_VP8:
+    case AV_CODEC_ID_VP8:
       // (role name) video_decoder.vp8
       // VP8
       decoder_name = OMX_VP8_DECODER;
       m_codingType = OMX_VIDEO_CodingVP8;
       m_video_codec_name = "omx-vp8";
     break;
-    case CODEC_ID_THEORA:
+    case AV_CODEC_ID_THEORA:
       // (role name) video_decoder.theora
       // theora
       decoder_name = OMX_THEORA_DECODER;
       m_codingType = OMX_VIDEO_CodingTheora;
       m_video_codec_name = "omx-theora";
     break;
-    case CODEC_ID_MJPEG:
-    case CODEC_ID_MJPEGB:
+    case AV_CODEC_ID_MJPEG:
+    case AV_CODEC_ID_MJPEGB:
       // (role name) video_decoder.mjpg
       // mjpg
       decoder_name = OMX_MJPEG_DECODER;
       m_codingType = OMX_VIDEO_CodingMJPEG;
       m_video_codec_name = "omx-mjpeg";
     break;
-    case CODEC_ID_VC1:
-    case CODEC_ID_WMV3:
+    case AV_CODEC_ID_VC1:
+    case AV_CODEC_ID_WMV3:
       // (role name) video_decoder.vc1
       // VC-1, WMV9
       decoder_name = OMX_VC1_DECODER;
@@ -299,69 +469,14 @@
       m_video_codec_name = "omx-vc1";
       break;
     default:
+      CLog::Log(LOGERROR, "COMXVideo::Open : Video codec unknown: %x", hints.codec);
       return false;
     break;
   }
+  m_deinterlace_request = deinterlace;
 
-  /* enable deintelace on SD and 1080i */
-  if(m_decoded_width <= 720 && m_decoded_height <=576 && deinterlace)
-    m_deinterlace = deinterlace;
-  else if(m_decoded_width >= 1920 && m_decoded_height >= 540 && deinterlace)
-    m_deinterlace = deinterlace;
-
-  if(m_deinterlace)
-    CLog::Log(LOGDEBUG, "COMXVideo::Open : enable deinterlace\n");
-
-  std::string componentName = "";
-
-  componentName = decoder_name;
-  if(!m_omx_decoder.Initialize((const std::string)componentName, OMX_IndexParamVideoInit))
-    return false;
-
-  componentName = "OMX.broadcom.video_render";
-  if(!m_omx_render.Initialize((const std::string)componentName, OMX_IndexParamVideoInit))
-    return false;
-
-  m_omx_render.ResetEos();
-
-  componentName = "OMX.broadcom.video_scheduler";
-  if(!m_omx_sched.Initialize((const std::string)componentName, OMX_IndexParamVideoInit))
-    return false;
-
-  if(m_deinterlace)
-  {
-    componentName = "OMX.broadcom.image_fx";
-    if(!m_omx_image_fx.Initialize((const std::string)componentName, OMX_IndexParamImageInit))
-      return false;
-  }
-
-  OMX_VIDEO_PARAM_PORTFORMATTYPE formatType;
-  /*
-  OMX_INIT_STRUCTURE(formatType);
-  formatType.nPortIndex = m_omx_decoder.GetInputPort();
-  OMX_U32 nIndex = 1;
-  bool bFound = false;
-
-  omx_err = OMX_ErrorNone;
-  do
-  {
-    formatType.nIndex = nIndex;
-    omx_err = m_omx_decoder.GetParameter(OMX_IndexParamVideoPortFormat, &formatType);
-    if(formatType.eCompressionFormat == m_codingType)
-    {
-      bFound = true;
-      break;
-    }
-    nIndex++;
-  }
-  while(omx_err == OMX_ErrorNone);
-
-  if(!bFound)
-  {
-    CLog::Log(LOGINFO, "COMXVideo::Open coding : %s not supported\n", m_video_codec_name.c_str());
+  if(!m_omx_decoder.Initialize(decoder_name, OMX_IndexParamVideoInit))
     return false;
-  }
-  */
 
   if(clock == NULL)
     return false;
@@ -376,26 +491,6 @@
     return false;
   }
 
-  if(m_deinterlace)
-  {
-    m_omx_tunnel_decoder.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_image_fx, m_omx_image_fx.GetInputPort());
-    m_omx_tunnel_image_fx.Initialize(&m_omx_image_fx, m_omx_image_fx.GetOutputPort(), &m_omx_sched, m_omx_sched.GetInputPort());
-  }
-  else
-  {
-    m_omx_tunnel_decoder.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_sched, m_omx_sched.GetInputPort());
-  }
-  m_omx_tunnel_sched.Initialize(&m_omx_sched, m_omx_sched.GetOutputPort(), &m_omx_render, m_omx_render.GetInputPort());
-
-  m_omx_tunnel_clock.Initialize(m_omx_clock, m_omx_clock->GetInputPort()  + 1, &m_omx_sched, m_omx_sched.GetOutputPort()  + 1);
-
-  omx_err = m_omx_tunnel_clock.Establish(false);
-  if(omx_err != OMX_ErrorNone)
-  {
-    CLog::Log(LOGERROR, "COMXVideo::Open m_omx_tunnel_clock.Establish\n");
-    return false;
-  }
-
   omx_err = m_omx_decoder.SetStateForComponent(OMX_StateIdle);
   if (omx_err != OMX_ErrorNone)
   {
@@ -403,6 +498,7 @@
     return false;
   }
 
+  OMX_VIDEO_PARAM_PORTFORMATTYPE formatType;
   OMX_INIT_STRUCTURE(formatType);
   formatType.nPortIndex = m_omx_decoder.GetInputPort();
   formatType.eCompressionFormat = m_codingType;
@@ -432,8 +528,8 @@
   }
 
   portParam.nPortIndex = m_omx_decoder.GetInputPort();
-  portParam.nBufferCountActual = VIDEO_BUFFERS;
-
+  bool small_mem = g_RBP.GetArmMem() < 256;
+  portParam.nBufferCountActual = small_mem ? VIDEO_BUFFERS:2*VIDEO_BUFFERS;
   portParam.format.video.nFrameWidth  = m_decoded_width;
   portParam.format.video.nFrameHeight = m_decoded_height;
 
@@ -444,6 +540,20 @@
     return false;
   }
 
+  // request portsettingschanged on aspect ratio change
+  OMX_CONFIG_REQUESTCALLBACKTYPE notifications;
+  OMX_INIT_STRUCTURE(notifications);
+  notifications.nPortIndex = m_omx_decoder.GetOutputPort();
+  notifications.nIndex = OMX_IndexParamBrcmPixelAspectRatio;
+  notifications.bEnable = OMX_TRUE;
+
+  omx_err = m_omx_decoder.SetParameter((OMX_INDEXTYPE)OMX_IndexConfigRequestCallback, &notifications);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "COMXVideo::Open OMX_IndexConfigRequestCallback error (0%08x)\n", omx_err);
+    return false;
+  }
+
   OMX_PARAM_BRCMVIDEODECODEERRORCONCEALMENTTYPE concanParam;
   OMX_INIT_STRUCTURE(concanParam);
   if(g_advancedSettings.m_omxDecodeStartWithValidFrame)
@@ -458,7 +568,7 @@
     return false;
   }
 
-  if (m_deinterlace)
+  if (m_deinterlace_request != VS_DEINTERLACEMODE_OFF)
   {
     // the deinterlace component requires 3 additional video buffers in addition to the DPB (this is normally 2).
     OMX_PARAM_U32TYPE extra_buffers;
@@ -473,6 +583,7 @@
     }
   }
 
+
   // broadcom omx entension:
   // When enabled, the timestamp fifo mode will change the way incoming timestamps are associated with output images.
   // In this mode the incoming timestamps get used without re-ordering on output images.
@@ -505,26 +616,6 @@
     }
   }
 
-  if(m_hdmi_clock_sync)
-  {
-    OMX_CONFIG_LATENCYTARGETTYPE latencyTarget;
-    OMX_INIT_STRUCTURE(latencyTarget);
-    latencyTarget.nPortIndex = m_omx_render.GetInputPort();
-    latencyTarget.bEnabled = OMX_TRUE;
-    latencyTarget.nFilter = 2;
-    latencyTarget.nTarget = 4000;
-    latencyTarget.nShift = 3;
-    latencyTarget.nSpeedFactor = -135;
-    latencyTarget.nInterFactor = 500;
-    latencyTarget.nAdjCap = 20;
-
-    omx_err = m_omx_render.SetConfig(OMX_IndexConfigLatencyTarget, &latencyTarget);
-    if (omx_err != OMX_ErrorNone)
-    {
-      CLog::Log(LOGERROR, "COMXVideo::Open OMX_IndexConfigLatencyTarget error (0%08x)\n", omx_err);
-      return false;
-    }
-  }
 
   // Alloc buffers for the omx intput port.
   omx_err = m_omx_decoder.AllocInputBuffers();
@@ -534,13 +625,6 @@
     return false;
   }
 
-  omx_err = m_omx_tunnel_decoder.Establish(false);
-  if(omx_err != OMX_ErrorNone)
-  {
-    CLog::Log(LOGERROR, "COMXVideo::Open m_omx_tunnel_decoder.Establish\n");
-    return false;
-  }
-
   omx_err = m_omx_decoder.SetStateForComponent(OMX_StateExecuting);
   if (omx_err != OMX_ErrorNone)
   {
@@ -548,152 +632,29 @@
     return false;
   }
 
-  if(m_deinterlace)
-  {
-    OMX_CONFIG_IMAGEFILTERPARAMSTYPE image_filter;
-    OMX_INIT_STRUCTURE(image_filter);
-
-    image_filter.nPortIndex = m_omx_image_fx.GetOutputPort();
-    image_filter.nNumParams = 1;
-    image_filter.nParams[0] = 3;
-    image_filter.eImageFilter = OMX_ImageFilterDeInterlaceAdvanced;
-
-    omx_err = m_omx_image_fx.SetConfig(OMX_IndexConfigCommonImageFilterParameters, &image_filter);
-    if(omx_err != OMX_ErrorNone)
-    {
-      CLog::Log(LOGERROR, "COMXVideo::Open error OMX_IndexConfigCommonImageFilterParameters omx_err(0x%08x)\n", omx_err);
-      return false;
-    }
-
-    omx_err = m_omx_tunnel_image_fx.Establish(false);
-    if(omx_err != OMX_ErrorNone)
-    {
-      CLog::Log(LOGERROR, "COMXVideo::Open m_omx_tunnel_image_fx.Establish\n");
-      return false;
-    }
-
-    omx_err = m_omx_image_fx.SetStateForComponent(OMX_StateExecuting);
-    if (omx_err != OMX_ErrorNone)
-    {
-      CLog::Log(LOGERROR, "COMXVideo::Open error m_omx_image_fx.SetStateForComponent\n");
-      return false;
-    }
-
-    m_omx_image_fx.DisablePort(m_omx_image_fx.GetInputPort(), false);
-    m_omx_image_fx.DisablePort(m_omx_image_fx.GetOutputPort(), false);
-  }
-
-  omx_err = m_omx_tunnel_sched.Establish(false);
-  if(omx_err != OMX_ErrorNone)
-  {
-    CLog::Log(LOGERROR, "COMXVideo::Open m_omx_tunnel_sched.Establish\n");
-    return false;
-  }
-
-  omx_err = m_omx_sched.SetStateForComponent(OMX_StateExecuting);
-  if (omx_err != OMX_ErrorNone)
-  {
-    CLog::Log(LOGERROR, "COMXVideo::Open error m_omx_sched.SetStateForComponent\n");
-    return false;
-  }
-
-  omx_err = m_omx_render.SetStateForComponent(OMX_StateExecuting);
-  if (omx_err != OMX_ErrorNone)
-  {
-    CLog::Log(LOGERROR, "COMXVideo::Open error m_omx_render.SetStateForComponent\n");
-    return false;
-  }
-
   if(!SendDecoderConfig())
     return false;
 
   m_is_open           = true;
   m_drop_state        = false;
 
-  OMX_CONFIG_DISPLAYREGIONTYPE configDisplay;
-  OMX_INIT_STRUCTURE(configDisplay);
-  configDisplay.nPortIndex = m_omx_render.GetInputPort();
-
-  configDisplay.set = OMX_DISPLAY_SET_TRANSFORM;
-
   switch(hints.orientation)
   {
     case 90:
-      configDisplay.transform = OMX_DISPLAY_ROT90;
+      m_transform = OMX_DISPLAY_ROT90;
       break;
     case 180:
-      configDisplay.transform = OMX_DISPLAY_ROT180;
+      m_transform = OMX_DISPLAY_ROT180;
       break;
     case 270:
-      configDisplay.transform = OMX_DISPLAY_ROT270;
+      m_transform = OMX_DISPLAY_ROT270;
       break;
     default:
-      configDisplay.transform = OMX_DISPLAY_ROT0;
+      m_transform = OMX_DISPLAY_ROT0;
       break;
   }
   if (vflip)
-      configDisplay.transform = OMX_DISPLAY_MIRROR_ROT180;
-
-  omx_err = m_omx_render.SetConfig(OMX_IndexConfigDisplayRegion, &configDisplay);
-  if(omx_err != OMX_ErrorNone)
-  {
-    CLog::Log(LOGWARNING, "COMXVideo::Open could not set orientation : %d\n", hints.orientation);
-  }
-
-  /*
-  configDisplay.set     = OMX_DISPLAY_SET_LAYER;
-  configDisplay.layer   = 2;
-
-  omx_err = m_omx_render.SetConfig(OMX_IndexConfigDisplayRegion, &configDisplay);
-  if(omx_err != OMX_ErrorNone)
-    return false;
-
-  configDisplay.set     = OMX_DISPLAY_SET_DEST_RECT;
-  configDisplay.dest_rect.x_offset  = 100;
-  configDisplay.dest_rect.y_offset  = 100;
-  configDisplay.dest_rect.width     = 640;
-  configDisplay.dest_rect.height    = 480;
-    
-  omx_err = m_omx_render.SetConfig(OMX_IndexConfigDisplayRegion, &configDisplay);
-  if(omx_err != OMX_ErrorNone)
-    return false;
-
-  configDisplay.set     = OMX_DISPLAY_SET_TRANSFORM;
-  configDisplay.transform = OMX_DISPLAY_ROT180;
-    
-  omx_err = m_omx_render.SetConfig(OMX_IndexConfigDisplayRegion, &configDisplay);
-  if(omx_err != OMX_ErrorNone)
-    return false;
-
-  configDisplay.set     = OMX_DISPLAY_SET_FULLSCREEN;
-  configDisplay.fullscreen = OMX_FALSE;
-    
-  omx_err = m_omx_render.SetConfig(OMX_IndexConfigDisplayRegion, &configDisplay);
-  if(omx_err != OMX_ErrorNone)
-    return false;
-
-  configDisplay.set     = OMX_DISPLAY_SET_MODE;
-  configDisplay.mode    = OMX_DISPLAY_MODE_FILL; //OMX_DISPLAY_MODE_LETTERBOX;
-    
-  omx_err = m_omx_render.SetConfig(OMX_IndexConfigDisplayRegion, &configDisplay);
-  if(omx_err != OMX_ErrorNone)
-    return false;
-
-  configDisplay.set     = OMX_DISPLAY_SET_LAYER;
-  configDisplay.layer   = 1;
-
-  omx_err = m_omx_render.SetConfig(OMX_IndexConfigDisplayRegion, &configDisplay);
-  if(omx_err != OMX_ErrorNone)
-    return false;
-
-  configDisplay.set     = OMX_DISPLAY_SET_ALPHA;
-  configDisplay.alpha   = OMX_FALSE;
-    
-  omx_err = m_omx_render.SetConfig(OMX_IndexConfigDisplayRegion, &configDisplay);
-  if(omx_err != OMX_ErrorNone)
-    return false;
-
-  */
+      m_transform = OMX_DISPLAY_MIRROR_ROT180;
 
   if(m_omx_decoder.BadState())
     return false;
@@ -701,22 +662,15 @@
   CLog::Log(LOGDEBUG,
     "%s::%s - decoder_component(0x%p), input_port(0x%x), output_port(0x%x) deinterlace %d hdmiclocksync %d\n",
     CLASSNAME, __func__, m_omx_decoder.GetComponent(), m_omx_decoder.GetInputPort(), m_omx_decoder.GetOutputPort(),
-    m_deinterlace, m_hdmi_clock_sync);
-
-  // start from assuming all recent frames had valid pts
-  m_history_valid_pts = ~0;
+    m_deinterlace_request, m_hdmi_clock_sync);
 
   return true;
 }
 
+
 void COMXVideo::Close()
 {
-  m_omx_tunnel_decoder.Flush();
-  if(m_deinterlace)
-    m_omx_tunnel_image_fx.Flush();
-  m_omx_tunnel_clock.Flush();
-  m_omx_tunnel_sched.Flush();
-
+  CSingleLock lock (m_critSection);
   m_omx_tunnel_clock.Deestablish();
   m_omx_tunnel_decoder.Deestablish();
   if(m_deinterlace)
@@ -725,11 +679,11 @@
 
   m_omx_decoder.FlushInput();
 
-  m_omx_sched.Deinitialize(true);
-  m_omx_decoder.Deinitialize(true);
+  m_omx_sched.Deinitialize();
+  m_omx_decoder.Deinitialize();
   if(m_deinterlace)
-    m_omx_image_fx.Deinitialize(true);
-  m_omx_render.Deinitialize(true);
+    m_omx_image_fx.Deinitialize();
+  m_omx_render.Deinitialize();
 
   m_is_open       = false;
 
@@ -738,7 +692,6 @@
   m_extradata = NULL;
   m_extrasize = 0;
 
-  m_video_convert     = false;
   m_video_codec_name  = "";
   m_deinterlace       = false;
   m_av_clock          = NULL;
@@ -754,27 +707,22 @@
 
 unsigned int COMXVideo::GetFreeSpace()
 {
+  CSingleLock lock (m_critSection);
   return m_omx_decoder.GetInputBufferSpace();
 }
 
 unsigned int COMXVideo::GetSize()
 {
+  CSingleLock lock (m_critSection);
   return m_omx_decoder.GetInputBufferSize();
 }
 
-static unsigned count_bits(int32_t value)
-{
-  unsigned bits = 0;
-  for(;value;++bits)
-    value &= value - 1;
-  return bits;
-}
-
-int COMXVideo::Decode(uint8_t *pData, int iSize, double dts, double pts)
+int COMXVideo::Decode(uint8_t *pData, int iSize, double pts)
 {
+  CSingleLock lock (m_critSection);
   OMX_ERRORTYPE omx_err;
 
-  if( m_drop_state )
+  if( m_drop_state || !m_is_open )
     return true;
 
   unsigned int demuxer_bytes = (unsigned int)iSize;
@@ -792,33 +740,14 @@
         return false;
       }
 
-      /*
-      CLog::Log(DEBUG, "COMXVideo::Video VDec : pts %lld omx_buffer 0x%08x buffer 0x%08x number %d\n", 
-          pts, omx_buffer, omx_buffer->pBuffer, (int)omx_buffer->pAppPrivate);
-      if(pts == DVD_NOPTS_VALUE)
-      {
-        CLog::Log(LOGDEBUG, "VDec : pts %f omx_buffer 0x%08x buffer 0x%08x number %d\n", 
-          (float)pts / AV_TIME_BASE, (int)omx_buffer, (int)omx_buffer->pBuffer, (int)omx_buffer->pAppPrivate);
-      }
-      */
-
       omx_buffer->nFlags = 0;
       omx_buffer->nOffset = 0;
-      // some packed bitstream AVI files set almost all pts values to DVD_NOPTS_VALUE, but have a scattering of real pts values.
-      // the valid pts values match the dts values.
-      // if a stream has had more than 4 valid pts values in the last 16, the use UNKNOWN, otherwise use dts
-      m_history_valid_pts = (m_history_valid_pts << 1) | (pts != DVD_NOPTS_VALUE);
-      if(pts == DVD_NOPTS_VALUE && count_bits(m_history_valid_pts & 0xffff) < 4)
-        pts = dts;
 
-      if(m_av_clock->VideoStart())
+      if(m_setStartTime)
       {
-        // only send dts on first frame to get nearly correct starttime
-        if(pts == DVD_NOPTS_VALUE)
-          pts = dts;
         omx_buffer->nFlags |= OMX_BUFFERFLAG_STARTTIME;
         CLog::Log(LOGDEBUG, "OMXVideo::Decode VDec : setStartTime %f\n", (pts == DVD_NOPTS_VALUE ? 0.0 : pts) / DVD_TIME_BASE);
-        m_av_clock->VideoStart(false);
+        m_setStartTime = false;
       }
       if(pts == DVD_NOPTS_VALUE)
         omx_buffer->nFlags |= OMX_BUFFERFLAG_TIME_UNKNOWN;
@@ -849,7 +778,7 @@
         }
         if(nRetry == 5)
         {
-          CLog::Log(LOGERROR, "%s::%s - OMX_EmptyThisBuffer() finaly failed\n", CLASSNAME, __func__);
+          CLog::Log(LOGERROR, "%s::%s - OMX_EmptyThisBuffer() finally failed\n", CLASSNAME, __func__);
           return false;
         }
       }
@@ -857,74 +786,21 @@
       omx_err = m_omx_decoder.WaitForEvent(OMX_EventPortSettingsChanged, 0);
       if (omx_err == OMX_ErrorNone)
       {
-        OMX_PARAM_PORTDEFINITIONTYPE port_image;
-        OMX_INIT_STRUCTURE(port_image);
-        port_image.nPortIndex = m_omx_decoder.GetOutputPort();
-        omx_err = m_omx_decoder.GetParameter(OMX_IndexParamPortDefinition, &port_image);
-        if(omx_err != OMX_ErrorNone)
-        {
-          CLog::Log(LOGERROR, "%s::%s - error m_omx_decoder.GetParameter(OMX_IndexParamPortDefinition) omx_err(0x%08x)\n", CLASSNAME, __func__, omx_err);
-        }
-        // let OMXPlayerVideo know about resolution so it can inform RenderManager
-        if (m_res_callback)
-          m_res_callback(m_res_ctx, port_image.format.video.nFrameWidth, port_image.format.video.nFrameHeight);
-
-        m_omx_decoder.DisablePort(m_omx_decoder.GetOutputPort(), true);
-        m_omx_sched.DisablePort(m_omx_sched.GetInputPort(), true);
-
-        OMX_CONFIG_INTERLACETYPE interlace;
-        OMX_INIT_STRUCTURE(interlace);
-        interlace.nPortIndex = m_omx_decoder.GetOutputPort();
-        omx_err = m_omx_decoder.GetConfig(OMX_IndexConfigCommonInterlace, &interlace);
-        if(omx_err != OMX_ErrorNone)
-        {
-          CLog::Log(LOGERROR, "%s::%s - error m_omx_decoder.GetConfig(OMX_IndexConfigCommonInterlace) omx_err(0x%08x)\n", CLASSNAME, __func__, omx_err);
-        }
-
-        if (m_deinterlace)
+        if(!PortSettingsChanged())
         {
-          m_omx_image_fx.DisablePort(m_omx_image_fx.GetInputPort(), true);
-          port_image.nPortIndex = m_omx_image_fx.GetInputPort();
-          omx_err = m_omx_image_fx.SetParameter(OMX_IndexParamPortDefinition, &port_image);
-          if(omx_err != OMX_ErrorNone)
-          {
-            CLog::Log(LOGERROR, "%s::%s - error m_omx_image_fx.SetParameter(OMX_IndexParamPortDefinition) omx_err(0x%08x)\n", CLASSNAME, __func__, omx_err);
-          }
-          omx_err = m_omx_image_fx.WaitForEvent(OMX_EventPortSettingsChanged);
-          if(omx_err != OMX_ErrorNone)
-          {
-             CLog::Log(LOGERROR, "%s::%s - error m_omx_image_fx.WaitForEvent(OMX_EventPortSettingsChanged) omx_err(0x%08x)\n", CLASSNAME, __func__, omx_err);
-          }
-          port_image.nPortIndex = m_omx_image_fx.GetOutputPort();
-          omx_err = m_omx_image_fx.GetParameter(OMX_IndexParamPortDefinition, &port_image);
-          if(omx_err != OMX_ErrorNone)
-          {
-            CLog::Log(LOGERROR, "%s::%s - error m_omx_image_fx.GetParameter(OMX_IndexParamPortDefinition) omx_err(0x%08x)\n", CLASSNAME, __func__, omx_err);
-          }
-          m_omx_image_fx.EnablePort(m_omx_image_fx.GetInputPort(), true);
-
-          m_omx_image_fx.DisablePort(m_omx_image_fx.GetOutputPort(), true);
-        }
-        port_image.nPortIndex = m_omx_sched.GetInputPort();
-        omx_err = m_omx_sched.SetParameter(OMX_IndexParamPortDefinition, &port_image);
-        if(omx_err != OMX_ErrorNone)
-        {
-          CLog::Log(LOGERROR, "%s::%s - error m_omx_sched.SetParameter(OMX_IndexParamPortDefinition) omx_err(0x%08x)\n", CLASSNAME, __func__, omx_err);
-        }
-        omx_err = m_omx_sched.WaitForEvent(OMX_EventPortSettingsChanged);
-        if(omx_err != OMX_ErrorNone)
-        {
-           CLog::Log(LOGERROR, "%s::%s - error m_omx_sched.WaitForEvent(OMX_EventPortSettingsChanged) omx_err(0x%08x)\n", CLASSNAME, __func__, omx_err);
+          CLog::Log(LOGERROR, "%s::%s - error PortSettingsChanged omx_err(0x%08x)\n", CLASSNAME, __func__, omx_err);
+          return false;
         }
-        if (m_deinterlace)
+      }
+      omx_err = m_omx_decoder.WaitForEvent(OMX_EventParamOrConfigChanged, 0);
+      if (omx_err == OMX_ErrorNone)
+      {
+        if(!PortSettingsChanged())
         {
-          m_omx_image_fx.EnablePort(m_omx_image_fx.GetOutputPort(), true);
+          CLog::Log(LOGERROR, "%s::%s - error PortSettingsChanged (EventParamOrConfigChanged) omx_err(0x%08x)\n", CLASSNAME, __func__, omx_err);
         }
-        m_omx_decoder.EnablePort(m_omx_decoder.GetOutputPort(), true);
-        m_omx_sched.EnablePort(m_omx_sched.GetInputPort(), true);
       }
     }
-
     return true;
 
   }
@@ -934,78 +810,24 @@
 
 void COMXVideo::Reset(void)
 {
+  CSingleLock lock (m_critSection);
   if(!m_is_open)
     return;
 
+  m_setStartTime = true;
   m_omx_decoder.FlushInput();
-  m_omx_tunnel_decoder.Flush();
-
-  /*
-  OMX_ERRORTYPE omx_err;
-  OMX_CONFIG_BOOLEANTYPE configBool;
-  OMX_INIT_STRUCTURE(configBool);
-  configBool.bEnabled = OMX_TRUE;
-
-  omx_err = m_omx_decoder.SetConfig(OMX_IndexConfigRefreshCodec, &configBool);
-  if (omx_err != OMX_ErrorNone)
-    CLog::Log(LOGERROR, "%s::%s - error reopen codec omx_err(0x%08x)\n", CLASSNAME, __func__, omx_err);
-
-  SendDecoderConfig();
-
-  */
-}
-
-///////////////////////////////////////////////////////////////////////////////////////////
-bool COMXVideo::Pause()
-{
-  if(m_omx_render.GetComponent() == NULL)
-    return false;
-
-  if(m_Pause) return true;
-  m_Pause = true;
-
-  m_omx_sched.SetStateForComponent(OMX_StatePause);
-  m_omx_render.SetStateForComponent(OMX_StatePause);
-
-  return true;
-}
-
-///////////////////////////////////////////////////////////////////////////////////////////
-bool COMXVideo::Resume()
-{
-  if(m_omx_render.GetComponent() == NULL)
-    return false;
-
-  if(!m_Pause) return true;
-  m_Pause = false;
-
-  m_omx_sched.SetStateForComponent(OMX_StateExecuting);
-  m_omx_render.SetStateForComponent(OMX_StateExecuting);
-
-  return true;
+  if(m_deinterlace)
+    m_omx_image_fx.FlushInput();
 }
 
 ///////////////////////////////////////////////////////////////////////////////////////////
 void COMXVideo::SetVideoRect(const CRect& SrcRect, const CRect& DestRect)
 {
+  CSingleLock lock (m_critSection);
   if(!m_is_open)
     return;
 
   OMX_CONFIG_DISPLAYREGIONTYPE configDisplay;
-  float sx1 = SrcRect.x1, sy1 = SrcRect.y1, sx2 = SrcRect.x2, sy2 = SrcRect.y2;
-  float dx1 = DestRect.x1, dy1 = DestRect.y1, dx2 = DestRect.x2, dy2 = DestRect.y2;
-  float sw = SrcRect.Width() / DestRect.Width();
-  float sh = SrcRect.Height() / DestRect.Height();
-
-  // doesn't like negative coordinates on dest_rect. So adjust by increasing src_rect
-  if (dx1 < 0.0f) {
-    sx1 -= dx1 * sw;
-    dx1 -= dx1;
-  }
-  if (dy1 < 0.0f) {
-    sy1 -= dy1 * sh;
-    dy1 -= dy1;
-  }
 
   OMX_INIT_STRUCTURE(configDisplay);
   configDisplay.nPortIndex = m_omx_render.GetInputPort();
@@ -1013,15 +835,15 @@
   configDisplay.noaspect   = OMX_TRUE;
 
   configDisplay.set                 = (OMX_DISPLAYSETTYPE)(OMX_DISPLAY_SET_DEST_RECT|OMX_DISPLAY_SET_SRC_RECT|OMX_DISPLAY_SET_FULLSCREEN|OMX_DISPLAY_SET_NOASPECT);
-  configDisplay.dest_rect.x_offset  = (int)(dx1+0.5f);
-  configDisplay.dest_rect.y_offset  = (int)(dy1+0.5f);
-  configDisplay.dest_rect.width     = (int)(dx2-dx1+0.5f);
-  configDisplay.dest_rect.height    = (int)(dy2-dy1+0.5f);
-
-  configDisplay.src_rect.x_offset   = (int)(sx1+0.5f);
-  configDisplay.src_rect.y_offset   = (int)(sy1+0.5f);
-  configDisplay.src_rect.width      = (int)(sx2-sx1+0.5f);
-  configDisplay.src_rect.height     = (int)(sy2-sy1+0.5f);
+  configDisplay.dest_rect.x_offset  = (int)(DestRect.x1+0.5f);
+  configDisplay.dest_rect.y_offset  = (int)(DestRect.y1+0.5f);
+  configDisplay.dest_rect.width     = (int)(DestRect.Width()+0.5f);
+  configDisplay.dest_rect.height    = (int)(DestRect.Height()+0.5f);
+
+  configDisplay.src_rect.x_offset   = (int)(SrcRect.x1+0.5f);
+  configDisplay.src_rect.y_offset   = (int)(SrcRect.y1+0.5f);
+  configDisplay.src_rect.width      = (int)(SrcRect.Width()+0.5f);
+  configDisplay.src_rect.height     = (int)(SrcRect.Height()+0.5f);
 
   m_omx_render.SetConfig(OMX_IndexConfigDisplayRegion, &configDisplay);
 
@@ -1032,22 +854,26 @@
 
 int COMXVideo::GetInputBufferSize()
 {
+  CSingleLock lock (m_critSection);
   return m_omx_decoder.GetInputBufferSize();
 }
 
 void COMXVideo::SubmitEOS()
 {
+  CSingleLock lock (m_critSection);
   if(!m_is_open)
     return;
 
   m_submitted_eos = true;
+  m_failed_eos = false;
 
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-  OMX_BUFFERHEADERTYPE *omx_buffer = m_omx_decoder.GetInputBuffer();
+  OMX_BUFFERHEADERTYPE *omx_buffer = m_omx_decoder.GetInputBuffer(1000);
   
   if(omx_buffer == NULL)
   {
     CLog::Log(LOGERROR, "%s::%s - buffer error 0x%08x", CLASSNAME, __func__, omx_err);
+    m_failed_eos = true;
     return;
   }
   
@@ -1063,11 +889,20 @@
     CLog::Log(LOGERROR, "%s::%s - OMX_EmptyThisBuffer() failed with result(0x%x)\n", CLASSNAME, __func__, omx_err);
     return;
   }
+  CLog::Log(LOGINFO, "%s::%s", CLASSNAME, __func__);
 }
 
 bool COMXVideo::IsEOS()
 {
+  CSingleLock lock (m_critSection);
   if(!m_is_open)
     return true;
-  return m_omx_render.IsEOS();
+  if (!m_failed_eos && !m_omx_render.IsEOS())
+    return false;
+  if (m_submitted_eos)
+  {
+    CLog::Log(LOGINFO, "%s::%s", CLASSNAME, __func__);
+    m_submitted_eos = false;
+  }
+  return true;
 }
diff -ur a/xbmc/cores/omxplayer/OMXVideo.h b/xbmc/cores/omxplayer/OMXVideo.h
--- a/xbmc/cores/omxplayer/OMXVideo.h	2015-03-12 20:52:41.090096999 +0100
+++ b/xbmc/cores/omxplayer/OMXVideo.h	2015-03-12 20:48:25.166096999 +0100
@@ -30,13 +30,15 @@
 
 #include "guilib/Geometry.h"
 #include "DVDDemuxers/DVDDemux.h"
+#include "xbmc/settings/VideoSettings.h"
+#include "threads/CriticalSection.h"
 #include <string>
 
 #define VIDEO_BUFFERS 60
 
 #define CLASSNAME "COMXVideo"
 
-typedef void (*ResolutionUpdateCallBackFn)(void *ctx, uint32_t width, uint32_t height);
+typedef void (*ResolutionUpdateCallBackFn)(void *ctx, uint32_t width, uint32_t height, float display_aspect);
 
 class COMXVideo
 {
@@ -46,16 +48,15 @@
 
   // Required overrides
   bool SendDecoderConfig();
-  bool Open(CDVDStreamInfo &hints, OMXClock *clock, bool deinterlace = false, bool hdmi_clock_sync = false);
+  bool Open(CDVDStreamInfo &hints, OMXClock *clock, EDEINTERLACEMODE deinterlace = VS_DEINTERLACEMODE_OFF, bool hdmi_clock_sync = false);
+  bool PortSettingsChanged();
   void RegisterResolutionUpdateCallBack(void *ctx, ResolutionUpdateCallBackFn callback) { m_res_ctx = ctx; m_res_callback = callback; }
   void Close(void);
   unsigned int GetFreeSpace();
   unsigned int GetSize();
-  int  Decode(uint8_t *pData, int iSize, double dts, double pts);
+  int  Decode(uint8_t *pData, int iSize, double pts);
   void Reset(void);
   void SetDropState(bool bDrop);
-  bool Pause();
-  bool Resume();
   std::string GetDecoderName() { return m_video_codec_name; };
   void SetVideoRect(const CRect& SrcRect, const CRect& DestRect);
   int GetInputBufferSize();
@@ -83,22 +84,24 @@
   COMXCoreTunel     m_omx_tunnel_sched;
   COMXCoreTunel     m_omx_tunnel_image_fx;
   bool              m_is_open;
-
-  bool              m_Pause;
+  bool              m_setStartTime;
 
   uint8_t           *m_extradata;
   int               m_extrasize;
 
-  bool              m_video_convert;
   std::string       m_video_codec_name;
 
   bool              m_deinterlace;
+  EDEINTERLACEMODE  m_deinterlace_request;
   bool              m_hdmi_clock_sync;
-  uint32_t          m_history_valid_pts;
   ResolutionUpdateCallBackFn m_res_callback;
   void              *m_res_ctx;
   bool              m_submitted_eos;
-  bool NaluFormatStartCodes(enum CodecID codec, uint8_t *in_extradata, int in_extrasize);
+  bool              m_failed_eos;
+  OMX_DISPLAYTRANSFORMTYPE m_transform;
+  bool              m_settings_changed;
+  static bool NaluFormatStartCodes(enum AVCodecID codec, uint8_t *in_extradata, int in_extrasize);
+  CCriticalSection m_critSection;
 };
 
 #endif
diff -ur a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp	2015-03-12 20:52:41.070096999 +0100
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp	2015-03-12 20:48:25.150096999 +0100
@@ -112,12 +112,14 @@
 
   m_dllSwScale = new DllSwScale;
   m_sw_context = NULL;
+
   /* PLEX */
 #if defined(TARGET_RASPBERRY_PI)
   m_bRGBImageSet = false;
 #endif
   /* END PLEX */
 
+
 }
 
 CLinuxRendererGLES::~CLinuxRendererGLES()
@@ -357,7 +359,6 @@
     return;
 #endif
 
-
   const GLvoid *pixelData = data;
 
   int bps = glFormatElementByteCount(type);
@@ -1015,8 +1016,8 @@
   g_matrices.LoadIdentity();
   VerifyGLState();
   g_matrices.Ortho2D(0, m_sourceWidth, 0, m_sourceHeight);
-  glViewport(0, 0, m_sourceWidth, m_sourceHeight);
-  glScissor(0, 0, m_sourceWidth, m_sourceHeight);
+  CRect viewport(0, 0, m_sourceWidth, m_sourceHeight);
+  g_Windowing.SetViewPort(viewport);
   g_matrices.MatrixMode(MM_MODELVIEW);
   VerifyGLState();
 
@@ -1326,12 +1327,19 @@
 #endif
 }
 
-
 bool CLinuxRendererGLES::RenderCapture(CRenderCapture* capture)
 {
   if (!m_bValidated)
     return false;
 
+  // If rendered directly by the hardware
+  if (m_renderMethod & RENDER_BYPASS)
+  {
+    capture->BeginRender();
+    capture->EndRender();
+    return true;
+  }
+
   // save current video rect
   CRect saveSize = m_destRect;
   saveRotatedCoords();//backup current m_rotatedDestCoords
@@ -1365,7 +1373,7 @@
   // OpenGLES returns in RGBA order but CRenderCapture needs BGRA order
   // XOR Swap RGBA -> BGRA
   unsigned char* pixels = (unsigned char*)capture->GetRenderBuffer();
-  for (int i = 0; i < capture->GetWidth() * capture->GetHeight(); i++, pixels+=4)
+  for (unsigned int i = 0; i < capture->GetWidth() * capture->GetHeight(); i++, pixels+=4)
   {
     std::swap(pixels[0], pixels[2]);
   }
@@ -2001,17 +2009,6 @@
   buf.openMaxBuffer = picture->openMaxBuffer;
 }
 #endif
-#ifdef HAVE_VIDEOTOOLBOXDECODER
-void CLinuxRendererGLES::AddProcessor(struct __CVBuffer *cvBufferRef)
-{
-  YUVBUFFER &buf = m_buffers[NextYV12Texture()];
-  if (buf.cvBufferRef)
-    CVBufferRelease(buf.cvBufferRef);
-  buf.cvBufferRef = cvBufferRef;
-  // retain another reference, this way dvdplayer and renderer can issue releases.
-  CVBufferRetain(buf.cvBufferRef);
-}
-#endif
 
 /* PLEX */
 void CLinuxRendererGLES::SetRGB32Image(const char *image, int nHeight, int nWidth, int nPitch)
@@ -2046,8 +2043,6 @@
   }
 }
 /* END PLEX */
-#endif
-
 
 /* PLEX */
 bool CLinuxRendererGLES::ValidateRenderer()
@@ -2076,3 +2071,17 @@
 }
 /* END PLEX */
 
+#ifdef HAVE_VIDEOTOOLBOXDECODER
+void CLinuxRendererGLES::AddProcessor(struct __CVBuffer *cvBufferRef)
+{
+  YUVBUFFER &buf = m_buffers[NextYV12Texture()];
+  if (buf.cvBufferRef)
+    CVBufferRelease(buf.cvBufferRef);
+  buf.cvBufferRef = cvBufferRef;
+  // retain another reference, this way dvdplayer and renderer can issue releases.
+  CVBufferRetain(buf.cvBufferRef);
+}
+#endif
+
+#endif
+
diff -ur a/xbmc/cores/VideoRenderers/OverlayRendererGL.cpp b/xbmc/cores/VideoRenderers/OverlayRendererGL.cpp
--- a/xbmc/cores/VideoRenderers/OverlayRendererGL.cpp	2015-03-12 20:52:41.070096999 +0100
+++ b/xbmc/cores/VideoRenderers/OverlayRendererGL.cpp	2015-03-12 20:48:25.150096999 +0100
@@ -56,13 +56,19 @@
                       , GLfloat* u, GLfloat* v
                       , GLenum internalFormat, GLenum externalFormat, const GLvoid* pixels)
 {
-  int width2  = NP2(width);
-  int height2 = NP2(height);
+  int width2  = width;
+  int height2 = height;
   char *pixelVector = NULL;
   const GLvoid *pixelData = pixels;
 
   int bytesPerPixel = glFormatElementByteCount(externalFormat);
 
+  if (!g_Windowing.SupportsNPOT(0))
+  {
+    width2  = NP2(width);
+    height2 = NP2(height);
+  }
+
 #ifdef HAS_GLES
   /** OpenGL ES does not support strided texture input. Make a copy without stride **/
   if (stride != width)
diff -ur a/xbmc/cores/VideoRenderers/RenderCapture.cpp b/xbmc/cores/VideoRenderers/RenderCapture.cpp
--- a/xbmc/cores/VideoRenderers/RenderCapture.cpp	2015-03-12 20:52:41.070096999 +0100
+++ b/xbmc/cores/VideoRenderers/RenderCapture.cpp	2015-03-12 20:48:25.150096999 +0100
@@ -54,7 +54,43 @@
     return true;
 }
 
-#if defined(HAS_GL) || defined(HAS_GLES)
+#if defined(TARGET_RASPBERRY_PI)
+
+CRenderCaptureDispmanX::CRenderCaptureDispmanX()
+{
+}
+
+CRenderCaptureDispmanX::~CRenderCaptureDispmanX()
+{
+	delete[] m_pixels;
+}
+
+int CRenderCaptureDispmanX::GetCaptureFormat()
+{
+	return CAPTUREFORMAT_BGRA;
+}
+
+void CRenderCaptureDispmanX::BeginRender()
+{
+}
+
+void CRenderCaptureDispmanX::EndRender()
+{
+	m_pixels = g_RBP.CaptureDisplay(m_width, m_height, NULL, true);
+
+	SetState(CAPTURESTATE_DONE);
+}
+
+void* CRenderCaptureDispmanX::GetRenderBuffer()
+{
+    return m_pixels;
+}
+
+void CRenderCaptureDispmanX::ReadOut()
+{
+}
+
+#elif defined(HAS_GL) || defined(HAS_GLES)
 
 CRenderCaptureGL::CRenderCaptureGL()
 {
diff -ur a/xbmc/cores/VideoRenderers/RenderCapture.h b/xbmc/cores/VideoRenderers/RenderCapture.h
--- a/xbmc/cores/VideoRenderers/RenderCapture.h	2015-03-12 20:52:41.070096999 +0100
+++ b/xbmc/cores/VideoRenderers/RenderCapture.h	2015-03-12 20:48:25.150096999 +0100
@@ -172,7 +172,33 @@
     bool             m_asyncChecked;
 };
 
-#if defined(HAS_GL) || defined(HAS_GLES)
+#if defined(TARGET_RASPBERRY_PI)
+#include "xbmc/linux/RBP.h"
+
+class CRenderCaptureDispmanX : public CRenderCaptureBase
+{
+  public:
+    CRenderCaptureDispmanX();
+    ~CRenderCaptureDispmanX();
+
+    int   GetCaptureFormat();
+
+    void  BeginRender();
+    void  EndRender();
+    void  ReadOut();
+
+    void* GetRenderBuffer();
+};
+
+//used instead of typedef CRenderCaptureGL CRenderCapture
+//since C++ doesn't allow you to forward declare a typedef
+class CRenderCapture : public CRenderCaptureDispmanX
+{
+  public:
+    CRenderCapture() {};
+};
+
+#elif defined(HAS_GL) || defined(HAS_GLES)
 #include "system_gl.h"
 
 class CRenderCaptureGL : public CRenderCaptureBase
diff -ur a/xbmc/cores/VideoRenderers/RenderManager.h b/xbmc/cores/VideoRenderers/RenderManager.h
--- a/xbmc/cores/VideoRenderers/RenderManager.h	2015-03-12 20:52:41.070096999 +0100
+++ b/xbmc/cores/VideoRenderers/RenderManager.h	2015-03-12 20:48:25.150096999 +0100
@@ -42,6 +42,7 @@
 #endif
 /* END PLEX */
 
+
 class CRenderCapture;
 
 namespace DXVA { class CProcessor; }
@@ -155,6 +156,7 @@
       m_pRenderer->SetRGB32Image(image, nHeight, nWidth, nPitch);
   }
   /* END PLEX */
+
 protected:
   void Render(bool clear, DWORD flags, DWORD alpha);
 
